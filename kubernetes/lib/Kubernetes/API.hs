{-
   Kubernetes

   No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

   OpenAPI spec version: 2.0
   Kubernetes API version: v1.9.1
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : Kubernetes.API
-}

{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Kubernetes.API where

import Kubernetes.Core
import Kubernetes.MimeTypes
import Kubernetes.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified GHC.Base as P (Alternative)
import qualified Lens.Micro as L
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Monoid ((<>))
import Data.Function ((&))
import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Admissionregistration

-- *** getAPIGroup

-- | @GET \/apis\/admissionregistration.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup MimeNoContent V1APIGroup accept
getAPIGroup  _ =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup  

-- | @application/json@
instance Consumes GetAPIGroup MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup MimeVndKubernetesProtobuf


-- ** AdmissionregistrationV1alpha1

-- *** createInitializerConfiguration

-- | @POST \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations@
-- 
-- create an InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createInitializerConfiguration 
  :: (Consumes CreateInitializerConfiguration contentType, MimeRender contentType V1alpha1InitializerConfiguration)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha1InitializerConfiguration -- ^ "body"
  -> KubernetesRequest CreateInitializerConfiguration contentType V1alpha1InitializerConfiguration accept
createInitializerConfiguration _  _ body =
  _mkRequest "POST" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateInitializerConfiguration 
instance HasBodyParam CreateInitializerConfiguration V1alpha1InitializerConfiguration 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateInitializerConfiguration MimeAny

-- | @application/json@
instance Produces CreateInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces CreateInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateInitializerConfiguration MimeVndKubernetesProtobuf


-- *** deleteCollectionInitializerConfiguration

-- | @DELETE \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations@
-- 
-- delete collection of InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionInitializerConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionInitializerConfiguration MimeNoContent V1Status accept
deleteCollectionInitializerConfiguration  _ =
  _mkRequest "DELETE" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionInitializerConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionInitializerConfiguration Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionInitializerConfiguration FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionInitializerConfiguration IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionInitializerConfiguration LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionInitializerConfiguration Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionInitializerConfiguration ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionInitializerConfiguration TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionInitializerConfiguration Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionInitializerConfiguration MimeAny

-- | @application/json@
instance Produces DeleteCollectionInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionInitializerConfiguration MimeVndKubernetesProtobuf


-- *** deleteInitializerConfiguration

-- | @DELETE \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations\/{name}@
-- 
-- delete an InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteInitializerConfiguration 
  :: (Consumes DeleteInitializerConfiguration contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the InitializerConfiguration
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteInitializerConfiguration contentType V1Status accept
deleteInitializerConfiguration _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteInitializerConfiguration 
instance HasBodyParam DeleteInitializerConfiguration V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteInitializerConfiguration GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteInitializerConfiguration OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteInitializerConfiguration PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteInitializerConfiguration MimeAny

-- | @application/json@
instance Produces DeleteInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces DeleteInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteInitializerConfiguration MimeVndKubernetesProtobuf


-- *** getAPIResources2

-- | @GET \/apis\/admissionregistration.k8s.io\/v1alpha1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources2 MimeNoContent V1APIResourceList accept
getAPIResources2  _ =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1alpha1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources2  

-- | @application/json@
instance Consumes GetAPIResources2 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources2 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources2 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources2 MimeVndKubernetesProtobuf


-- *** listInitializerConfiguration

-- | @GET \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations@
-- 
-- list or watch objects of kind InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listInitializerConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListInitializerConfiguration MimeNoContent V1alpha1InitializerConfigurationList accept
listInitializerConfiguration  _ =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListInitializerConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListInitializerConfiguration Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListInitializerConfiguration FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListInitializerConfiguration IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListInitializerConfiguration LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListInitializerConfiguration Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListInitializerConfiguration ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListInitializerConfiguration TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListInitializerConfiguration Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListInitializerConfiguration MimeAny

-- | @application/json@
instance Produces ListInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces ListInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListInitializerConfiguration MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListInitializerConfiguration MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListInitializerConfiguration MimeVndKubernetesProtobufstreamwatch


-- *** patchInitializerConfiguration

-- | @PATCH \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations\/{name}@
-- 
-- partially update the specified InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchInitializerConfiguration 
  :: (Consumes PatchInitializerConfiguration contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the InitializerConfiguration
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchInitializerConfiguration contentType V1alpha1InitializerConfiguration accept
patchInitializerConfiguration _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchInitializerConfiguration 
instance HasBodyParam PatchInitializerConfiguration A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchInitializerConfiguration MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchInitializerConfiguration MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchInitializerConfiguration MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces PatchInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchInitializerConfiguration MimeVndKubernetesProtobuf


-- *** readInitializerConfiguration

-- | @GET \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations\/{name}@
-- 
-- read the specified InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readInitializerConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the InitializerConfiguration
  -> KubernetesRequest ReadInitializerConfiguration MimeNoContent V1alpha1InitializerConfiguration accept
readInitializerConfiguration  _ (Name name) =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadInitializerConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadInitializerConfiguration Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadInitializerConfiguration Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadInitializerConfiguration MimeAny

-- | @application/json@
instance Produces ReadInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces ReadInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadInitializerConfiguration MimeVndKubernetesProtobuf


-- *** replaceInitializerConfiguration

-- | @PUT \/apis\/admissionregistration.k8s.io\/v1alpha1\/initializerconfigurations\/{name}@
-- 
-- replace the specified InitializerConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceInitializerConfiguration 
  :: (Consumes ReplaceInitializerConfiguration contentType, MimeRender contentType V1alpha1InitializerConfiguration)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the InitializerConfiguration
  -> V1alpha1InitializerConfiguration -- ^ "body"
  -> KubernetesRequest ReplaceInitializerConfiguration contentType V1alpha1InitializerConfiguration accept
replaceInitializerConfiguration _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceInitializerConfiguration 
instance HasBodyParam ReplaceInitializerConfiguration V1alpha1InitializerConfiguration 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceInitializerConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceInitializerConfiguration MimeAny

-- | @application/json@
instance Produces ReplaceInitializerConfiguration MimeJSON
-- | @application/yaml@
instance Produces ReplaceInitializerConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceInitializerConfiguration MimeVndKubernetesProtobuf


-- ** AdmissionregistrationV1beta1

-- *** createMutatingWebhookConfiguration

-- | @POST \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations@
-- 
-- create a MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createMutatingWebhookConfiguration 
  :: (Consumes CreateMutatingWebhookConfiguration contentType, MimeRender contentType V1beta1MutatingWebhookConfiguration)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1MutatingWebhookConfiguration -- ^ "body"
  -> KubernetesRequest CreateMutatingWebhookConfiguration contentType V1beta1MutatingWebhookConfiguration accept
createMutatingWebhookConfiguration _  _ body =
  _mkRequest "POST" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateMutatingWebhookConfiguration 
instance HasBodyParam CreateMutatingWebhookConfiguration V1beta1MutatingWebhookConfiguration 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateMutatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces CreateMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces CreateMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateMutatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** createValidatingWebhookConfiguration

-- | @POST \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations@
-- 
-- create a ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createValidatingWebhookConfiguration 
  :: (Consumes CreateValidatingWebhookConfiguration contentType, MimeRender contentType V1beta1ValidatingWebhookConfiguration)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1ValidatingWebhookConfiguration -- ^ "body"
  -> KubernetesRequest CreateValidatingWebhookConfiguration contentType V1beta1ValidatingWebhookConfiguration accept
createValidatingWebhookConfiguration _  _ body =
  _mkRequest "POST" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateValidatingWebhookConfiguration 
instance HasBodyParam CreateValidatingWebhookConfiguration V1beta1ValidatingWebhookConfiguration 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateValidatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces CreateValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces CreateValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateValidatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** deleteCollectionMutatingWebhookConfiguration

-- | @DELETE \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations@
-- 
-- delete collection of MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionMutatingWebhookConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionMutatingWebhookConfiguration MimeNoContent V1Status accept
deleteCollectionMutatingWebhookConfiguration  _ =
  _mkRequest "DELETE" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionMutatingWebhookConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionMutatingWebhookConfiguration Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionMutatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces DeleteCollectionMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionMutatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** deleteCollectionValidatingWebhookConfiguration

-- | @DELETE \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations@
-- 
-- delete collection of ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionValidatingWebhookConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionValidatingWebhookConfiguration MimeNoContent V1Status accept
deleteCollectionValidatingWebhookConfiguration  _ =
  _mkRequest "DELETE" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionValidatingWebhookConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionValidatingWebhookConfiguration Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionValidatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces DeleteCollectionValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionValidatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** deleteMutatingWebhookConfiguration

-- | @DELETE \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations\/{name}@
-- 
-- delete a MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteMutatingWebhookConfiguration 
  :: (Consumes DeleteMutatingWebhookConfiguration contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the MutatingWebhookConfiguration
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteMutatingWebhookConfiguration contentType V1Status accept
deleteMutatingWebhookConfiguration _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteMutatingWebhookConfiguration 
instance HasBodyParam DeleteMutatingWebhookConfiguration V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteMutatingWebhookConfiguration GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteMutatingWebhookConfiguration OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteMutatingWebhookConfiguration PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteMutatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces DeleteMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces DeleteMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteMutatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** deleteValidatingWebhookConfiguration

-- | @DELETE \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations\/{name}@
-- 
-- delete a ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteValidatingWebhookConfiguration 
  :: (Consumes DeleteValidatingWebhookConfiguration contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ValidatingWebhookConfiguration
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteValidatingWebhookConfiguration contentType V1Status accept
deleteValidatingWebhookConfiguration _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteValidatingWebhookConfiguration 
instance HasBodyParam DeleteValidatingWebhookConfiguration V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteValidatingWebhookConfiguration GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteValidatingWebhookConfiguration OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteValidatingWebhookConfiguration PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteValidatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces DeleteValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces DeleteValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteValidatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** getAPIResources3

-- | @GET \/apis\/admissionregistration.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources3 MimeNoContent V1APIResourceList accept
getAPIResources3  _ =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources3  

-- | @application/json@
instance Consumes GetAPIResources3 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources3 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources3 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources3 MimeVndKubernetesProtobuf


-- *** listMutatingWebhookConfiguration

-- | @GET \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations@
-- 
-- list or watch objects of kind MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listMutatingWebhookConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListMutatingWebhookConfiguration MimeNoContent V1beta1MutatingWebhookConfigurationList accept
listMutatingWebhookConfiguration  _ =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListMutatingWebhookConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListMutatingWebhookConfiguration Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListMutatingWebhookConfiguration FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListMutatingWebhookConfiguration IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListMutatingWebhookConfiguration LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListMutatingWebhookConfiguration Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListMutatingWebhookConfiguration ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListMutatingWebhookConfiguration TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListMutatingWebhookConfiguration Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListMutatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces ListMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces ListMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListMutatingWebhookConfiguration MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListMutatingWebhookConfiguration MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListMutatingWebhookConfiguration MimeVndKubernetesProtobufstreamwatch


-- *** listValidatingWebhookConfiguration

-- | @GET \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations@
-- 
-- list or watch objects of kind ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listValidatingWebhookConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListValidatingWebhookConfiguration MimeNoContent V1beta1ValidatingWebhookConfigurationList accept
listValidatingWebhookConfiguration  _ =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListValidatingWebhookConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListValidatingWebhookConfiguration Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListValidatingWebhookConfiguration FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListValidatingWebhookConfiguration IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListValidatingWebhookConfiguration LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListValidatingWebhookConfiguration Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListValidatingWebhookConfiguration ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListValidatingWebhookConfiguration TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListValidatingWebhookConfiguration Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListValidatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces ListValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces ListValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListValidatingWebhookConfiguration MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListValidatingWebhookConfiguration MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListValidatingWebhookConfiguration MimeVndKubernetesProtobufstreamwatch


-- *** patchMutatingWebhookConfiguration

-- | @PATCH \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations\/{name}@
-- 
-- partially update the specified MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchMutatingWebhookConfiguration 
  :: (Consumes PatchMutatingWebhookConfiguration contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the MutatingWebhookConfiguration
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchMutatingWebhookConfiguration contentType V1beta1MutatingWebhookConfiguration accept
patchMutatingWebhookConfiguration _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchMutatingWebhookConfiguration 
instance HasBodyParam PatchMutatingWebhookConfiguration A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchMutatingWebhookConfiguration MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchMutatingWebhookConfiguration MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchMutatingWebhookConfiguration MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces PatchMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchMutatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** patchValidatingWebhookConfiguration

-- | @PATCH \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations\/{name}@
-- 
-- partially update the specified ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchValidatingWebhookConfiguration 
  :: (Consumes PatchValidatingWebhookConfiguration contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ValidatingWebhookConfiguration
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchValidatingWebhookConfiguration contentType V1beta1ValidatingWebhookConfiguration accept
patchValidatingWebhookConfiguration _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchValidatingWebhookConfiguration 
instance HasBodyParam PatchValidatingWebhookConfiguration A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchValidatingWebhookConfiguration MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchValidatingWebhookConfiguration MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchValidatingWebhookConfiguration MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces PatchValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchValidatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** readMutatingWebhookConfiguration

-- | @GET \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations\/{name}@
-- 
-- read the specified MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readMutatingWebhookConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the MutatingWebhookConfiguration
  -> KubernetesRequest ReadMutatingWebhookConfiguration MimeNoContent V1beta1MutatingWebhookConfiguration accept
readMutatingWebhookConfiguration  _ (Name name) =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadMutatingWebhookConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadMutatingWebhookConfiguration Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadMutatingWebhookConfiguration Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadMutatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces ReadMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces ReadMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadMutatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** readValidatingWebhookConfiguration

-- | @GET \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations\/{name}@
-- 
-- read the specified ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readValidatingWebhookConfiguration 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ValidatingWebhookConfiguration
  -> KubernetesRequest ReadValidatingWebhookConfiguration MimeNoContent V1beta1ValidatingWebhookConfiguration accept
readValidatingWebhookConfiguration  _ (Name name) =
  _mkRequest "GET" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadValidatingWebhookConfiguration  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadValidatingWebhookConfiguration Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadValidatingWebhookConfiguration Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadValidatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces ReadValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces ReadValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadValidatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** replaceMutatingWebhookConfiguration

-- | @PUT \/apis\/admissionregistration.k8s.io\/v1beta1\/mutatingwebhookconfigurations\/{name}@
-- 
-- replace the specified MutatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceMutatingWebhookConfiguration 
  :: (Consumes ReplaceMutatingWebhookConfiguration contentType, MimeRender contentType V1beta1MutatingWebhookConfiguration)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the MutatingWebhookConfiguration
  -> V1beta1MutatingWebhookConfiguration -- ^ "body"
  -> KubernetesRequest ReplaceMutatingWebhookConfiguration contentType V1beta1MutatingWebhookConfiguration accept
replaceMutatingWebhookConfiguration _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceMutatingWebhookConfiguration 
instance HasBodyParam ReplaceMutatingWebhookConfiguration V1beta1MutatingWebhookConfiguration 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceMutatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceMutatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces ReplaceMutatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces ReplaceMutatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceMutatingWebhookConfiguration MimeVndKubernetesProtobuf


-- *** replaceValidatingWebhookConfiguration

-- | @PUT \/apis\/admissionregistration.k8s.io\/v1beta1\/validatingwebhookconfigurations\/{name}@
-- 
-- replace the specified ValidatingWebhookConfiguration
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceValidatingWebhookConfiguration 
  :: (Consumes ReplaceValidatingWebhookConfiguration contentType, MimeRender contentType V1beta1ValidatingWebhookConfiguration)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ValidatingWebhookConfiguration
  -> V1beta1ValidatingWebhookConfiguration -- ^ "body"
  -> KubernetesRequest ReplaceValidatingWebhookConfiguration contentType V1beta1ValidatingWebhookConfiguration accept
replaceValidatingWebhookConfiguration _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceValidatingWebhookConfiguration 
instance HasBodyParam ReplaceValidatingWebhookConfiguration V1beta1ValidatingWebhookConfiguration 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceValidatingWebhookConfiguration Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceValidatingWebhookConfiguration MimeAny

-- | @application/json@
instance Produces ReplaceValidatingWebhookConfiguration MimeJSON
-- | @application/yaml@
instance Produces ReplaceValidatingWebhookConfiguration MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceValidatingWebhookConfiguration MimeVndKubernetesProtobuf


-- ** Apiextensions

-- *** getAPIGroup2

-- | @GET \/apis\/apiextensions.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup2 MimeNoContent V1APIGroup accept
getAPIGroup2  _ =
  _mkRequest "GET" ["/apis/apiextensions.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup2  

-- | @application/json@
instance Consumes GetAPIGroup2 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup2 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup2 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup2 MimeVndKubernetesProtobuf


-- ** ApiextensionsV1beta1

-- *** createCustomResourceDefinition

-- | @POST \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions@
-- 
-- create a CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createCustomResourceDefinition 
  :: (Consumes CreateCustomResourceDefinition contentType, MimeRender contentType V1beta1CustomResourceDefinition)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1CustomResourceDefinition -- ^ "body"
  -> KubernetesRequest CreateCustomResourceDefinition contentType V1beta1CustomResourceDefinition accept
createCustomResourceDefinition _  _ body =
  _mkRequest "POST" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateCustomResourceDefinition 
instance HasBodyParam CreateCustomResourceDefinition V1beta1CustomResourceDefinition 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateCustomResourceDefinition MimeAny

-- | @application/json@
instance Produces CreateCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces CreateCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateCustomResourceDefinition MimeVndKubernetesProtobuf


-- *** deleteCollectionCustomResourceDefinition

-- | @DELETE \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions@
-- 
-- delete collection of CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionCustomResourceDefinition 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionCustomResourceDefinition MimeNoContent V1Status accept
deleteCollectionCustomResourceDefinition  _ =
  _mkRequest "DELETE" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionCustomResourceDefinition  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionCustomResourceDefinition Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionCustomResourceDefinition MimeAny

-- | @application/json@
instance Produces DeleteCollectionCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionCustomResourceDefinition MimeVndKubernetesProtobuf


-- *** deleteCustomResourceDefinition

-- | @DELETE \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions\/{name}@
-- 
-- delete a CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCustomResourceDefinition 
  :: (Consumes DeleteCustomResourceDefinition contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CustomResourceDefinition
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteCustomResourceDefinition contentType V1Status accept
deleteCustomResourceDefinition _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteCustomResourceDefinition 
instance HasBodyParam DeleteCustomResourceDefinition V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCustomResourceDefinition GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCustomResourceDefinition OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCustomResourceDefinition PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteCustomResourceDefinition MimeAny

-- | @application/json@
instance Produces DeleteCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces DeleteCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCustomResourceDefinition MimeVndKubernetesProtobuf


-- *** getAPIResources4

-- | @GET \/apis\/apiextensions.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources4 MimeNoContent V1APIResourceList accept
getAPIResources4  _ =
  _mkRequest "GET" ["/apis/apiextensions.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources4  

-- | @application/json@
instance Consumes GetAPIResources4 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources4 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources4 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources4 MimeVndKubernetesProtobuf


-- *** listCustomResourceDefinition

-- | @GET \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions@
-- 
-- list or watch objects of kind CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listCustomResourceDefinition 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListCustomResourceDefinition MimeNoContent V1beta1CustomResourceDefinitionList accept
listCustomResourceDefinition  _ =
  _mkRequest "GET" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListCustomResourceDefinition  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListCustomResourceDefinition Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListCustomResourceDefinition FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListCustomResourceDefinition IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListCustomResourceDefinition LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListCustomResourceDefinition Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListCustomResourceDefinition ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListCustomResourceDefinition TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListCustomResourceDefinition Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListCustomResourceDefinition MimeAny

-- | @application/json@
instance Produces ListCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces ListCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListCustomResourceDefinition MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListCustomResourceDefinition MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListCustomResourceDefinition MimeVndKubernetesProtobufstreamwatch


-- *** patchCustomResourceDefinition

-- | @PATCH \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions\/{name}@
-- 
-- partially update the specified CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchCustomResourceDefinition 
  :: (Consumes PatchCustomResourceDefinition contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CustomResourceDefinition
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchCustomResourceDefinition contentType V1beta1CustomResourceDefinition accept
patchCustomResourceDefinition _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchCustomResourceDefinition 
instance HasBodyParam PatchCustomResourceDefinition A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchCustomResourceDefinition MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchCustomResourceDefinition MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchCustomResourceDefinition MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces PatchCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchCustomResourceDefinition MimeVndKubernetesProtobuf


-- *** readCustomResourceDefinition

-- | @GET \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions\/{name}@
-- 
-- read the specified CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readCustomResourceDefinition 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CustomResourceDefinition
  -> KubernetesRequest ReadCustomResourceDefinition MimeNoContent V1beta1CustomResourceDefinition accept
readCustomResourceDefinition  _ (Name name) =
  _mkRequest "GET" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadCustomResourceDefinition  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadCustomResourceDefinition Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadCustomResourceDefinition Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadCustomResourceDefinition MimeAny

-- | @application/json@
instance Produces ReadCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces ReadCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadCustomResourceDefinition MimeVndKubernetesProtobuf


-- *** replaceCustomResourceDefinition

-- | @PUT \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions\/{name}@
-- 
-- replace the specified CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceCustomResourceDefinition 
  :: (Consumes ReplaceCustomResourceDefinition contentType, MimeRender contentType V1beta1CustomResourceDefinition)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CustomResourceDefinition
  -> V1beta1CustomResourceDefinition -- ^ "body"
  -> KubernetesRequest ReplaceCustomResourceDefinition contentType V1beta1CustomResourceDefinition accept
replaceCustomResourceDefinition _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceCustomResourceDefinition 
instance HasBodyParam ReplaceCustomResourceDefinition V1beta1CustomResourceDefinition 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceCustomResourceDefinition Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceCustomResourceDefinition MimeAny

-- | @application/json@
instance Produces ReplaceCustomResourceDefinition MimeJSON
-- | @application/yaml@
instance Produces ReplaceCustomResourceDefinition MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceCustomResourceDefinition MimeVndKubernetesProtobuf


-- *** replaceCustomResourceDefinitionStatus

-- | @PUT \/apis\/apiextensions.k8s.io\/v1beta1\/customresourcedefinitions\/{name}\/status@
-- 
-- replace status of the specified CustomResourceDefinition
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceCustomResourceDefinitionStatus 
  :: (Consumes ReplaceCustomResourceDefinitionStatus contentType, MimeRender contentType V1beta1CustomResourceDefinition)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CustomResourceDefinition
  -> V1beta1CustomResourceDefinition -- ^ "body"
  -> KubernetesRequest ReplaceCustomResourceDefinitionStatus contentType V1beta1CustomResourceDefinition accept
replaceCustomResourceDefinitionStatus _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceCustomResourceDefinitionStatus 
instance HasBodyParam ReplaceCustomResourceDefinitionStatus V1beta1CustomResourceDefinition 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceCustomResourceDefinitionStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceCustomResourceDefinitionStatus MimeAny

-- | @application/json@
instance Produces ReplaceCustomResourceDefinitionStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceCustomResourceDefinitionStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceCustomResourceDefinitionStatus MimeVndKubernetesProtobuf


-- ** Apiregistration

-- *** getAPIGroup3

-- | @GET \/apis\/apiregistration.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup3 MimeNoContent V1APIGroup accept
getAPIGroup3  _ =
  _mkRequest "GET" ["/apis/apiregistration.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup3  

-- | @application/json@
instance Consumes GetAPIGroup3 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup3 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup3 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup3 MimeVndKubernetesProtobuf


-- ** ApiregistrationV1beta1

-- *** createAPIService

-- | @POST \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices@
-- 
-- create an APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createAPIService 
  :: (Consumes CreateAPIService contentType, MimeRender contentType V1beta1APIService)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1APIService -- ^ "body"
  -> KubernetesRequest CreateAPIService contentType V1beta1APIService accept
createAPIService _  _ body =
  _mkRequest "POST" ["/apis/apiregistration.k8s.io/v1beta1/apiservices"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateAPIService 
instance HasBodyParam CreateAPIService V1beta1APIService 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateAPIService MimeAny

-- | @application/json@
instance Produces CreateAPIService MimeJSON
-- | @application/yaml@
instance Produces CreateAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateAPIService MimeVndKubernetesProtobuf


-- *** deleteAPIService

-- | @DELETE \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices\/{name}@
-- 
-- delete an APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteAPIService 
  :: (Consumes DeleteAPIService contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the APIService
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteAPIService contentType V1Status accept
deleteAPIService _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/apiregistration.k8s.io/v1beta1/apiservices/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteAPIService 
instance HasBodyParam DeleteAPIService V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteAPIService GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteAPIService OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteAPIService PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteAPIService MimeAny

-- | @application/json@
instance Produces DeleteAPIService MimeJSON
-- | @application/yaml@
instance Produces DeleteAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteAPIService MimeVndKubernetesProtobuf


-- *** deleteCollectionAPIService

-- | @DELETE \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices@
-- 
-- delete collection of APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionAPIService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionAPIService MimeNoContent V1Status accept
deleteCollectionAPIService  _ =
  _mkRequest "DELETE" ["/apis/apiregistration.k8s.io/v1beta1/apiservices"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionAPIService  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionAPIService Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionAPIService FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionAPIService IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionAPIService LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionAPIService Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionAPIService ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionAPIService TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionAPIService Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionAPIService MimeAny

-- | @application/json@
instance Produces DeleteCollectionAPIService MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionAPIService MimeVndKubernetesProtobuf


-- *** getAPIResources5

-- | @GET \/apis\/apiregistration.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources5 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources5 MimeNoContent V1APIResourceList accept
getAPIResources5  _ =
  _mkRequest "GET" ["/apis/apiregistration.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources5  

-- | @application/json@
instance Consumes GetAPIResources5 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources5 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources5 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources5 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources5 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources5 MimeVndKubernetesProtobuf


-- *** listAPIService

-- | @GET \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices@
-- 
-- list or watch objects of kind APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listAPIService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListAPIService MimeNoContent V1beta1APIServiceList accept
listAPIService  _ =
  _mkRequest "GET" ["/apis/apiregistration.k8s.io/v1beta1/apiservices"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListAPIService  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListAPIService Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListAPIService FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListAPIService IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListAPIService LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListAPIService Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListAPIService ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListAPIService TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListAPIService Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListAPIService MimeAny

-- | @application/json@
instance Produces ListAPIService MimeJSON
-- | @application/yaml@
instance Produces ListAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListAPIService MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListAPIService MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListAPIService MimeVndKubernetesProtobufstreamwatch


-- *** patchAPIService

-- | @PATCH \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices\/{name}@
-- 
-- partially update the specified APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchAPIService 
  :: (Consumes PatchAPIService contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the APIService
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchAPIService contentType V1beta1APIService accept
patchAPIService _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/apiregistration.k8s.io/v1beta1/apiservices/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchAPIService 
instance HasBodyParam PatchAPIService A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchAPIService MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchAPIService MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchAPIService MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchAPIService MimeJSON
-- | @application/yaml@
instance Produces PatchAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchAPIService MimeVndKubernetesProtobuf


-- *** readAPIService

-- | @GET \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices\/{name}@
-- 
-- read the specified APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readAPIService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the APIService
  -> KubernetesRequest ReadAPIService MimeNoContent V1beta1APIService accept
readAPIService  _ (Name name) =
  _mkRequest "GET" ["/apis/apiregistration.k8s.io/v1beta1/apiservices/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadAPIService  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadAPIService Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadAPIService Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadAPIService MimeAny

-- | @application/json@
instance Produces ReadAPIService MimeJSON
-- | @application/yaml@
instance Produces ReadAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadAPIService MimeVndKubernetesProtobuf


-- *** replaceAPIService

-- | @PUT \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices\/{name}@
-- 
-- replace the specified APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceAPIService 
  :: (Consumes ReplaceAPIService contentType, MimeRender contentType V1beta1APIService)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the APIService
  -> V1beta1APIService -- ^ "body"
  -> KubernetesRequest ReplaceAPIService contentType V1beta1APIService accept
replaceAPIService _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/apiregistration.k8s.io/v1beta1/apiservices/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceAPIService 
instance HasBodyParam ReplaceAPIService V1beta1APIService 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceAPIService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceAPIService MimeAny

-- | @application/json@
instance Produces ReplaceAPIService MimeJSON
-- | @application/yaml@
instance Produces ReplaceAPIService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceAPIService MimeVndKubernetesProtobuf


-- *** replaceAPIServiceStatus

-- | @PUT \/apis\/apiregistration.k8s.io\/v1beta1\/apiservices\/{name}\/status@
-- 
-- replace status of the specified APIService
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceAPIServiceStatus 
  :: (Consumes ReplaceAPIServiceStatus contentType, MimeRender contentType V1beta1APIService)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the APIService
  -> V1beta1APIService -- ^ "body"
  -> KubernetesRequest ReplaceAPIServiceStatus contentType V1beta1APIService accept
replaceAPIServiceStatus _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/apiregistration.k8s.io/v1beta1/apiservices/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceAPIServiceStatus 
instance HasBodyParam ReplaceAPIServiceStatus V1beta1APIService 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceAPIServiceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceAPIServiceStatus MimeAny

-- | @application/json@
instance Produces ReplaceAPIServiceStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceAPIServiceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceAPIServiceStatus MimeVndKubernetesProtobuf


-- ** Apis

-- *** getAPIVersions2

-- | @GET \/apis\/@
-- 
-- get available API versions
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIVersions2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIVersions2 MimeNoContent V1APIGroupList accept
getAPIVersions2  _ =
  _mkRequest "GET" ["/apis/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIVersions2  

-- | @application/json@
instance Consumes GetAPIVersions2 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIVersions2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIVersions2 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIVersions2 MimeJSON
-- | @application/yaml@
instance Produces GetAPIVersions2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIVersions2 MimeVndKubernetesProtobuf


-- ** Apps

-- *** getAPIGroup4

-- | @GET \/apis\/apps\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup4 MimeNoContent V1APIGroup accept
getAPIGroup4  _ =
  _mkRequest "GET" ["/apis/apps/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup4  

-- | @application/json@
instance Consumes GetAPIGroup4 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup4 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup4 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup4 MimeVndKubernetesProtobuf


-- ** AppsV1

-- *** createNamespacedControllerRevision

-- | @POST \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- create a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedControllerRevision 
  :: (Consumes CreateNamespacedControllerRevision contentType, MimeRender contentType V1ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ControllerRevision -- ^ "body"
  -> KubernetesRequest CreateNamespacedControllerRevision contentType V1ControllerRevision accept
createNamespacedControllerRevision _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedControllerRevision 
instance HasBodyParam CreateNamespacedControllerRevision V1ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedControllerRevision MimeAny

-- | @application/json@
instance Produces CreateNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** createNamespacedDaemonSet

-- | @POST \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets@
-- 
-- create a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDaemonSet 
  :: (Consumes CreateNamespacedDaemonSet contentType, MimeRender contentType V1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DaemonSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedDaemonSet contentType V1DaemonSet accept
createNamespacedDaemonSet _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDaemonSet 
instance HasBodyParam CreateNamespacedDaemonSet V1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDaemonSet MimeAny

-- | @application/json@
instance Produces CreateNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** createNamespacedDeployment

-- | @POST \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments@
-- 
-- create a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeployment 
  :: (Consumes CreateNamespacedDeployment contentType, MimeRender contentType V1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Deployment -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeployment contentType V1Deployment accept
createNamespacedDeployment _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeployment 
instance HasBodyParam CreateNamespacedDeployment V1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDeployment MimeAny

-- | @application/json@
instance Produces CreateNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeployment MimeVndKubernetesProtobuf


-- *** createNamespacedReplicaSet

-- | @POST \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets@
-- 
-- create a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedReplicaSet 
  :: (Consumes CreateNamespacedReplicaSet contentType, MimeRender contentType V1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ReplicaSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedReplicaSet contentType V1ReplicaSet accept
createNamespacedReplicaSet _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedReplicaSet 
instance HasBodyParam CreateNamespacedReplicaSet V1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedReplicaSet MimeAny

-- | @application/json@
instance Produces CreateNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** createNamespacedStatefulSet

-- | @POST \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets@
-- 
-- create a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedStatefulSet 
  :: (Consumes CreateNamespacedStatefulSet contentType, MimeRender contentType V1StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1StatefulSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedStatefulSet contentType V1StatefulSet accept
createNamespacedStatefulSet _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedStatefulSet 
instance HasBodyParam CreateNamespacedStatefulSet V1StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedStatefulSet MimeAny

-- | @application/json@
instance Produces CreateNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedControllerRevision

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- delete collection of ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedControllerRevision 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedControllerRevision MimeNoContent V1Status accept
deleteCollectionNamespacedControllerRevision  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedControllerRevision  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedControllerRevision MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDaemonSet

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets@
-- 
-- delete collection of DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDaemonSet MimeNoContent V1Status accept
deleteCollectionNamespacedDaemonSet  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDaemonSet MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDeployment

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments@
-- 
-- delete collection of Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDeployment MimeNoContent V1Status accept
deleteCollectionNamespacedDeployment  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDeployment IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDeployment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDeployment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDeployment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDeployment MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDeployment MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedReplicaSet

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets@
-- 
-- delete collection of ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedReplicaSet MimeNoContent V1Status accept
deleteCollectionNamespacedReplicaSet  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedReplicaSet MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedStatefulSet

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets@
-- 
-- delete collection of StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedStatefulSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedStatefulSet MimeNoContent V1Status accept
deleteCollectionNamespacedStatefulSet  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedStatefulSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedStatefulSet MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** deleteNamespacedControllerRevision

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- delete a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedControllerRevision 
  :: (Consumes DeleteNamespacedControllerRevision contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedControllerRevision contentType V1Status accept
deleteNamespacedControllerRevision _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedControllerRevision 
instance HasBodyParam DeleteNamespacedControllerRevision V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedControllerRevision GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedControllerRevision OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedControllerRevision PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedControllerRevision MimeAny

-- | @application/json@
instance Produces DeleteNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** deleteNamespacedDaemonSet

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- delete a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDaemonSet 
  :: (Consumes DeleteNamespacedDaemonSet contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDaemonSet contentType V1Status accept
deleteNamespacedDaemonSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDaemonSet 
instance HasBodyParam DeleteNamespacedDaemonSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDaemonSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDaemonSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDaemonSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDaemonSet MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** deleteNamespacedDeployment

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- delete a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDeployment 
  :: (Consumes DeleteNamespacedDeployment contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDeployment contentType V1Status accept
deleteNamespacedDeployment _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDeployment 
instance HasBodyParam DeleteNamespacedDeployment V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDeployment GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDeployment OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDeployment PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDeployment MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDeployment MimeVndKubernetesProtobuf


-- *** deleteNamespacedReplicaSet

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- delete a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedReplicaSet 
  :: (Consumes DeleteNamespacedReplicaSet contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedReplicaSet contentType V1Status accept
deleteNamespacedReplicaSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedReplicaSet 
instance HasBodyParam DeleteNamespacedReplicaSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedReplicaSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedReplicaSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedReplicaSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedReplicaSet MimeAny

-- | @application/json@
instance Produces DeleteNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** deleteNamespacedStatefulSet

-- | @DELETE \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- delete a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedStatefulSet 
  :: (Consumes DeleteNamespacedStatefulSet contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedStatefulSet contentType V1Status accept
deleteNamespacedStatefulSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedStatefulSet 
instance HasBodyParam DeleteNamespacedStatefulSet V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedStatefulSet GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedStatefulSet OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedStatefulSet PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedStatefulSet MimeAny

-- | @application/json@
instance Produces DeleteNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** getAPIResources6

-- | @GET \/apis\/apps\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources6 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources6 MimeNoContent V1APIResourceList accept
getAPIResources6  _ =
  _mkRequest "GET" ["/apis/apps/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources6  

-- | @application/json@
instance Consumes GetAPIResources6 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources6 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources6 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources6 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources6 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources6 MimeVndKubernetesProtobuf


-- *** listControllerRevisionForAllNamespaces

-- | @GET \/apis\/apps\/v1\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listControllerRevisionForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListControllerRevisionForAllNamespaces MimeNoContent V1ControllerRevisionList accept
listControllerRevisionForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListControllerRevisionForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListControllerRevisionForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListControllerRevisionForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListControllerRevisionForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListControllerRevisionForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListControllerRevisionForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListControllerRevisionForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListControllerRevisionForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListControllerRevisionForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listDaemonSetForAllNamespaces

-- | @GET \/apis\/apps\/v1\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDaemonSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDaemonSetForAllNamespaces MimeNoContent V1DaemonSetList accept
listDaemonSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDaemonSetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDaemonSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDaemonSetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDaemonSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDaemonSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDaemonSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDaemonSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDaemonSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDaemonSetForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListDaemonSetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListDaemonSetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDaemonSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDaemonSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDaemonSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listDeploymentForAllNamespaces

-- | @GET \/apis\/apps\/v1\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDeploymentForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDeploymentForAllNamespaces MimeNoContent V1DeploymentList accept
listDeploymentForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDeploymentForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDeploymentForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDeploymentForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDeploymentForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDeploymentForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDeploymentForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDeploymentForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDeploymentForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDeploymentForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListDeploymentForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListDeploymentForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDeploymentForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDeploymentForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDeploymentForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedControllerRevision

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedControllerRevision 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedControllerRevision MimeNoContent V1ControllerRevisionList accept
listNamespacedControllerRevision  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedControllerRevision  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedControllerRevision Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedControllerRevision IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedControllerRevision Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedControllerRevision ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedControllerRevision TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedControllerRevision Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedControllerRevision MimeAny

-- | @application/json@
instance Produces ListNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedControllerRevision MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedControllerRevision MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedControllerRevision MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDaemonSet

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDaemonSet MimeNoContent V1DaemonSetList accept
listNamespacedDaemonSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDaemonSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDaemonSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDaemonSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDaemonSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDaemonSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDaemonSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDaemonSet MimeAny

-- | @application/json@
instance Produces ListNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDaemonSet MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDaemonSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDaemonSet MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDeployment

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDeployment MimeNoContent V1DeploymentList accept
listNamespacedDeployment  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDeployment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDeployment IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDeployment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDeployment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDeployment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDeployment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDeployment MimeAny

-- | @application/json@
instance Produces ListNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDeployment MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDeployment MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDeployment MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedReplicaSet

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedReplicaSet MimeNoContent V1ReplicaSetList accept
listNamespacedReplicaSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedReplicaSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedReplicaSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedReplicaSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedReplicaSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedReplicaSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedReplicaSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedReplicaSet MimeAny

-- | @application/json@
instance Produces ListNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedReplicaSet MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedReplicaSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedReplicaSet MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedStatefulSet

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedStatefulSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedStatefulSet MimeNoContent V1StatefulSetList accept
listNamespacedStatefulSet  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedStatefulSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedStatefulSet Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedStatefulSet IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedStatefulSet Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedStatefulSet ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedStatefulSet TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedStatefulSet Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedStatefulSet MimeAny

-- | @application/json@
instance Produces ListNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedStatefulSet MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedStatefulSet MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedStatefulSet MimeVndKubernetesProtobufstreamwatch


-- *** listReplicaSetForAllNamespaces

-- | @GET \/apis\/apps\/v1\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listReplicaSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListReplicaSetForAllNamespaces MimeNoContent V1ReplicaSetList accept
listReplicaSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListReplicaSetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListReplicaSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListReplicaSetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListReplicaSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListReplicaSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListReplicaSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListReplicaSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListReplicaSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListReplicaSetForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListReplicaSetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListReplicaSetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListReplicaSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListReplicaSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListReplicaSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listStatefulSetForAllNamespaces

-- | @GET \/apis\/apps\/v1\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listStatefulSetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListStatefulSetForAllNamespaces MimeNoContent V1StatefulSetList accept
listStatefulSetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/apps/v1/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListStatefulSetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListStatefulSetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListStatefulSetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListStatefulSetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListStatefulSetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListStatefulSetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListStatefulSetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListStatefulSetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListStatefulSetForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListStatefulSetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListStatefulSetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListStatefulSetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListStatefulSetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListStatefulSetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedControllerRevision

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- partially update the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedControllerRevision 
  :: (Consumes PatchNamespacedControllerRevision contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedControllerRevision contentType V1ControllerRevision accept
patchNamespacedControllerRevision _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedControllerRevision 
instance HasBodyParam PatchNamespacedControllerRevision A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedControllerRevision MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedControllerRevision MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedControllerRevision MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSet

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- partially update the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSet 
  :: (Consumes PatchNamespacedDaemonSet contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSet contentType V1DaemonSet accept
patchNamespacedDaemonSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSet 
instance HasBodyParam PatchNamespacedDaemonSet A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSetStatus

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- partially update status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSetStatus 
  :: (Consumes PatchNamespacedDaemonSetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSetStatus contentType V1DaemonSet accept
patchNamespacedDaemonSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSetStatus 
instance HasBodyParam PatchNamespacedDaemonSetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSetStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedDeployment

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- partially update the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeployment 
  :: (Consumes PatchNamespacedDeployment contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeployment contentType V1Deployment accept
patchNamespacedDeployment _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeployment 
instance HasBodyParam PatchNamespacedDeployment A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeployment MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeployment MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeployment MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeployment MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentScale

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- partially update scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentScale 
  :: (Consumes PatchNamespacedDeploymentScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentScale contentType V1Scale accept
patchNamespacedDeploymentScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentScale 
instance HasBodyParam PatchNamespacedDeploymentScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentScale MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentStatus

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- partially update status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentStatus 
  :: (Consumes PatchNamespacedDeploymentStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentStatus contentType V1Deployment accept
patchNamespacedDeploymentStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentStatus 
instance HasBodyParam PatchNamespacedDeploymentStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSet

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- partially update the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSet 
  :: (Consumes PatchNamespacedReplicaSet contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSet contentType V1ReplicaSet accept
patchNamespacedReplicaSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSet 
instance HasBodyParam PatchNamespacedReplicaSet A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetScale

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetScale 
  :: (Consumes PatchNamespacedReplicaSetScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetScale contentType V1Scale accept
patchNamespacedReplicaSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetScale 
instance HasBodyParam PatchNamespacedReplicaSetScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetScale MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetStatus

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- partially update status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetStatus 
  :: (Consumes PatchNamespacedReplicaSetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetStatus contentType V1ReplicaSet accept
patchNamespacedReplicaSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetStatus 
instance HasBodyParam PatchNamespacedReplicaSetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSet

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- partially update the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSet 
  :: (Consumes PatchNamespacedStatefulSet contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSet contentType V1StatefulSet accept
patchNamespacedStatefulSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSet 
instance HasBodyParam PatchNamespacedStatefulSet A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSet MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSet MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSet MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetScale

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- partially update scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetScale 
  :: (Consumes PatchNamespacedStatefulSetScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetScale contentType V1Scale accept
patchNamespacedStatefulSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetScale 
instance HasBodyParam PatchNamespacedStatefulSetScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetScale MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetStatus

-- | @PATCH \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- partially update status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetStatus 
  :: (Consumes PatchNamespacedStatefulSetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetStatus contentType V1StatefulSet accept
patchNamespacedStatefulSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetStatus 
instance HasBodyParam PatchNamespacedStatefulSetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedControllerRevision

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- read the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedControllerRevision 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedControllerRevision MimeNoContent V1ControllerRevision accept
readNamespacedControllerRevision  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedControllerRevision  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedControllerRevision Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedControllerRevision Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedControllerRevision MimeAny

-- | @application/json@
instance Produces ReadNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSet

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- read the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSet MimeNoContent V1DaemonSet accept
readNamespacedDaemonSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDaemonSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDaemonSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDaemonSet MimeAny

-- | @application/json@
instance Produces ReadNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSetStatus

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- read status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSetStatus MimeNoContent V1DaemonSet accept
readNamespacedDaemonSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDaemonSetStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedDaemonSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedDeployment

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- read the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeployment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeployment MimeNoContent V1Deployment accept
readNamespacedDeployment  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeployment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDeployment Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDeployment Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeployment MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeployment MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentScale

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- read scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentScale MimeNoContent V1Scale accept
readNamespacedDeploymentScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentScale MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentScale MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentStatus

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- read status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentStatus MimeNoContent V1Deployment accept
readNamespacedDeploymentStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentStatus MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSet

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- read the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSet MimeNoContent V1ReplicaSet accept
readNamespacedReplicaSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedReplicaSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedReplicaSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSet MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetScale

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- read scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetScale MimeNoContent V1Scale accept
readNamespacedReplicaSetScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSetScale MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSetScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetScale MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetStatus

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- read status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetStatus MimeNoContent V1ReplicaSet accept
readNamespacedReplicaSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSetStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSet

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- read the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSet 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSet MimeNoContent V1StatefulSet accept
readNamespacedStatefulSet  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSet  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedStatefulSet Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedStatefulSet Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSet MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetScale

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- read scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetScale MimeNoContent V1Scale accept
readNamespacedStatefulSetScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSetScale MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSetScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetScale MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetStatus

-- | @GET \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- read status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetStatus MimeNoContent V1StatefulSet accept
readNamespacedStatefulSetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSetStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedControllerRevision

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- replace the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedControllerRevision 
  :: (Consumes ReplaceNamespacedControllerRevision contentType, MimeRender contentType V1ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ControllerRevision -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedControllerRevision contentType V1ControllerRevision accept
replaceNamespacedControllerRevision _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedControllerRevision 
instance HasBodyParam ReplaceNamespacedControllerRevision V1ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedControllerRevision Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedControllerRevision MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedControllerRevision MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedControllerRevision MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedControllerRevision MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSet

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- replace the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSet 
  :: (Consumes ReplaceNamespacedDaemonSet contentType, MimeRender contentType V1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSet contentType V1DaemonSet accept
replaceNamespacedDaemonSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSet 
instance HasBodyParam ReplaceNamespacedDaemonSet V1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDaemonSet MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSet MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSet MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSetStatus

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- replace status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSetStatus 
  :: (Consumes ReplaceNamespacedDaemonSetStatus contentType, MimeRender contentType V1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSetStatus contentType V1DaemonSet accept
replaceNamespacedDaemonSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSetStatus 
instance HasBodyParam ReplaceNamespacedDaemonSetStatus V1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDaemonSetStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeployment

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- replace the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeployment 
  :: (Consumes ReplaceNamespacedDeployment contentType, MimeRender contentType V1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeployment contentType V1Deployment accept
replaceNamespacedDeployment _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeployment 
instance HasBodyParam ReplaceNamespacedDeployment V1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeployment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeployment MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeployment MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeployment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeployment MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentScale

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- replace scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentScale 
  :: (Consumes ReplaceNamespacedDeploymentScale contentType, MimeRender contentType V1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentScale contentType V1Scale accept
replaceNamespacedDeploymentScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentScale 
instance HasBodyParam ReplaceNamespacedDeploymentScale V1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentScale MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentStatus

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- replace status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentStatus 
  :: (Consumes ReplaceNamespacedDeploymentStatus contentType, MimeRender contentType V1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentStatus contentType V1Deployment accept
replaceNamespacedDeploymentStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentStatus 
instance HasBodyParam ReplaceNamespacedDeploymentStatus V1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSet

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- replace the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSet 
  :: (Consumes ReplaceNamespacedReplicaSet contentType, MimeRender contentType V1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSet contentType V1ReplicaSet accept
replaceNamespacedReplicaSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSet 
instance HasBodyParam ReplaceNamespacedReplicaSet V1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSet MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSet MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSet MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetScale

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- replace scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetScale 
  :: (Consumes ReplaceNamespacedReplicaSetScale contentType, MimeRender contentType V1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetScale contentType V1Scale accept
replaceNamespacedReplicaSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetScale 
instance HasBodyParam ReplaceNamespacedReplicaSetScale V1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSetScale MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetStatus

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- replace status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetStatus 
  :: (Consumes ReplaceNamespacedReplicaSetStatus contentType, MimeRender contentType V1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetStatus contentType V1ReplicaSet accept
replaceNamespacedReplicaSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetStatus 
instance HasBodyParam ReplaceNamespacedReplicaSetStatus V1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSetStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSet

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- replace the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSet 
  :: (Consumes ReplaceNamespacedStatefulSet contentType, MimeRender contentType V1StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSet contentType V1StatefulSet accept
replaceNamespacedStatefulSet _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSet 
instance HasBodyParam ReplaceNamespacedStatefulSet V1StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSet Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSet MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSet MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSet MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSet MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetScale

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- replace scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetScale 
  :: (Consumes ReplaceNamespacedStatefulSetScale contentType, MimeRender contentType V1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetScale contentType V1Scale accept
replaceNamespacedStatefulSetScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetScale 
instance HasBodyParam ReplaceNamespacedStatefulSetScale V1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSetScale MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetStatus

-- | @PUT \/apis\/apps\/v1\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- replace status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetStatus 
  :: (Consumes ReplaceNamespacedStatefulSetStatus contentType, MimeRender contentType V1StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetStatus contentType V1StatefulSet accept
replaceNamespacedStatefulSetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetStatus 
instance HasBodyParam ReplaceNamespacedStatefulSetStatus V1StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSetStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetStatus MimeVndKubernetesProtobuf


-- ** AppsV1beta1

-- *** createNamespacedControllerRevision2

-- | @POST \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- create a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedControllerRevision2 
  :: (Consumes CreateNamespacedControllerRevision2 contentType, MimeRender contentType V1beta1ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1ControllerRevision -- ^ "body"
  -> KubernetesRequest CreateNamespacedControllerRevision2 contentType V1beta1ControllerRevision accept
createNamespacedControllerRevision2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedControllerRevision2 
instance HasBodyParam CreateNamespacedControllerRevision2 V1beta1ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedControllerRevision2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedControllerRevision2 MimeVndKubernetesProtobuf


-- *** createNamespacedDeployment2

-- | @POST \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- create a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeployment2 
  :: (Consumes CreateNamespacedDeployment2 contentType, MimeRender contentType AppsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> AppsV1beta1Deployment -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeployment2 contentType AppsV1beta1Deployment accept
createNamespacedDeployment2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeployment2 
instance HasBodyParam CreateNamespacedDeployment2 AppsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDeployment2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeployment2 MimeVndKubernetesProtobuf


-- *** createNamespacedDeploymentRollback

-- | @POST \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/rollback@
-- 
-- create rollback of a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeploymentRollback 
  :: (Consumes CreateNamespacedDeploymentRollback contentType, MimeRender contentType AppsV1beta1DeploymentRollback)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DeploymentRollback
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> AppsV1beta1DeploymentRollback -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeploymentRollback contentType AppsV1beta1DeploymentRollback accept
createNamespacedDeploymentRollback _  _ (Name name) (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/rollback"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeploymentRollback 
instance HasBodyParam CreateNamespacedDeploymentRollback AppsV1beta1DeploymentRollback 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeploymentRollback Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDeploymentRollback MimeAny

-- | @application/json@
instance Produces CreateNamespacedDeploymentRollback MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeploymentRollback MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeploymentRollback MimeVndKubernetesProtobuf


-- *** createNamespacedStatefulSet2

-- | @POST \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets@
-- 
-- create a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedStatefulSet2 
  :: (Consumes CreateNamespacedStatefulSet2 contentType, MimeRender contentType V1beta1StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1StatefulSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedStatefulSet2 contentType V1beta1StatefulSet accept
createNamespacedStatefulSet2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedStatefulSet2 
instance HasBodyParam CreateNamespacedStatefulSet2 V1beta1StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedStatefulSet2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedStatefulSet2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedControllerRevision2

-- | @DELETE \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- delete collection of ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedControllerRevision2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedControllerRevision2 MimeNoContent V1Status accept
deleteCollectionNamespacedControllerRevision2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedControllerRevision2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedControllerRevision2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedControllerRevision2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDeployment2

-- | @DELETE \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- delete collection of Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDeployment2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDeployment2 MimeNoContent V1Status accept
deleteCollectionNamespacedDeployment2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDeployment2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDeployment2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDeployment2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDeployment2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedStatefulSet2

-- | @DELETE \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets@
-- 
-- delete collection of StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedStatefulSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedStatefulSet2 MimeNoContent V1Status accept
deleteCollectionNamespacedStatefulSet2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedStatefulSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedStatefulSet2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedStatefulSet2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedControllerRevision2

-- | @DELETE \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- delete a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedControllerRevision2 
  :: (Consumes DeleteNamespacedControllerRevision2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedControllerRevision2 contentType V1Status accept
deleteNamespacedControllerRevision2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedControllerRevision2 
instance HasBodyParam DeleteNamespacedControllerRevision2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedControllerRevision2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedControllerRevision2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedControllerRevision2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedControllerRevision2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedControllerRevision2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedDeployment2

-- | @DELETE \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- delete a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDeployment2 
  :: (Consumes DeleteNamespacedDeployment2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDeployment2 contentType V1Status accept
deleteNamespacedDeployment2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDeployment2 
instance HasBodyParam DeleteNamespacedDeployment2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDeployment2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDeployment2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDeployment2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDeployment2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDeployment2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedStatefulSet2

-- | @DELETE \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- delete a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedStatefulSet2 
  :: (Consumes DeleteNamespacedStatefulSet2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedStatefulSet2 contentType V1Status accept
deleteNamespacedStatefulSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedStatefulSet2 
instance HasBodyParam DeleteNamespacedStatefulSet2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedStatefulSet2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedStatefulSet2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedStatefulSet2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedStatefulSet2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedStatefulSet2 MimeVndKubernetesProtobuf


-- *** getAPIResources7

-- | @GET \/apis\/apps\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources7 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources7 MimeNoContent V1APIResourceList accept
getAPIResources7  _ =
  _mkRequest "GET" ["/apis/apps/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources7  

-- | @application/json@
instance Consumes GetAPIResources7 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources7 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources7 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources7 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources7 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources7 MimeVndKubernetesProtobuf


-- *** listControllerRevisionForAllNamespaces2

-- | @GET \/apis\/apps\/v1beta1\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listControllerRevisionForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListControllerRevisionForAllNamespaces2 MimeNoContent V1beta1ControllerRevisionList accept
listControllerRevisionForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/apps/v1beta1/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListControllerRevisionForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListControllerRevisionForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListControllerRevisionForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListControllerRevisionForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListControllerRevisionForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListControllerRevisionForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listDeploymentForAllNamespaces2

-- | @GET \/apis\/apps\/v1beta1\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDeploymentForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDeploymentForAllNamespaces2 MimeNoContent AppsV1beta1DeploymentList accept
listDeploymentForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/apps/v1beta1/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDeploymentForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDeploymentForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDeploymentForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDeploymentForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDeploymentForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDeploymentForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDeploymentForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDeploymentForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDeploymentForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListDeploymentForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListDeploymentForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDeploymentForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDeploymentForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDeploymentForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedControllerRevision2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedControllerRevision2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedControllerRevision2 MimeNoContent V1beta1ControllerRevisionList accept
listNamespacedControllerRevision2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedControllerRevision2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedControllerRevision2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedControllerRevision2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedControllerRevision2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedControllerRevision2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedControllerRevision2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedControllerRevision2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedControllerRevision2 MimeAny

-- | @application/json@
instance Produces ListNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedControllerRevision2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedControllerRevision2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedControllerRevision2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDeployment2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDeployment2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDeployment2 MimeNoContent AppsV1beta1DeploymentList accept
listNamespacedDeployment2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDeployment2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDeployment2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDeployment2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDeployment2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDeployment2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDeployment2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDeployment2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDeployment2 MimeAny

-- | @application/json@
instance Produces ListNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDeployment2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDeployment2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDeployment2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedStatefulSet2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedStatefulSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedStatefulSet2 MimeNoContent V1beta1StatefulSetList accept
listNamespacedStatefulSet2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedStatefulSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedStatefulSet2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedStatefulSet2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedStatefulSet2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedStatefulSet2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedStatefulSet2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedStatefulSet2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedStatefulSet2 MimeAny

-- | @application/json@
instance Produces ListNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedStatefulSet2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedStatefulSet2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedStatefulSet2 MimeVndKubernetesProtobufstreamwatch


-- *** listStatefulSetForAllNamespaces2

-- | @GET \/apis\/apps\/v1beta1\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listStatefulSetForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListStatefulSetForAllNamespaces2 MimeNoContent V1beta1StatefulSetList accept
listStatefulSetForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/apps/v1beta1/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListStatefulSetForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListStatefulSetForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListStatefulSetForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListStatefulSetForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListStatefulSetForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListStatefulSetForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListStatefulSetForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListStatefulSetForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedControllerRevision2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- partially update the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedControllerRevision2 
  :: (Consumes PatchNamespacedControllerRevision2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedControllerRevision2 contentType V1beta1ControllerRevision accept
patchNamespacedControllerRevision2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedControllerRevision2 
instance HasBodyParam PatchNamespacedControllerRevision2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedControllerRevision2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedControllerRevision2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedControllerRevision2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedControllerRevision2 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeployment2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- partially update the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeployment2 
  :: (Consumes PatchNamespacedDeployment2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeployment2 contentType AppsV1beta1Deployment accept
patchNamespacedDeployment2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeployment2 
instance HasBodyParam PatchNamespacedDeployment2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeployment2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeployment2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeployment2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeployment2 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentScale2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- partially update scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentScale2 
  :: (Consumes PatchNamespacedDeploymentScale2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentScale2 contentType AppsV1beta1Scale accept
patchNamespacedDeploymentScale2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentScale2 
instance HasBodyParam PatchNamespacedDeploymentScale2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentScale2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentScale2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentScale2 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentStatus2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- partially update status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentStatus2 
  :: (Consumes PatchNamespacedDeploymentStatus2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentStatus2 contentType AppsV1beta1Deployment accept
patchNamespacedDeploymentStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentStatus2 
instance HasBodyParam PatchNamespacedDeploymentStatus2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentStatus2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentStatus2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentStatus2 MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSet2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- partially update the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSet2 
  :: (Consumes PatchNamespacedStatefulSet2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSet2 contentType V1beta1StatefulSet accept
patchNamespacedStatefulSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSet2 
instance HasBodyParam PatchNamespacedStatefulSet2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSet2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSet2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSet2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSet2 MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetScale2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- partially update scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetScale2 
  :: (Consumes PatchNamespacedStatefulSetScale2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetScale2 contentType AppsV1beta1Scale accept
patchNamespacedStatefulSetScale2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetScale2 
instance HasBodyParam PatchNamespacedStatefulSetScale2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetScale2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetScale2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetScale2 MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetStatus2

-- | @PATCH \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- partially update status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetStatus2 
  :: (Consumes PatchNamespacedStatefulSetStatus2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetStatus2 contentType V1beta1StatefulSet accept
patchNamespacedStatefulSetStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetStatus2 
instance HasBodyParam PatchNamespacedStatefulSetStatus2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetStatus2 MimeVndKubernetesProtobuf


-- *** readNamespacedControllerRevision2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- read the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedControllerRevision2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedControllerRevision2 MimeNoContent V1beta1ControllerRevision accept
readNamespacedControllerRevision2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedControllerRevision2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedControllerRevision2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedControllerRevision2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedControllerRevision2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedControllerRevision2 MimeVndKubernetesProtobuf


-- *** readNamespacedDeployment2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- read the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeployment2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeployment2 MimeNoContent AppsV1beta1Deployment accept
readNamespacedDeployment2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeployment2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDeployment2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDeployment2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeployment2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeployment2 MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentScale2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- read scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentScale2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentScale2 MimeNoContent AppsV1beta1Scale accept
readNamespacedDeploymentScale2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentScale2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentScale2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentScale2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentScale2 MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentStatus2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- read status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentStatus2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentStatus2 MimeNoContent AppsV1beta1Deployment accept
readNamespacedDeploymentStatus2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentStatus2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentStatus2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentStatus2 MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSet2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- read the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSet2 MimeNoContent V1beta1StatefulSet accept
readNamespacedStatefulSet2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedStatefulSet2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedStatefulSet2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSet2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSet2 MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetScale2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- read scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetScale2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetScale2 MimeNoContent AppsV1beta1Scale accept
readNamespacedStatefulSetScale2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetScale2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSetScale2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSetScale2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetScale2 MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetStatus2

-- | @GET \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- read status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetStatus2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetStatus2 MimeNoContent V1beta1StatefulSet accept
readNamespacedStatefulSetStatus2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetStatus2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSetStatus2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetStatus2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedControllerRevision2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- replace the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedControllerRevision2 
  :: (Consumes ReplaceNamespacedControllerRevision2 contentType, MimeRender contentType V1beta1ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1ControllerRevision -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedControllerRevision2 contentType V1beta1ControllerRevision accept
replaceNamespacedControllerRevision2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedControllerRevision2 
instance HasBodyParam ReplaceNamespacedControllerRevision2 V1beta1ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedControllerRevision2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedControllerRevision2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedControllerRevision2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedControllerRevision2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedControllerRevision2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeployment2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- replace the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeployment2 
  :: (Consumes ReplaceNamespacedDeployment2 contentType, MimeRender contentType AppsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> AppsV1beta1Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeployment2 contentType AppsV1beta1Deployment accept
replaceNamespacedDeployment2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeployment2 
instance HasBodyParam ReplaceNamespacedDeployment2 AppsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeployment2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeployment2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeployment2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeployment2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeployment2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentScale2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- replace scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentScale2 
  :: (Consumes ReplaceNamespacedDeploymentScale2 contentType, MimeRender contentType AppsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> AppsV1beta1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentScale2 contentType AppsV1beta1Scale accept
replaceNamespacedDeploymentScale2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentScale2 
instance HasBodyParam ReplaceNamespacedDeploymentScale2 AppsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentScale2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentScale2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentScale2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentStatus2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- replace status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentStatus2 
  :: (Consumes ReplaceNamespacedDeploymentStatus2 contentType, MimeRender contentType AppsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> AppsV1beta1Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentStatus2 contentType AppsV1beta1Deployment accept
replaceNamespacedDeploymentStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentStatus2 
instance HasBodyParam ReplaceNamespacedDeploymentStatus2 AppsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentStatus2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentStatus2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSet2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- replace the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSet2 
  :: (Consumes ReplaceNamespacedStatefulSet2 contentType, MimeRender contentType V1beta1StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSet2 contentType V1beta1StatefulSet accept
replaceNamespacedStatefulSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSet2 
instance HasBodyParam ReplaceNamespacedStatefulSet2 V1beta1StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSet2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSet2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSet2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetScale2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- replace scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetScale2 
  :: (Consumes ReplaceNamespacedStatefulSetScale2 contentType, MimeRender contentType AppsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> AppsV1beta1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetScale2 contentType AppsV1beta1Scale accept
replaceNamespacedStatefulSetScale2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetScale2 
instance HasBodyParam ReplaceNamespacedStatefulSetScale2 AppsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSetScale2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetScale2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetScale2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetStatus2

-- | @PUT \/apis\/apps\/v1beta1\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- replace status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetStatus2 
  :: (Consumes ReplaceNamespacedStatefulSetStatus2 contentType, MimeRender contentType V1beta1StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetStatus2 contentType V1beta1StatefulSet accept
replaceNamespacedStatefulSetStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta1/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetStatus2 
instance HasBodyParam ReplaceNamespacedStatefulSetStatus2 V1beta1StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSetStatus2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetStatus2 MimeVndKubernetesProtobuf


-- ** AppsV1beta2

-- *** createNamespacedControllerRevision3

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- create a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedControllerRevision3 
  :: (Consumes CreateNamespacedControllerRevision3 contentType, MimeRender contentType V1beta2ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ControllerRevision -- ^ "body"
  -> KubernetesRequest CreateNamespacedControllerRevision3 contentType V1beta2ControllerRevision accept
createNamespacedControllerRevision3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedControllerRevision3 
instance HasBodyParam CreateNamespacedControllerRevision3 V1beta2ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedControllerRevision3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedControllerRevision3 MimeVndKubernetesProtobuf


-- *** createNamespacedDaemonSet2

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets@
-- 
-- create a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDaemonSet2 
  :: (Consumes CreateNamespacedDaemonSet2 contentType, MimeRender contentType V1beta2DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2DaemonSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedDaemonSet2 contentType V1beta2DaemonSet accept
createNamespacedDaemonSet2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDaemonSet2 
instance HasBodyParam CreateNamespacedDaemonSet2 V1beta2DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDaemonSet2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDaemonSet2 MimeVndKubernetesProtobuf


-- *** createNamespacedDeployment3

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments@
-- 
-- create a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeployment3 
  :: (Consumes CreateNamespacedDeployment3 contentType, MimeRender contentType V1beta2Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Deployment -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeployment3 contentType V1beta2Deployment accept
createNamespacedDeployment3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeployment3 
instance HasBodyParam CreateNamespacedDeployment3 V1beta2Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDeployment3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeployment3 MimeVndKubernetesProtobuf


-- *** createNamespacedReplicaSet2

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets@
-- 
-- create a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedReplicaSet2 
  :: (Consumes CreateNamespacedReplicaSet2 contentType, MimeRender contentType V1beta2ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ReplicaSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedReplicaSet2 contentType V1beta2ReplicaSet accept
createNamespacedReplicaSet2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedReplicaSet2 
instance HasBodyParam CreateNamespacedReplicaSet2 V1beta2ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedReplicaSet2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedReplicaSet2 MimeVndKubernetesProtobuf


-- *** createNamespacedStatefulSet3

-- | @POST \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets@
-- 
-- create a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedStatefulSet3 
  :: (Consumes CreateNamespacedStatefulSet3 contentType, MimeRender contentType V1beta2StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2StatefulSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedStatefulSet3 contentType V1beta2StatefulSet accept
createNamespacedStatefulSet3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedStatefulSet3 
instance HasBodyParam CreateNamespacedStatefulSet3 V1beta2StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedStatefulSet3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedStatefulSet3 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedControllerRevision3

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- delete collection of ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedControllerRevision3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedControllerRevision3 MimeNoContent V1Status accept
deleteCollectionNamespacedControllerRevision3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedControllerRevision3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedControllerRevision3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedControllerRevision3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedControllerRevision3 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDaemonSet2

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets@
-- 
-- delete collection of DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDaemonSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDaemonSet2 MimeNoContent V1Status accept
deleteCollectionNamespacedDaemonSet2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDaemonSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDaemonSet2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDaemonSet2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDeployment3

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments@
-- 
-- delete collection of Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDeployment3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDeployment3 MimeNoContent V1Status accept
deleteCollectionNamespacedDeployment3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDeployment3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDeployment3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDeployment3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDeployment3 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedReplicaSet2

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets@
-- 
-- delete collection of ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedReplicaSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedReplicaSet2 MimeNoContent V1Status accept
deleteCollectionNamespacedReplicaSet2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedReplicaSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedReplicaSet2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedReplicaSet2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedStatefulSet3

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets@
-- 
-- delete collection of StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedStatefulSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedStatefulSet3 MimeNoContent V1Status accept
deleteCollectionNamespacedStatefulSet3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedStatefulSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedStatefulSet3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedStatefulSet3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedStatefulSet3 MimeVndKubernetesProtobuf


-- *** deleteNamespacedControllerRevision3

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- delete a ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedControllerRevision3 
  :: (Consumes DeleteNamespacedControllerRevision3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedControllerRevision3 contentType V1Status accept
deleteNamespacedControllerRevision3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedControllerRevision3 
instance HasBodyParam DeleteNamespacedControllerRevision3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedControllerRevision3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedControllerRevision3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedControllerRevision3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedControllerRevision3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedControllerRevision3 MimeVndKubernetesProtobuf


-- *** deleteNamespacedDaemonSet2

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- delete a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDaemonSet2 
  :: (Consumes DeleteNamespacedDaemonSet2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDaemonSet2 contentType V1Status accept
deleteNamespacedDaemonSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDaemonSet2 
instance HasBodyParam DeleteNamespacedDaemonSet2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDaemonSet2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDaemonSet2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDaemonSet2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDaemonSet2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDaemonSet2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedDeployment3

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- delete a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDeployment3 
  :: (Consumes DeleteNamespacedDeployment3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDeployment3 contentType V1Status accept
deleteNamespacedDeployment3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDeployment3 
instance HasBodyParam DeleteNamespacedDeployment3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDeployment3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDeployment3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDeployment3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDeployment3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDeployment3 MimeVndKubernetesProtobuf


-- *** deleteNamespacedReplicaSet2

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- delete a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedReplicaSet2 
  :: (Consumes DeleteNamespacedReplicaSet2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedReplicaSet2 contentType V1Status accept
deleteNamespacedReplicaSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedReplicaSet2 
instance HasBodyParam DeleteNamespacedReplicaSet2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedReplicaSet2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedReplicaSet2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedReplicaSet2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedReplicaSet2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedReplicaSet2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedStatefulSet3

-- | @DELETE \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- delete a StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedStatefulSet3 
  :: (Consumes DeleteNamespacedStatefulSet3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedStatefulSet3 contentType V1Status accept
deleteNamespacedStatefulSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedStatefulSet3 
instance HasBodyParam DeleteNamespacedStatefulSet3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedStatefulSet3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedStatefulSet3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedStatefulSet3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedStatefulSet3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedStatefulSet3 MimeVndKubernetesProtobuf


-- *** getAPIResources8

-- | @GET \/apis\/apps\/v1beta2\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources8 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources8 MimeNoContent V1APIResourceList accept
getAPIResources8  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources8  

-- | @application/json@
instance Consumes GetAPIResources8 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources8 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources8 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources8 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources8 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources8 MimeVndKubernetesProtobuf


-- *** listControllerRevisionForAllNamespaces3

-- | @GET \/apis\/apps\/v1beta2\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listControllerRevisionForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListControllerRevisionForAllNamespaces3 MimeNoContent V1beta2ControllerRevisionList accept
listControllerRevisionForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListControllerRevisionForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListControllerRevisionForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListControllerRevisionForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListControllerRevisionForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListControllerRevisionForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListControllerRevisionForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListControllerRevisionForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** listDaemonSetForAllNamespaces2

-- | @GET \/apis\/apps\/v1beta2\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDaemonSetForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDaemonSetForAllNamespaces2 MimeNoContent V1beta2DaemonSetList accept
listDaemonSetForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDaemonSetForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDaemonSetForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDaemonSetForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListDaemonSetForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListDaemonSetForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDaemonSetForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDaemonSetForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDaemonSetForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listDeploymentForAllNamespaces3

-- | @GET \/apis\/apps\/v1beta2\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDeploymentForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDeploymentForAllNamespaces3 MimeNoContent V1beta2DeploymentList accept
listDeploymentForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDeploymentForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDeploymentForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDeploymentForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDeploymentForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDeploymentForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDeploymentForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDeploymentForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDeploymentForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDeploymentForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListDeploymentForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListDeploymentForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDeploymentForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDeploymentForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDeploymentForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedControllerRevision3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions@
-- 
-- list or watch objects of kind ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedControllerRevision3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedControllerRevision3 MimeNoContent V1beta2ControllerRevisionList accept
listNamespacedControllerRevision3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedControllerRevision3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedControllerRevision3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedControllerRevision3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedControllerRevision3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedControllerRevision3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedControllerRevision3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedControllerRevision3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedControllerRevision3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedControllerRevision3 MimeAny

-- | @application/json@
instance Produces ListNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedControllerRevision3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedControllerRevision3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedControllerRevision3 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDaemonSet2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDaemonSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDaemonSet2 MimeNoContent V1beta2DaemonSetList accept
listNamespacedDaemonSet2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDaemonSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDaemonSet2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDaemonSet2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDaemonSet2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDaemonSet2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDaemonSet2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDaemonSet2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDaemonSet2 MimeAny

-- | @application/json@
instance Produces ListNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDaemonSet2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDaemonSet2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDaemonSet2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDeployment3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDeployment3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDeployment3 MimeNoContent V1beta2DeploymentList accept
listNamespacedDeployment3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDeployment3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDeployment3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDeployment3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDeployment3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDeployment3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDeployment3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDeployment3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDeployment3 MimeAny

-- | @application/json@
instance Produces ListNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDeployment3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDeployment3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDeployment3 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedReplicaSet2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedReplicaSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedReplicaSet2 MimeNoContent V1beta2ReplicaSetList accept
listNamespacedReplicaSet2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedReplicaSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedReplicaSet2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedReplicaSet2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedReplicaSet2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedReplicaSet2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedReplicaSet2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedReplicaSet2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedReplicaSet2 MimeAny

-- | @application/json@
instance Produces ListNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedReplicaSet2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedReplicaSet2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedReplicaSet2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedStatefulSet3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedStatefulSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedStatefulSet3 MimeNoContent V1beta2StatefulSetList accept
listNamespacedStatefulSet3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedStatefulSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedStatefulSet3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedStatefulSet3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedStatefulSet3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedStatefulSet3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedStatefulSet3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedStatefulSet3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedStatefulSet3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedStatefulSet3 MimeAny

-- | @application/json@
instance Produces ListNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedStatefulSet3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedStatefulSet3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedStatefulSet3 MimeVndKubernetesProtobufstreamwatch


-- *** listReplicaSetForAllNamespaces2

-- | @GET \/apis\/apps\/v1beta2\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listReplicaSetForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListReplicaSetForAllNamespaces2 MimeNoContent V1beta2ReplicaSetList accept
listReplicaSetForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListReplicaSetForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListReplicaSetForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListReplicaSetForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListReplicaSetForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListReplicaSetForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListReplicaSetForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListReplicaSetForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListReplicaSetForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listStatefulSetForAllNamespaces3

-- | @GET \/apis\/apps\/v1beta2\/statefulsets@
-- 
-- list or watch objects of kind StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listStatefulSetForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListStatefulSetForAllNamespaces3 MimeNoContent V1beta2StatefulSetList accept
listStatefulSetForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/apps/v1beta2/statefulsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListStatefulSetForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListStatefulSetForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListStatefulSetForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListStatefulSetForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListStatefulSetForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListStatefulSetForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListStatefulSetForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListStatefulSetForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedControllerRevision3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- partially update the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedControllerRevision3 
  :: (Consumes PatchNamespacedControllerRevision3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedControllerRevision3 contentType V1beta2ControllerRevision accept
patchNamespacedControllerRevision3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedControllerRevision3 
instance HasBodyParam PatchNamespacedControllerRevision3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedControllerRevision3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedControllerRevision3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedControllerRevision3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedControllerRevision3 MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSet2

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- partially update the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSet2 
  :: (Consumes PatchNamespacedDaemonSet2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSet2 contentType V1beta2DaemonSet accept
patchNamespacedDaemonSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSet2 
instance HasBodyParam PatchNamespacedDaemonSet2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSet2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSet2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSet2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSet2 MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSetStatus2

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- partially update status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSetStatus2 
  :: (Consumes PatchNamespacedDaemonSetStatus2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSetStatus2 contentType V1beta2DaemonSet accept
patchNamespacedDaemonSetStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSetStatus2 
instance HasBodyParam PatchNamespacedDaemonSetStatus2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSetStatus2 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeployment3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- partially update the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeployment3 
  :: (Consumes PatchNamespacedDeployment3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeployment3 contentType V1beta2Deployment accept
patchNamespacedDeployment3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeployment3 
instance HasBodyParam PatchNamespacedDeployment3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeployment3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeployment3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeployment3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeployment3 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentScale3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- partially update scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentScale3 
  :: (Consumes PatchNamespacedDeploymentScale3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentScale3 contentType V1beta2Scale accept
patchNamespacedDeploymentScale3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentScale3 
instance HasBodyParam PatchNamespacedDeploymentScale3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentScale3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentScale3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentScale3 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentStatus3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- partially update status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentStatus3 
  :: (Consumes PatchNamespacedDeploymentStatus3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentStatus3 contentType V1beta2Deployment accept
patchNamespacedDeploymentStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentStatus3 
instance HasBodyParam PatchNamespacedDeploymentStatus3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentStatus3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentStatus3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentStatus3 MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSet2

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- partially update the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSet2 
  :: (Consumes PatchNamespacedReplicaSet2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSet2 contentType V1beta2ReplicaSet accept
patchNamespacedReplicaSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSet2 
instance HasBodyParam PatchNamespacedReplicaSet2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSet2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSet2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSet2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSet2 MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetScale2

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetScale2 
  :: (Consumes PatchNamespacedReplicaSetScale2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetScale2 contentType V1beta2Scale accept
patchNamespacedReplicaSetScale2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetScale2 
instance HasBodyParam PatchNamespacedReplicaSetScale2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetScale2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetScale2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetScale2 MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetStatus2

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- partially update status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetStatus2 
  :: (Consumes PatchNamespacedReplicaSetStatus2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetStatus2 contentType V1beta2ReplicaSet accept
patchNamespacedReplicaSetStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetStatus2 
instance HasBodyParam PatchNamespacedReplicaSetStatus2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetStatus2 MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSet3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- partially update the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSet3 
  :: (Consumes PatchNamespacedStatefulSet3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSet3 contentType V1beta2StatefulSet accept
patchNamespacedStatefulSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSet3 
instance HasBodyParam PatchNamespacedStatefulSet3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSet3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSet3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSet3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSet3 MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetScale3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- partially update scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetScale3 
  :: (Consumes PatchNamespacedStatefulSetScale3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetScale3 contentType V1beta2Scale accept
patchNamespacedStatefulSetScale3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetScale3 
instance HasBodyParam PatchNamespacedStatefulSetScale3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetScale3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetScale3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetScale3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetScale3 MimeVndKubernetesProtobuf


-- *** patchNamespacedStatefulSetStatus3

-- | @PATCH \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- partially update status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedStatefulSetStatus3 
  :: (Consumes PatchNamespacedStatefulSetStatus3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedStatefulSetStatus3 contentType V1beta2StatefulSet accept
patchNamespacedStatefulSetStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedStatefulSetStatus3 
instance HasBodyParam PatchNamespacedStatefulSetStatus3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedStatefulSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedStatefulSetStatus3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedStatefulSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedStatefulSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedStatefulSetStatus3 MimeVndKubernetesProtobuf


-- *** readNamespacedControllerRevision3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- read the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedControllerRevision3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedControllerRevision3 MimeNoContent V1beta2ControllerRevision accept
readNamespacedControllerRevision3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedControllerRevision3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedControllerRevision3 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedControllerRevision3 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedControllerRevision3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedControllerRevision3 MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSet2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- read the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSet2 MimeNoContent V1beta2DaemonSet accept
readNamespacedDaemonSet2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDaemonSet2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDaemonSet2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDaemonSet2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSet2 MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSetStatus2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- read status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSetStatus2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSetStatus2 MimeNoContent V1beta2DaemonSet accept
readNamespacedDaemonSetStatus2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSetStatus2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDaemonSetStatus2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDaemonSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSetStatus2 MimeVndKubernetesProtobuf


-- *** readNamespacedDeployment3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- read the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeployment3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeployment3 MimeNoContent V1beta2Deployment accept
readNamespacedDeployment3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeployment3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDeployment3 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDeployment3 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeployment3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeployment3 MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentScale3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- read scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentScale3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentScale3 MimeNoContent V1beta2Scale accept
readNamespacedDeploymentScale3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentScale3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentScale3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentScale3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentScale3 MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentStatus3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- read status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentStatus3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentStatus3 MimeNoContent V1beta2Deployment accept
readNamespacedDeploymentStatus3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentStatus3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentStatus3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentStatus3 MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSet2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- read the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSet2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSet2 MimeNoContent V1beta2ReplicaSet accept
readNamespacedReplicaSet2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSet2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedReplicaSet2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedReplicaSet2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSet2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSet2 MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetScale2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- read scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetScale2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetScale2 MimeNoContent V1beta2Scale accept
readNamespacedReplicaSetScale2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetScale2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSetScale2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSetScale2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetScale2 MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetStatus2

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- read status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetStatus2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetStatus2 MimeNoContent V1beta2ReplicaSet accept
readNamespacedReplicaSetStatus2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetStatus2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSetStatus2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetStatus2 MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSet3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- read the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSet3 MimeNoContent V1beta2StatefulSet accept
readNamespacedStatefulSet3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedStatefulSet3 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedStatefulSet3 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSet3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSet3 MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetScale3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- read scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetScale3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetScale3 MimeNoContent V1beta2Scale accept
readNamespacedStatefulSetScale3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetScale3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSetScale3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSetScale3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetScale3 MimeVndKubernetesProtobuf


-- *** readNamespacedStatefulSetStatus3

-- | @GET \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- read status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedStatefulSetStatus3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedStatefulSetStatus3 MimeNoContent V1beta2StatefulSet accept
readNamespacedStatefulSetStatus3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedStatefulSetStatus3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedStatefulSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedStatefulSetStatus3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedStatefulSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedStatefulSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedStatefulSetStatus3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedControllerRevision3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/controllerrevisions\/{name}@
-- 
-- replace the specified ControllerRevision
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedControllerRevision3 
  :: (Consumes ReplaceNamespacedControllerRevision3 contentType, MimeRender contentType V1beta2ControllerRevision)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ControllerRevision
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ControllerRevision -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedControllerRevision3 contentType V1beta2ControllerRevision accept
replaceNamespacedControllerRevision3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/controllerrevisions/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedControllerRevision3 
instance HasBodyParam ReplaceNamespacedControllerRevision3 V1beta2ControllerRevision 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedControllerRevision3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedControllerRevision3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedControllerRevision3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedControllerRevision3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedControllerRevision3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSet2

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- replace the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSet2 
  :: (Consumes ReplaceNamespacedDaemonSet2 contentType, MimeRender contentType V1beta2DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSet2 contentType V1beta2DaemonSet accept
replaceNamespacedDaemonSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSet2 
instance HasBodyParam ReplaceNamespacedDaemonSet2 V1beta2DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDaemonSet2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSet2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSet2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSetStatus2

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- replace status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSetStatus2 
  :: (Consumes ReplaceNamespacedDaemonSetStatus2 contentType, MimeRender contentType V1beta2DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSetStatus2 contentType V1beta2DaemonSet accept
replaceNamespacedDaemonSetStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSetStatus2 
instance HasBodyParam ReplaceNamespacedDaemonSetStatus2 V1beta2DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDaemonSetStatus2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSetStatus2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeployment3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- replace the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeployment3 
  :: (Consumes ReplaceNamespacedDeployment3 contentType, MimeRender contentType V1beta2Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeployment3 contentType V1beta2Deployment accept
replaceNamespacedDeployment3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeployment3 
instance HasBodyParam ReplaceNamespacedDeployment3 V1beta2Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeployment3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeployment3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeployment3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeployment3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeployment3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentScale3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- replace scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentScale3 
  :: (Consumes ReplaceNamespacedDeploymentScale3 contentType, MimeRender contentType V1beta2Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentScale3 contentType V1beta2Scale accept
replaceNamespacedDeploymentScale3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentScale3 
instance HasBodyParam ReplaceNamespacedDeploymentScale3 V1beta2Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentScale3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentScale3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentScale3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentStatus3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- replace status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentStatus3 
  :: (Consumes ReplaceNamespacedDeploymentStatus3 contentType, MimeRender contentType V1beta2Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentStatus3 contentType V1beta2Deployment accept
replaceNamespacedDeploymentStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentStatus3 
instance HasBodyParam ReplaceNamespacedDeploymentStatus3 V1beta2Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentStatus3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentStatus3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSet2

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- replace the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSet2 
  :: (Consumes ReplaceNamespacedReplicaSet2 contentType, MimeRender contentType V1beta2ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSet2 contentType V1beta2ReplicaSet accept
replaceNamespacedReplicaSet2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSet2 
instance HasBodyParam ReplaceNamespacedReplicaSet2 V1beta2ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSet2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSet2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSet2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSet2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSet2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetScale2

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- replace scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetScale2 
  :: (Consumes ReplaceNamespacedReplicaSetScale2 contentType, MimeRender contentType V1beta2Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetScale2 contentType V1beta2Scale accept
replaceNamespacedReplicaSetScale2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetScale2 
instance HasBodyParam ReplaceNamespacedReplicaSetScale2 V1beta2Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetScale2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSetScale2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetScale2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetScale2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetScale2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetStatus2

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- replace status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetStatus2 
  :: (Consumes ReplaceNamespacedReplicaSetStatus2 contentType, MimeRender contentType V1beta2ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetStatus2 contentType V1beta2ReplicaSet accept
replaceNamespacedReplicaSetStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetStatus2 
instance HasBodyParam ReplaceNamespacedReplicaSetStatus2 V1beta2ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSetStatus2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetStatus2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSet3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}@
-- 
-- replace the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSet3 
  :: (Consumes ReplaceNamespacedStatefulSet3 contentType, MimeRender contentType V1beta2StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSet3 contentType V1beta2StatefulSet accept
replaceNamespacedStatefulSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSet3 
instance HasBodyParam ReplaceNamespacedStatefulSet3 V1beta2StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSet3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSet3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSet3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetScale3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/scale@
-- 
-- replace scale of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetScale3 
  :: (Consumes ReplaceNamespacedStatefulSetScale3 contentType, MimeRender contentType V1beta2Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetScale3 contentType V1beta2Scale accept
replaceNamespacedStatefulSetScale3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetScale3 
instance HasBodyParam ReplaceNamespacedStatefulSetScale3 V1beta2Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSetScale3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetScale3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetScale3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedStatefulSetStatus3

-- | @PUT \/apis\/apps\/v1beta2\/namespaces\/{namespace}\/statefulsets\/{name}\/status@
-- 
-- replace status of the specified StatefulSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedStatefulSetStatus3 
  :: (Consumes ReplaceNamespacedStatefulSetStatus3 contentType, MimeRender contentType V1beta2StatefulSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StatefulSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta2StatefulSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedStatefulSetStatus3 contentType V1beta2StatefulSet accept
replaceNamespacedStatefulSetStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/apps/v1beta2/namespaces/",toPath namespace,"/statefulsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedStatefulSetStatus3 
instance HasBodyParam ReplaceNamespacedStatefulSetStatus3 V1beta2StatefulSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedStatefulSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedStatefulSetStatus3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedStatefulSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedStatefulSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedStatefulSetStatus3 MimeVndKubernetesProtobuf


-- ** Authentication

-- *** getAPIGroup5

-- | @GET \/apis\/authentication.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup5 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup5 MimeNoContent V1APIGroup accept
getAPIGroup5  _ =
  _mkRequest "GET" ["/apis/authentication.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup5  

-- | @application/json@
instance Consumes GetAPIGroup5 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup5 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup5 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup5 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup5 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup5 MimeVndKubernetesProtobuf


-- ** AuthenticationV1

-- *** createTokenReview

-- | @POST \/apis\/authentication.k8s.io\/v1\/tokenreviews@
-- 
-- create a TokenReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createTokenReview 
  :: (Consumes CreateTokenReview contentType, MimeRender contentType V1TokenReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1TokenReview -- ^ "body"
  -> KubernetesRequest CreateTokenReview contentType V1TokenReview accept
createTokenReview _  _ body =
  _mkRequest "POST" ["/apis/authentication.k8s.io/v1/tokenreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateTokenReview 
instance HasBodyParam CreateTokenReview V1TokenReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateTokenReview Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateTokenReview MimeAny

-- | @application/json@
instance Produces CreateTokenReview MimeJSON
-- | @application/yaml@
instance Produces CreateTokenReview MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateTokenReview MimeVndKubernetesProtobuf


-- *** getAPIResources9

-- | @GET \/apis\/authentication.k8s.io\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources9 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources9 MimeNoContent V1APIResourceList accept
getAPIResources9  _ =
  _mkRequest "GET" ["/apis/authentication.k8s.io/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources9  

-- | @application/json@
instance Consumes GetAPIResources9 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources9 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources9 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources9 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources9 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources9 MimeVndKubernetesProtobuf


-- ** AuthenticationV1beta1

-- *** createTokenReview2

-- | @POST \/apis\/authentication.k8s.io\/v1beta1\/tokenreviews@
-- 
-- create a TokenReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createTokenReview2 
  :: (Consumes CreateTokenReview2 contentType, MimeRender contentType V1beta1TokenReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1TokenReview -- ^ "body"
  -> KubernetesRequest CreateTokenReview2 contentType V1beta1TokenReview accept
createTokenReview2 _  _ body =
  _mkRequest "POST" ["/apis/authentication.k8s.io/v1beta1/tokenreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateTokenReview2 
instance HasBodyParam CreateTokenReview2 V1beta1TokenReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateTokenReview2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateTokenReview2 MimeAny

-- | @application/json@
instance Produces CreateTokenReview2 MimeJSON
-- | @application/yaml@
instance Produces CreateTokenReview2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateTokenReview2 MimeVndKubernetesProtobuf


-- *** getAPIResources10

-- | @GET \/apis\/authentication.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources10 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources10 MimeNoContent V1APIResourceList accept
getAPIResources10  _ =
  _mkRequest "GET" ["/apis/authentication.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources10  

-- | @application/json@
instance Consumes GetAPIResources10 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources10 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources10 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources10 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources10 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources10 MimeVndKubernetesProtobuf


-- ** Authorization

-- *** getAPIGroup6

-- | @GET \/apis\/authorization.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup6 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup6 MimeNoContent V1APIGroup accept
getAPIGroup6  _ =
  _mkRequest "GET" ["/apis/authorization.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup6  

-- | @application/json@
instance Consumes GetAPIGroup6 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup6 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup6 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup6 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup6 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup6 MimeVndKubernetesProtobuf


-- ** AuthorizationV1

-- *** createNamespacedLocalSubjectAccessReview

-- | @POST \/apis\/authorization.k8s.io\/v1\/namespaces\/{namespace}\/localsubjectaccessreviews@
-- 
-- create a LocalSubjectAccessReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedLocalSubjectAccessReview 
  :: (Consumes CreateNamespacedLocalSubjectAccessReview contentType, MimeRender contentType V1LocalSubjectAccessReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1LocalSubjectAccessReview -- ^ "body"
  -> KubernetesRequest CreateNamespacedLocalSubjectAccessReview contentType V1LocalSubjectAccessReview accept
createNamespacedLocalSubjectAccessReview _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1/namespaces/",toPath namespace,"/localsubjectaccessreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedLocalSubjectAccessReview 
instance HasBodyParam CreateNamespacedLocalSubjectAccessReview V1LocalSubjectAccessReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedLocalSubjectAccessReview Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedLocalSubjectAccessReview MimeAny

-- | @application/json@
instance Produces CreateNamespacedLocalSubjectAccessReview MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedLocalSubjectAccessReview MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedLocalSubjectAccessReview MimeVndKubernetesProtobuf


-- *** createSelfSubjectAccessReview

-- | @POST \/apis\/authorization.k8s.io\/v1\/selfsubjectaccessreviews@
-- 
-- create a SelfSubjectAccessReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createSelfSubjectAccessReview 
  :: (Consumes CreateSelfSubjectAccessReview contentType, MimeRender contentType V1SelfSubjectAccessReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1SelfSubjectAccessReview -- ^ "body"
  -> KubernetesRequest CreateSelfSubjectAccessReview contentType V1SelfSubjectAccessReview accept
createSelfSubjectAccessReview _  _ body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1/selfsubjectaccessreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateSelfSubjectAccessReview 
instance HasBodyParam CreateSelfSubjectAccessReview V1SelfSubjectAccessReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateSelfSubjectAccessReview Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateSelfSubjectAccessReview MimeAny

-- | @application/json@
instance Produces CreateSelfSubjectAccessReview MimeJSON
-- | @application/yaml@
instance Produces CreateSelfSubjectAccessReview MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateSelfSubjectAccessReview MimeVndKubernetesProtobuf


-- *** createSelfSubjectRulesReview

-- | @POST \/apis\/authorization.k8s.io\/v1\/selfsubjectrulesreviews@
-- 
-- create a SelfSubjectRulesReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createSelfSubjectRulesReview 
  :: (Consumes CreateSelfSubjectRulesReview contentType, MimeRender contentType V1SelfSubjectRulesReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1SelfSubjectRulesReview -- ^ "body"
  -> KubernetesRequest CreateSelfSubjectRulesReview contentType V1SelfSubjectRulesReview accept
createSelfSubjectRulesReview _  _ body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateSelfSubjectRulesReview 
instance HasBodyParam CreateSelfSubjectRulesReview V1SelfSubjectRulesReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateSelfSubjectRulesReview Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateSelfSubjectRulesReview MimeAny

-- | @application/json@
instance Produces CreateSelfSubjectRulesReview MimeJSON
-- | @application/yaml@
instance Produces CreateSelfSubjectRulesReview MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateSelfSubjectRulesReview MimeVndKubernetesProtobuf


-- *** createSubjectAccessReview

-- | @POST \/apis\/authorization.k8s.io\/v1\/subjectaccessreviews@
-- 
-- create a SubjectAccessReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createSubjectAccessReview 
  :: (Consumes CreateSubjectAccessReview contentType, MimeRender contentType V1SubjectAccessReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1SubjectAccessReview -- ^ "body"
  -> KubernetesRequest CreateSubjectAccessReview contentType V1SubjectAccessReview accept
createSubjectAccessReview _  _ body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1/subjectaccessreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateSubjectAccessReview 
instance HasBodyParam CreateSubjectAccessReview V1SubjectAccessReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateSubjectAccessReview Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateSubjectAccessReview MimeAny

-- | @application/json@
instance Produces CreateSubjectAccessReview MimeJSON
-- | @application/yaml@
instance Produces CreateSubjectAccessReview MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateSubjectAccessReview MimeVndKubernetesProtobuf


-- *** getAPIResources11

-- | @GET \/apis\/authorization.k8s.io\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources11 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources11 MimeNoContent V1APIResourceList accept
getAPIResources11  _ =
  _mkRequest "GET" ["/apis/authorization.k8s.io/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources11  

-- | @application/json@
instance Consumes GetAPIResources11 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources11 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources11 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources11 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources11 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources11 MimeVndKubernetesProtobuf


-- ** AuthorizationV1beta1

-- *** createNamespacedLocalSubjectAccessReview2

-- | @POST \/apis\/authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/localsubjectaccessreviews@
-- 
-- create a LocalSubjectAccessReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedLocalSubjectAccessReview2 
  :: (Consumes CreateNamespacedLocalSubjectAccessReview2 contentType, MimeRender contentType V1beta1LocalSubjectAccessReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1LocalSubjectAccessReview -- ^ "body"
  -> KubernetesRequest CreateNamespacedLocalSubjectAccessReview2 contentType V1beta1LocalSubjectAccessReview accept
createNamespacedLocalSubjectAccessReview2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/localsubjectaccessreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedLocalSubjectAccessReview2 
instance HasBodyParam CreateNamespacedLocalSubjectAccessReview2 V1beta1LocalSubjectAccessReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedLocalSubjectAccessReview2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedLocalSubjectAccessReview2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedLocalSubjectAccessReview2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedLocalSubjectAccessReview2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedLocalSubjectAccessReview2 MimeVndKubernetesProtobuf


-- *** createSelfSubjectAccessReview2

-- | @POST \/apis\/authorization.k8s.io\/v1beta1\/selfsubjectaccessreviews@
-- 
-- create a SelfSubjectAccessReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createSelfSubjectAccessReview2 
  :: (Consumes CreateSelfSubjectAccessReview2 contentType, MimeRender contentType V1beta1SelfSubjectAccessReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1SelfSubjectAccessReview -- ^ "body"
  -> KubernetesRequest CreateSelfSubjectAccessReview2 contentType V1beta1SelfSubjectAccessReview accept
createSelfSubjectAccessReview2 _  _ body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1beta1/selfsubjectaccessreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateSelfSubjectAccessReview2 
instance HasBodyParam CreateSelfSubjectAccessReview2 V1beta1SelfSubjectAccessReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateSelfSubjectAccessReview2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateSelfSubjectAccessReview2 MimeAny

-- | @application/json@
instance Produces CreateSelfSubjectAccessReview2 MimeJSON
-- | @application/yaml@
instance Produces CreateSelfSubjectAccessReview2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateSelfSubjectAccessReview2 MimeVndKubernetesProtobuf


-- *** createSelfSubjectRulesReview2

-- | @POST \/apis\/authorization.k8s.io\/v1beta1\/selfsubjectrulesreviews@
-- 
-- create a SelfSubjectRulesReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createSelfSubjectRulesReview2 
  :: (Consumes CreateSelfSubjectRulesReview2 contentType, MimeRender contentType V1beta1SelfSubjectRulesReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1SelfSubjectRulesReview -- ^ "body"
  -> KubernetesRequest CreateSelfSubjectRulesReview2 contentType V1beta1SelfSubjectRulesReview accept
createSelfSubjectRulesReview2 _  _ body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1beta1/selfsubjectrulesreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateSelfSubjectRulesReview2 
instance HasBodyParam CreateSelfSubjectRulesReview2 V1beta1SelfSubjectRulesReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateSelfSubjectRulesReview2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateSelfSubjectRulesReview2 MimeAny

-- | @application/json@
instance Produces CreateSelfSubjectRulesReview2 MimeJSON
-- | @application/yaml@
instance Produces CreateSelfSubjectRulesReview2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateSelfSubjectRulesReview2 MimeVndKubernetesProtobuf


-- *** createSubjectAccessReview2

-- | @POST \/apis\/authorization.k8s.io\/v1beta1\/subjectaccessreviews@
-- 
-- create a SubjectAccessReview
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createSubjectAccessReview2 
  :: (Consumes CreateSubjectAccessReview2 contentType, MimeRender contentType V1beta1SubjectAccessReview)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1SubjectAccessReview -- ^ "body"
  -> KubernetesRequest CreateSubjectAccessReview2 contentType V1beta1SubjectAccessReview accept
createSubjectAccessReview2 _  _ body =
  _mkRequest "POST" ["/apis/authorization.k8s.io/v1beta1/subjectaccessreviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateSubjectAccessReview2 
instance HasBodyParam CreateSubjectAccessReview2 V1beta1SubjectAccessReview 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateSubjectAccessReview2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateSubjectAccessReview2 MimeAny

-- | @application/json@
instance Produces CreateSubjectAccessReview2 MimeJSON
-- | @application/yaml@
instance Produces CreateSubjectAccessReview2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateSubjectAccessReview2 MimeVndKubernetesProtobuf


-- *** getAPIResources12

-- | @GET \/apis\/authorization.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources12 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources12 MimeNoContent V1APIResourceList accept
getAPIResources12  _ =
  _mkRequest "GET" ["/apis/authorization.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources12  

-- | @application/json@
instance Consumes GetAPIResources12 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources12 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources12 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources12 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources12 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources12 MimeVndKubernetesProtobuf


-- ** Autoscaling

-- *** getAPIGroup7

-- | @GET \/apis\/autoscaling\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup7 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup7 MimeNoContent V1APIGroup accept
getAPIGroup7  _ =
  _mkRequest "GET" ["/apis/autoscaling/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup7  

-- | @application/json@
instance Consumes GetAPIGroup7 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup7 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup7 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup7 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup7 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup7 MimeVndKubernetesProtobuf


-- ** AutoscalingV1

-- *** createNamespacedHorizontalPodAutoscaler

-- | @POST \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers@
-- 
-- create a HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedHorizontalPodAutoscaler 
  :: (Consumes CreateNamespacedHorizontalPodAutoscaler contentType, MimeRender contentType V1HorizontalPodAutoscaler)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1HorizontalPodAutoscaler -- ^ "body"
  -> KubernetesRequest CreateNamespacedHorizontalPodAutoscaler contentType V1HorizontalPodAutoscaler accept
createNamespacedHorizontalPodAutoscaler _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedHorizontalPodAutoscaler 
instance HasBodyParam CreateNamespacedHorizontalPodAutoscaler V1HorizontalPodAutoscaler 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedHorizontalPodAutoscaler MimeAny

-- | @application/json@
instance Produces CreateNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedHorizontalPodAutoscaler

-- | @DELETE \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers@
-- 
-- delete collection of HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedHorizontalPodAutoscaler 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedHorizontalPodAutoscaler MimeNoContent V1Status accept
deleteCollectionNamespacedHorizontalPodAutoscaler  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedHorizontalPodAutoscaler  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedHorizontalPodAutoscaler MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf


-- *** deleteNamespacedHorizontalPodAutoscaler

-- | @DELETE \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- delete a HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedHorizontalPodAutoscaler 
  :: (Consumes DeleteNamespacedHorizontalPodAutoscaler contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedHorizontalPodAutoscaler contentType V1Status accept
deleteNamespacedHorizontalPodAutoscaler _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedHorizontalPodAutoscaler 
instance HasBodyParam DeleteNamespacedHorizontalPodAutoscaler V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedHorizontalPodAutoscaler MimeAny

-- | @application/json@
instance Produces DeleteNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf


-- *** getAPIResources13

-- | @GET \/apis\/autoscaling\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources13 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources13 MimeNoContent V1APIResourceList accept
getAPIResources13  _ =
  _mkRequest "GET" ["/apis/autoscaling/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources13  

-- | @application/json@
instance Consumes GetAPIResources13 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources13 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources13 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources13 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources13 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources13 MimeVndKubernetesProtobuf


-- *** listHorizontalPodAutoscalerForAllNamespaces

-- | @GET \/apis\/autoscaling\/v1\/horizontalpodautoscalers@
-- 
-- list or watch objects of kind HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listHorizontalPodAutoscalerForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListHorizontalPodAutoscalerForAllNamespaces MimeNoContent V1HorizontalPodAutoscalerList accept
listHorizontalPodAutoscalerForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/autoscaling/v1/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListHorizontalPodAutoscalerForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListHorizontalPodAutoscalerForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedHorizontalPodAutoscaler

-- | @GET \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers@
-- 
-- list or watch objects of kind HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedHorizontalPodAutoscaler 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedHorizontalPodAutoscaler MimeNoContent V1HorizontalPodAutoscalerList accept
listNamespacedHorizontalPodAutoscaler  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedHorizontalPodAutoscaler  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedHorizontalPodAutoscaler MimeAny

-- | @application/json@
instance Produces ListNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedHorizontalPodAutoscaler MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedHorizontalPodAutoscaler

-- | @PATCH \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- partially update the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedHorizontalPodAutoscaler 
  :: (Consumes PatchNamespacedHorizontalPodAutoscaler contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedHorizontalPodAutoscaler contentType V1HorizontalPodAutoscaler accept
patchNamespacedHorizontalPodAutoscaler _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedHorizontalPodAutoscaler 
instance HasBodyParam PatchNamespacedHorizontalPodAutoscaler A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscaler MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscaler MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscaler MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf


-- *** patchNamespacedHorizontalPodAutoscalerStatus

-- | @PATCH \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}\/status@
-- 
-- partially update status of the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedHorizontalPodAutoscalerStatus 
  :: (Consumes PatchNamespacedHorizontalPodAutoscalerStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedHorizontalPodAutoscalerStatus contentType V1HorizontalPodAutoscaler accept
patchNamespacedHorizontalPodAutoscalerStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedHorizontalPodAutoscalerStatus 
instance HasBodyParam PatchNamespacedHorizontalPodAutoscalerStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedHorizontalPodAutoscalerStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscalerStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscalerStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscalerStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedHorizontalPodAutoscalerStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedHorizontalPodAutoscalerStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedHorizontalPodAutoscalerStatus MimeVndKubernetesProtobuf


-- *** readNamespacedHorizontalPodAutoscaler

-- | @GET \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- read the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedHorizontalPodAutoscaler 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedHorizontalPodAutoscaler MimeNoContent V1HorizontalPodAutoscaler accept
readNamespacedHorizontalPodAutoscaler  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedHorizontalPodAutoscaler  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscaler Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscaler Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedHorizontalPodAutoscaler MimeAny

-- | @application/json@
instance Produces ReadNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf


-- *** readNamespacedHorizontalPodAutoscalerStatus

-- | @GET \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}\/status@
-- 
-- read status of the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedHorizontalPodAutoscalerStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedHorizontalPodAutoscalerStatus MimeNoContent V1HorizontalPodAutoscaler accept
readNamespacedHorizontalPodAutoscalerStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedHorizontalPodAutoscalerStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscalerStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedHorizontalPodAutoscalerStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedHorizontalPodAutoscalerStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedHorizontalPodAutoscalerStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedHorizontalPodAutoscalerStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedHorizontalPodAutoscaler

-- | @PUT \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- replace the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedHorizontalPodAutoscaler 
  :: (Consumes ReplaceNamespacedHorizontalPodAutoscaler contentType, MimeRender contentType V1HorizontalPodAutoscaler)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1HorizontalPodAutoscaler -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedHorizontalPodAutoscaler contentType V1HorizontalPodAutoscaler accept
replaceNamespacedHorizontalPodAutoscaler _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedHorizontalPodAutoscaler 
instance HasBodyParam ReplaceNamespacedHorizontalPodAutoscaler V1HorizontalPodAutoscaler 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedHorizontalPodAutoscaler Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedHorizontalPodAutoscaler MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedHorizontalPodAutoscaler MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedHorizontalPodAutoscaler MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedHorizontalPodAutoscaler MimeVndKubernetesProtobuf


-- *** replaceNamespacedHorizontalPodAutoscalerStatus

-- | @PUT \/apis\/autoscaling\/v1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}\/status@
-- 
-- replace status of the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedHorizontalPodAutoscalerStatus 
  :: (Consumes ReplaceNamespacedHorizontalPodAutoscalerStatus contentType, MimeRender contentType V1HorizontalPodAutoscaler)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1HorizontalPodAutoscaler -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedHorizontalPodAutoscalerStatus contentType V1HorizontalPodAutoscaler accept
replaceNamespacedHorizontalPodAutoscalerStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/autoscaling/v1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedHorizontalPodAutoscalerStatus 
instance HasBodyParam ReplaceNamespacedHorizontalPodAutoscalerStatus V1HorizontalPodAutoscaler 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedHorizontalPodAutoscalerStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedHorizontalPodAutoscalerStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedHorizontalPodAutoscalerStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedHorizontalPodAutoscalerStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedHorizontalPodAutoscalerStatus MimeVndKubernetesProtobuf


-- ** AutoscalingV2beta1

-- *** createNamespacedHorizontalPodAutoscaler2

-- | @POST \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers@
-- 
-- create a HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedHorizontalPodAutoscaler2 
  :: (Consumes CreateNamespacedHorizontalPodAutoscaler2 contentType, MimeRender contentType V2beta1HorizontalPodAutoscaler)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V2beta1HorizontalPodAutoscaler -- ^ "body"
  -> KubernetesRequest CreateNamespacedHorizontalPodAutoscaler2 contentType V2beta1HorizontalPodAutoscaler accept
createNamespacedHorizontalPodAutoscaler2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedHorizontalPodAutoscaler2 
instance HasBodyParam CreateNamespacedHorizontalPodAutoscaler2 V2beta1HorizontalPodAutoscaler 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedHorizontalPodAutoscaler2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedHorizontalPodAutoscaler2

-- | @DELETE \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers@
-- 
-- delete collection of HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedHorizontalPodAutoscaler2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedHorizontalPodAutoscaler2 MimeNoContent V1Status accept
deleteCollectionNamespacedHorizontalPodAutoscaler2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedHorizontalPodAutoscaler2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedHorizontalPodAutoscaler2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedHorizontalPodAutoscaler2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedHorizontalPodAutoscaler2

-- | @DELETE \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- delete a HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedHorizontalPodAutoscaler2 
  :: (Consumes DeleteNamespacedHorizontalPodAutoscaler2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedHorizontalPodAutoscaler2 contentType V1Status accept
deleteNamespacedHorizontalPodAutoscaler2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedHorizontalPodAutoscaler2 
instance HasBodyParam DeleteNamespacedHorizontalPodAutoscaler2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedHorizontalPodAutoscaler2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedHorizontalPodAutoscaler2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf


-- *** getAPIResources14

-- | @GET \/apis\/autoscaling\/v2beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources14 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources14 MimeNoContent V1APIResourceList accept
getAPIResources14  _ =
  _mkRequest "GET" ["/apis/autoscaling/v2beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources14  

-- | @application/json@
instance Consumes GetAPIResources14 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources14 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources14 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources14 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources14 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources14 MimeVndKubernetesProtobuf


-- *** listHorizontalPodAutoscalerForAllNamespaces2

-- | @GET \/apis\/autoscaling\/v2beta1\/horizontalpodautoscalers@
-- 
-- list or watch objects of kind HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listHorizontalPodAutoscalerForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListHorizontalPodAutoscalerForAllNamespaces2 MimeNoContent V2beta1HorizontalPodAutoscalerList accept
listHorizontalPodAutoscalerForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/autoscaling/v2beta1/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListHorizontalPodAutoscalerForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListHorizontalPodAutoscalerForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListHorizontalPodAutoscalerForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListHorizontalPodAutoscalerForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedHorizontalPodAutoscaler2

-- | @GET \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers@
-- 
-- list or watch objects of kind HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedHorizontalPodAutoscaler2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedHorizontalPodAutoscaler2 MimeNoContent V2beta1HorizontalPodAutoscalerList accept
listNamespacedHorizontalPodAutoscaler2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedHorizontalPodAutoscaler2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedHorizontalPodAutoscaler2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedHorizontalPodAutoscaler2 MimeAny

-- | @application/json@
instance Produces ListNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedHorizontalPodAutoscaler2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedHorizontalPodAutoscaler2

-- | @PATCH \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- partially update the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedHorizontalPodAutoscaler2 
  :: (Consumes PatchNamespacedHorizontalPodAutoscaler2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedHorizontalPodAutoscaler2 contentType V2beta1HorizontalPodAutoscaler accept
patchNamespacedHorizontalPodAutoscaler2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedHorizontalPodAutoscaler2 
instance HasBodyParam PatchNamespacedHorizontalPodAutoscaler2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscaler2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscaler2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscaler2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf


-- *** patchNamespacedHorizontalPodAutoscalerStatus2

-- | @PATCH \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}\/status@
-- 
-- partially update status of the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedHorizontalPodAutoscalerStatus2 
  :: (Consumes PatchNamespacedHorizontalPodAutoscalerStatus2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedHorizontalPodAutoscalerStatus2 contentType V2beta1HorizontalPodAutoscaler accept
patchNamespacedHorizontalPodAutoscalerStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedHorizontalPodAutoscalerStatus2 
instance HasBodyParam PatchNamespacedHorizontalPodAutoscalerStatus2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedHorizontalPodAutoscalerStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscalerStatus2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscalerStatus2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedHorizontalPodAutoscalerStatus2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedHorizontalPodAutoscalerStatus2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedHorizontalPodAutoscalerStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedHorizontalPodAutoscalerStatus2 MimeVndKubernetesProtobuf


-- *** readNamespacedHorizontalPodAutoscaler2

-- | @GET \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- read the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedHorizontalPodAutoscaler2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedHorizontalPodAutoscaler2 MimeNoContent V2beta1HorizontalPodAutoscaler accept
readNamespacedHorizontalPodAutoscaler2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedHorizontalPodAutoscaler2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscaler2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscaler2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedHorizontalPodAutoscaler2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf


-- *** readNamespacedHorizontalPodAutoscalerStatus2

-- | @GET \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}\/status@
-- 
-- read status of the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedHorizontalPodAutoscalerStatus2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedHorizontalPodAutoscalerStatus2 MimeNoContent V2beta1HorizontalPodAutoscaler accept
readNamespacedHorizontalPodAutoscalerStatus2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedHorizontalPodAutoscalerStatus2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedHorizontalPodAutoscalerStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedHorizontalPodAutoscalerStatus2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedHorizontalPodAutoscalerStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedHorizontalPodAutoscalerStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedHorizontalPodAutoscalerStatus2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedHorizontalPodAutoscaler2

-- | @PUT \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}@
-- 
-- replace the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedHorizontalPodAutoscaler2 
  :: (Consumes ReplaceNamespacedHorizontalPodAutoscaler2 contentType, MimeRender contentType V2beta1HorizontalPodAutoscaler)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V2beta1HorizontalPodAutoscaler -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedHorizontalPodAutoscaler2 contentType V2beta1HorizontalPodAutoscaler accept
replaceNamespacedHorizontalPodAutoscaler2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedHorizontalPodAutoscaler2 
instance HasBodyParam ReplaceNamespacedHorizontalPodAutoscaler2 V2beta1HorizontalPodAutoscaler 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedHorizontalPodAutoscaler2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedHorizontalPodAutoscaler2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedHorizontalPodAutoscaler2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedHorizontalPodAutoscaler2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedHorizontalPodAutoscaler2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedHorizontalPodAutoscalerStatus2

-- | @PUT \/apis\/autoscaling\/v2beta1\/namespaces\/{namespace}\/horizontalpodautoscalers\/{name}\/status@
-- 
-- replace status of the specified HorizontalPodAutoscaler
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedHorizontalPodAutoscalerStatus2 
  :: (Consumes ReplaceNamespacedHorizontalPodAutoscalerStatus2 contentType, MimeRender contentType V2beta1HorizontalPodAutoscaler)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the HorizontalPodAutoscaler
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V2beta1HorizontalPodAutoscaler -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedHorizontalPodAutoscalerStatus2 contentType V2beta1HorizontalPodAutoscaler accept
replaceNamespacedHorizontalPodAutoscalerStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/autoscaling/v2beta1/namespaces/",toPath namespace,"/horizontalpodautoscalers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedHorizontalPodAutoscalerStatus2 
instance HasBodyParam ReplaceNamespacedHorizontalPodAutoscalerStatus2 V2beta1HorizontalPodAutoscaler 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedHorizontalPodAutoscalerStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedHorizontalPodAutoscalerStatus2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedHorizontalPodAutoscalerStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedHorizontalPodAutoscalerStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedHorizontalPodAutoscalerStatus2 MimeVndKubernetesProtobuf


-- ** Batch

-- *** getAPIGroup8

-- | @GET \/apis\/batch\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup8 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup8 MimeNoContent V1APIGroup accept
getAPIGroup8  _ =
  _mkRequest "GET" ["/apis/batch/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup8  

-- | @application/json@
instance Consumes GetAPIGroup8 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup8 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup8 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup8 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup8 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup8 MimeVndKubernetesProtobuf


-- ** BatchV1

-- *** createNamespacedJob

-- | @POST \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs@
-- 
-- create a Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedJob 
  :: (Consumes CreateNamespacedJob contentType, MimeRender contentType V1Job)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Job -- ^ "body"
  -> KubernetesRequest CreateNamespacedJob contentType V1Job accept
createNamespacedJob _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedJob 
instance HasBodyParam CreateNamespacedJob V1Job 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedJob MimeAny

-- | @application/json@
instance Produces CreateNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedJob MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedJob

-- | @DELETE \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs@
-- 
-- delete collection of Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedJob 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedJob MimeNoContent V1Status accept
deleteCollectionNamespacedJob  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedJob  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedJob Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedJob FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedJob IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedJob LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedJob Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedJob ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedJob TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedJob Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedJob MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedJob MimeVndKubernetesProtobuf


-- *** deleteNamespacedJob

-- | @DELETE \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}@
-- 
-- delete a Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedJob 
  :: (Consumes DeleteNamespacedJob contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedJob contentType V1Status accept
deleteNamespacedJob _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedJob 
instance HasBodyParam DeleteNamespacedJob V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedJob GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedJob OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedJob PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedJob MimeAny

-- | @application/json@
instance Produces DeleteNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedJob MimeVndKubernetesProtobuf


-- *** getAPIResources15

-- | @GET \/apis\/batch\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources15 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources15 MimeNoContent V1APIResourceList accept
getAPIResources15  _ =
  _mkRequest "GET" ["/apis/batch/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources15  

-- | @application/json@
instance Consumes GetAPIResources15 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources15 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources15 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources15 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources15 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources15 MimeVndKubernetesProtobuf


-- *** listJobForAllNamespaces

-- | @GET \/apis\/batch\/v1\/jobs@
-- 
-- list or watch objects of kind Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listJobForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListJobForAllNamespaces MimeNoContent V1JobList accept
listJobForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/batch/v1/jobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListJobForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListJobForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListJobForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListJobForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListJobForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListJobForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListJobForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListJobForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListJobForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListJobForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListJobForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListJobForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListJobForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListJobForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListJobForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListJobForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedJob

-- | @GET \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs@
-- 
-- list or watch objects of kind Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedJob 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedJob MimeNoContent V1JobList accept
listNamespacedJob  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedJob  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedJob Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedJob FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedJob IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedJob LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedJob Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedJob ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedJob TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedJob Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedJob MimeAny

-- | @application/json@
instance Produces ListNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedJob MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedJob MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedJob MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedJob

-- | @PATCH \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}@
-- 
-- partially update the specified Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedJob 
  :: (Consumes PatchNamespacedJob contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedJob contentType V1Job accept
patchNamespacedJob _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedJob 
instance HasBodyParam PatchNamespacedJob A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedJob MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedJob MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedJob MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedJob MimeVndKubernetesProtobuf


-- *** patchNamespacedJobStatus

-- | @PATCH \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}\/status@
-- 
-- partially update status of the specified Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedJobStatus 
  :: (Consumes PatchNamespacedJobStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedJobStatus contentType V1Job accept
patchNamespacedJobStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedJobStatus 
instance HasBodyParam PatchNamespacedJobStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedJobStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedJobStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedJobStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedJobStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedJobStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedJobStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedJobStatus MimeVndKubernetesProtobuf


-- *** readNamespacedJob

-- | @GET \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}@
-- 
-- read the specified Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedJob 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedJob MimeNoContent V1Job accept
readNamespacedJob  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedJob  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedJob Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedJob Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedJob MimeAny

-- | @application/json@
instance Produces ReadNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedJob MimeVndKubernetesProtobuf


-- *** readNamespacedJobStatus

-- | @GET \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}\/status@
-- 
-- read status of the specified Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedJobStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedJobStatus MimeNoContent V1Job accept
readNamespacedJobStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedJobStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedJobStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedJobStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedJobStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedJobStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedJobStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedJob

-- | @PUT \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}@
-- 
-- replace the specified Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedJob 
  :: (Consumes ReplaceNamespacedJob contentType, MimeRender contentType V1Job)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Job -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedJob contentType V1Job accept
replaceNamespacedJob _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedJob 
instance HasBodyParam ReplaceNamespacedJob V1Job 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedJob MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedJob MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedJob MimeVndKubernetesProtobuf


-- *** replaceNamespacedJobStatus

-- | @PUT \/apis\/batch\/v1\/namespaces\/{namespace}\/jobs\/{name}\/status@
-- 
-- replace status of the specified Job
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedJobStatus 
  :: (Consumes ReplaceNamespacedJobStatus contentType, MimeRender contentType V1Job)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Job
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Job -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedJobStatus contentType V1Job accept
replaceNamespacedJobStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/batch/v1/namespaces/",toPath namespace,"/jobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedJobStatus 
instance HasBodyParam ReplaceNamespacedJobStatus V1Job 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedJobStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedJobStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedJobStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedJobStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedJobStatus MimeVndKubernetesProtobuf


-- ** BatchV1beta1

-- *** createNamespacedCronJob

-- | @POST \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs@
-- 
-- create a CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedCronJob 
  :: (Consumes CreateNamespacedCronJob contentType, MimeRender contentType V1beta1CronJob)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1CronJob -- ^ "body"
  -> KubernetesRequest CreateNamespacedCronJob contentType V1beta1CronJob accept
createNamespacedCronJob _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedCronJob 
instance HasBodyParam CreateNamespacedCronJob V1beta1CronJob 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedCronJob MimeAny

-- | @application/json@
instance Produces CreateNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedCronJob MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedCronJob

-- | @DELETE \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs@
-- 
-- delete collection of CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedCronJob 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedCronJob MimeNoContent V1Status accept
deleteCollectionNamespacedCronJob  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedCronJob  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedCronJob Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedCronJob FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedCronJob IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedCronJob LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedCronJob Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedCronJob ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedCronJob TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedCronJob Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedCronJob MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedCronJob MimeVndKubernetesProtobuf


-- *** deleteNamespacedCronJob

-- | @DELETE \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- delete a CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedCronJob 
  :: (Consumes DeleteNamespacedCronJob contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedCronJob contentType V1Status accept
deleteNamespacedCronJob _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedCronJob 
instance HasBodyParam DeleteNamespacedCronJob V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedCronJob GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedCronJob OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedCronJob PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedCronJob MimeAny

-- | @application/json@
instance Produces DeleteNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedCronJob MimeVndKubernetesProtobuf


-- *** getAPIResources16

-- | @GET \/apis\/batch\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources16 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources16 MimeNoContent V1APIResourceList accept
getAPIResources16  _ =
  _mkRequest "GET" ["/apis/batch/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources16  

-- | @application/json@
instance Consumes GetAPIResources16 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources16 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources16 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources16 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources16 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources16 MimeVndKubernetesProtobuf


-- *** listCronJobForAllNamespaces

-- | @GET \/apis\/batch\/v1beta1\/cronjobs@
-- 
-- list or watch objects of kind CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listCronJobForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListCronJobForAllNamespaces MimeNoContent V1beta1CronJobList accept
listCronJobForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/batch/v1beta1/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListCronJobForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListCronJobForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListCronJobForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListCronJobForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListCronJobForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListCronJobForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListCronJobForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListCronJobForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListCronJobForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListCronJobForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListCronJobForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListCronJobForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListCronJobForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListCronJobForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListCronJobForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListCronJobForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedCronJob

-- | @GET \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs@
-- 
-- list or watch objects of kind CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedCronJob 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedCronJob MimeNoContent V1beta1CronJobList accept
listNamespacedCronJob  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedCronJob  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedCronJob Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedCronJob FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedCronJob IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedCronJob LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedCronJob Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedCronJob ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedCronJob TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedCronJob Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedCronJob MimeAny

-- | @application/json@
instance Produces ListNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedCronJob MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedCronJob MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedCronJob MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedCronJob

-- | @PATCH \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- partially update the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedCronJob 
  :: (Consumes PatchNamespacedCronJob contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedCronJob contentType V1beta1CronJob accept
patchNamespacedCronJob _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedCronJob 
instance HasBodyParam PatchNamespacedCronJob A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedCronJob MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedCronJob MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedCronJob MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedCronJob MimeVndKubernetesProtobuf


-- *** patchNamespacedCronJobStatus

-- | @PATCH \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}\/status@
-- 
-- partially update status of the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedCronJobStatus 
  :: (Consumes PatchNamespacedCronJobStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedCronJobStatus contentType V1beta1CronJob accept
patchNamespacedCronJobStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedCronJobStatus 
instance HasBodyParam PatchNamespacedCronJobStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedCronJobStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedCronJobStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedCronJobStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedCronJobStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedCronJobStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedCronJobStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedCronJobStatus MimeVndKubernetesProtobuf


-- *** readNamespacedCronJob

-- | @GET \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- read the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedCronJob 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedCronJob MimeNoContent V1beta1CronJob accept
readNamespacedCronJob  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedCronJob  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedCronJob Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedCronJob Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedCronJob MimeAny

-- | @application/json@
instance Produces ReadNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedCronJob MimeVndKubernetesProtobuf


-- *** readNamespacedCronJobStatus

-- | @GET \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}\/status@
-- 
-- read status of the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedCronJobStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedCronJobStatus MimeNoContent V1beta1CronJob accept
readNamespacedCronJobStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedCronJobStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedCronJobStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedCronJobStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedCronJobStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedCronJobStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedCronJobStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedCronJob

-- | @PUT \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- replace the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedCronJob 
  :: (Consumes ReplaceNamespacedCronJob contentType, MimeRender contentType V1beta1CronJob)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1CronJob -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedCronJob contentType V1beta1CronJob accept
replaceNamespacedCronJob _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedCronJob 
instance HasBodyParam ReplaceNamespacedCronJob V1beta1CronJob 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedCronJob Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedCronJob MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedCronJob MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedCronJob MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedCronJob MimeVndKubernetesProtobuf


-- *** replaceNamespacedCronJobStatus

-- | @PUT \/apis\/batch\/v1beta1\/namespaces\/{namespace}\/cronjobs\/{name}\/status@
-- 
-- replace status of the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedCronJobStatus 
  :: (Consumes ReplaceNamespacedCronJobStatus contentType, MimeRender contentType V1beta1CronJob)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1CronJob -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedCronJobStatus contentType V1beta1CronJob accept
replaceNamespacedCronJobStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/batch/v1beta1/namespaces/",toPath namespace,"/cronjobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedCronJobStatus 
instance HasBodyParam ReplaceNamespacedCronJobStatus V1beta1CronJob 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedCronJobStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedCronJobStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedCronJobStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedCronJobStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedCronJobStatus MimeVndKubernetesProtobuf


-- ** BatchV2alpha1

-- *** createNamespacedCronJob2

-- | @POST \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs@
-- 
-- create a CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedCronJob2 
  :: (Consumes CreateNamespacedCronJob2 contentType, MimeRender contentType V2alpha1CronJob)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V2alpha1CronJob -- ^ "body"
  -> KubernetesRequest CreateNamespacedCronJob2 contentType V2alpha1CronJob accept
createNamespacedCronJob2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedCronJob2 
instance HasBodyParam CreateNamespacedCronJob2 V2alpha1CronJob 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedCronJob2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedCronJob2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedCronJob2

-- | @DELETE \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs@
-- 
-- delete collection of CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedCronJob2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedCronJob2 MimeNoContent V1Status accept
deleteCollectionNamespacedCronJob2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedCronJob2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedCronJob2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedCronJob2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedCronJob2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedCronJob2

-- | @DELETE \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- delete a CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedCronJob2 
  :: (Consumes DeleteNamespacedCronJob2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedCronJob2 contentType V1Status accept
deleteNamespacedCronJob2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedCronJob2 
instance HasBodyParam DeleteNamespacedCronJob2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedCronJob2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedCronJob2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedCronJob2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedCronJob2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedCronJob2 MimeVndKubernetesProtobuf


-- *** getAPIResources17

-- | @GET \/apis\/batch\/v2alpha1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources17 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources17 MimeNoContent V1APIResourceList accept
getAPIResources17  _ =
  _mkRequest "GET" ["/apis/batch/v2alpha1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources17  

-- | @application/json@
instance Consumes GetAPIResources17 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources17 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources17 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources17 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources17 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources17 MimeVndKubernetesProtobuf


-- *** listCronJobForAllNamespaces2

-- | @GET \/apis\/batch\/v2alpha1\/cronjobs@
-- 
-- list or watch objects of kind CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listCronJobForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListCronJobForAllNamespaces2 MimeNoContent V2alpha1CronJobList accept
listCronJobForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/batch/v2alpha1/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListCronJobForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListCronJobForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListCronJobForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListCronJobForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListCronJobForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListCronJobForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListCronJobForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListCronJobForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListCronJobForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListCronJobForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListCronJobForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListCronJobForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListCronJobForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListCronJobForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListCronJobForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListCronJobForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedCronJob2

-- | @GET \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs@
-- 
-- list or watch objects of kind CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedCronJob2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedCronJob2 MimeNoContent V2alpha1CronJobList accept
listNamespacedCronJob2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedCronJob2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedCronJob2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedCronJob2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedCronJob2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedCronJob2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedCronJob2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedCronJob2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedCronJob2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedCronJob2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedCronJob2 MimeAny

-- | @application/json@
instance Produces ListNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedCronJob2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedCronJob2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedCronJob2 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedCronJob2

-- | @PATCH \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- partially update the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedCronJob2 
  :: (Consumes PatchNamespacedCronJob2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedCronJob2 contentType V2alpha1CronJob accept
patchNamespacedCronJob2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedCronJob2 
instance HasBodyParam PatchNamespacedCronJob2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedCronJob2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedCronJob2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedCronJob2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedCronJob2 MimeVndKubernetesProtobuf


-- *** patchNamespacedCronJobStatus2

-- | @PATCH \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}\/status@
-- 
-- partially update status of the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedCronJobStatus2 
  :: (Consumes PatchNamespacedCronJobStatus2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedCronJobStatus2 contentType V2alpha1CronJob accept
patchNamespacedCronJobStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedCronJobStatus2 
instance HasBodyParam PatchNamespacedCronJobStatus2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedCronJobStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedCronJobStatus2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedCronJobStatus2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedCronJobStatus2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedCronJobStatus2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedCronJobStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedCronJobStatus2 MimeVndKubernetesProtobuf


-- *** readNamespacedCronJob2

-- | @GET \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- read the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedCronJob2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedCronJob2 MimeNoContent V2alpha1CronJob accept
readNamespacedCronJob2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedCronJob2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedCronJob2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedCronJob2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedCronJob2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedCronJob2 MimeVndKubernetesProtobuf


-- *** readNamespacedCronJobStatus2

-- | @GET \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}\/status@
-- 
-- read status of the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedCronJobStatus2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedCronJobStatus2 MimeNoContent V2alpha1CronJob accept
readNamespacedCronJobStatus2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedCronJobStatus2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedCronJobStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedCronJobStatus2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedCronJobStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedCronJobStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedCronJobStatus2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedCronJob2

-- | @PUT \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}@
-- 
-- replace the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedCronJob2 
  :: (Consumes ReplaceNamespacedCronJob2 contentType, MimeRender contentType V2alpha1CronJob)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V2alpha1CronJob -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedCronJob2 contentType V2alpha1CronJob accept
replaceNamespacedCronJob2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedCronJob2 
instance HasBodyParam ReplaceNamespacedCronJob2 V2alpha1CronJob 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedCronJob2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedCronJob2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedCronJob2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedCronJob2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedCronJob2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedCronJobStatus2

-- | @PUT \/apis\/batch\/v2alpha1\/namespaces\/{namespace}\/cronjobs\/{name}\/status@
-- 
-- replace status of the specified CronJob
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedCronJobStatus2 
  :: (Consumes ReplaceNamespacedCronJobStatus2 contentType, MimeRender contentType V2alpha1CronJob)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CronJob
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V2alpha1CronJob -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedCronJobStatus2 contentType V2alpha1CronJob accept
replaceNamespacedCronJobStatus2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/batch/v2alpha1/namespaces/",toPath namespace,"/cronjobs/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedCronJobStatus2 
instance HasBodyParam ReplaceNamespacedCronJobStatus2 V2alpha1CronJob 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedCronJobStatus2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedCronJobStatus2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedCronJobStatus2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedCronJobStatus2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedCronJobStatus2 MimeVndKubernetesProtobuf


-- ** Certificates

-- *** getAPIGroup9

-- | @GET \/apis\/certificates.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup9 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup9 MimeNoContent V1APIGroup accept
getAPIGroup9  _ =
  _mkRequest "GET" ["/apis/certificates.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup9  

-- | @application/json@
instance Consumes GetAPIGroup9 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup9 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup9 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup9 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup9 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup9 MimeVndKubernetesProtobuf


-- ** CertificatesV1beta1

-- *** createCertificateSigningRequest

-- | @POST \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests@
-- 
-- create a CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createCertificateSigningRequest 
  :: (Consumes CreateCertificateSigningRequest contentType, MimeRender contentType V1beta1CertificateSigningRequest)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1CertificateSigningRequest -- ^ "body"
  -> KubernetesRequest CreateCertificateSigningRequest contentType V1beta1CertificateSigningRequest accept
createCertificateSigningRequest _  _ body =
  _mkRequest "POST" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateCertificateSigningRequest 
instance HasBodyParam CreateCertificateSigningRequest V1beta1CertificateSigningRequest 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateCertificateSigningRequest MimeAny

-- | @application/json@
instance Produces CreateCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces CreateCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateCertificateSigningRequest MimeVndKubernetesProtobuf


-- *** deleteCertificateSigningRequest

-- | @DELETE \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests\/{name}@
-- 
-- delete a CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCertificateSigningRequest 
  :: (Consumes DeleteCertificateSigningRequest contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CertificateSigningRequest
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteCertificateSigningRequest contentType V1Status accept
deleteCertificateSigningRequest _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteCertificateSigningRequest 
instance HasBodyParam DeleteCertificateSigningRequest V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCertificateSigningRequest GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCertificateSigningRequest OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCertificateSigningRequest PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteCertificateSigningRequest MimeAny

-- | @application/json@
instance Produces DeleteCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces DeleteCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCertificateSigningRequest MimeVndKubernetesProtobuf


-- *** deleteCollectionCertificateSigningRequest

-- | @DELETE \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests@
-- 
-- delete collection of CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionCertificateSigningRequest 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionCertificateSigningRequest MimeNoContent V1Status accept
deleteCollectionCertificateSigningRequest  _ =
  _mkRequest "DELETE" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionCertificateSigningRequest  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionCertificateSigningRequest Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionCertificateSigningRequest MimeAny

-- | @application/json@
instance Produces DeleteCollectionCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionCertificateSigningRequest MimeVndKubernetesProtobuf


-- *** getAPIResources18

-- | @GET \/apis\/certificates.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources18 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources18 MimeNoContent V1APIResourceList accept
getAPIResources18  _ =
  _mkRequest "GET" ["/apis/certificates.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources18  

-- | @application/json@
instance Consumes GetAPIResources18 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources18 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources18 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources18 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources18 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources18 MimeVndKubernetesProtobuf


-- *** listCertificateSigningRequest

-- | @GET \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests@
-- 
-- list or watch objects of kind CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listCertificateSigningRequest 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListCertificateSigningRequest MimeNoContent V1beta1CertificateSigningRequestList accept
listCertificateSigningRequest  _ =
  _mkRequest "GET" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListCertificateSigningRequest  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListCertificateSigningRequest Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListCertificateSigningRequest FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListCertificateSigningRequest IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListCertificateSigningRequest LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListCertificateSigningRequest Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListCertificateSigningRequest ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListCertificateSigningRequest TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListCertificateSigningRequest Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListCertificateSigningRequest MimeAny

-- | @application/json@
instance Produces ListCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces ListCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListCertificateSigningRequest MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListCertificateSigningRequest MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListCertificateSigningRequest MimeVndKubernetesProtobufstreamwatch


-- *** patchCertificateSigningRequest

-- | @PATCH \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests\/{name}@
-- 
-- partially update the specified CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchCertificateSigningRequest 
  :: (Consumes PatchCertificateSigningRequest contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CertificateSigningRequest
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchCertificateSigningRequest contentType V1beta1CertificateSigningRequest accept
patchCertificateSigningRequest _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchCertificateSigningRequest 
instance HasBodyParam PatchCertificateSigningRequest A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchCertificateSigningRequest MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchCertificateSigningRequest MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchCertificateSigningRequest MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces PatchCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchCertificateSigningRequest MimeVndKubernetesProtobuf


-- *** readCertificateSigningRequest

-- | @GET \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests\/{name}@
-- 
-- read the specified CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readCertificateSigningRequest 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CertificateSigningRequest
  -> KubernetesRequest ReadCertificateSigningRequest MimeNoContent V1beta1CertificateSigningRequest accept
readCertificateSigningRequest  _ (Name name) =
  _mkRequest "GET" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadCertificateSigningRequest  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadCertificateSigningRequest Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadCertificateSigningRequest Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadCertificateSigningRequest MimeAny

-- | @application/json@
instance Produces ReadCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces ReadCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadCertificateSigningRequest MimeVndKubernetesProtobuf


-- *** replaceCertificateSigningRequest

-- | @PUT \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests\/{name}@
-- 
-- replace the specified CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceCertificateSigningRequest 
  :: (Consumes ReplaceCertificateSigningRequest contentType, MimeRender contentType V1beta1CertificateSigningRequest)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CertificateSigningRequest
  -> V1beta1CertificateSigningRequest -- ^ "body"
  -> KubernetesRequest ReplaceCertificateSigningRequest contentType V1beta1CertificateSigningRequest accept
replaceCertificateSigningRequest _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceCertificateSigningRequest 
instance HasBodyParam ReplaceCertificateSigningRequest V1beta1CertificateSigningRequest 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceCertificateSigningRequest Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceCertificateSigningRequest MimeAny

-- | @application/json@
instance Produces ReplaceCertificateSigningRequest MimeJSON
-- | @application/yaml@
instance Produces ReplaceCertificateSigningRequest MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceCertificateSigningRequest MimeVndKubernetesProtobuf


-- *** replaceCertificateSigningRequestApproval

-- | @PUT \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests\/{name}\/approval@
-- 
-- replace approval of the specified CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceCertificateSigningRequestApproval 
  :: (Consumes ReplaceCertificateSigningRequestApproval contentType, MimeRender contentType V1beta1CertificateSigningRequest)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CertificateSigningRequest
  -> V1beta1CertificateSigningRequest -- ^ "body"
  -> KubernetesRequest ReplaceCertificateSigningRequestApproval contentType V1beta1CertificateSigningRequest accept
replaceCertificateSigningRequestApproval _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/",toPath name,"/approval"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceCertificateSigningRequestApproval 
instance HasBodyParam ReplaceCertificateSigningRequestApproval V1beta1CertificateSigningRequest 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceCertificateSigningRequestApproval Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceCertificateSigningRequestApproval MimeAny

-- | @application/json@
instance Produces ReplaceCertificateSigningRequestApproval MimeJSON
-- | @application/yaml@
instance Produces ReplaceCertificateSigningRequestApproval MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceCertificateSigningRequestApproval MimeVndKubernetesProtobuf


-- *** replaceCertificateSigningRequestStatus

-- | @PUT \/apis\/certificates.k8s.io\/v1beta1\/certificatesigningrequests\/{name}\/status@
-- 
-- replace status of the specified CertificateSigningRequest
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceCertificateSigningRequestStatus 
  :: (Consumes ReplaceCertificateSigningRequestStatus contentType, MimeRender contentType V1beta1CertificateSigningRequest)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the CertificateSigningRequest
  -> V1beta1CertificateSigningRequest -- ^ "body"
  -> KubernetesRequest ReplaceCertificateSigningRequestStatus contentType V1beta1CertificateSigningRequest accept
replaceCertificateSigningRequestStatus _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceCertificateSigningRequestStatus 
instance HasBodyParam ReplaceCertificateSigningRequestStatus V1beta1CertificateSigningRequest 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceCertificateSigningRequestStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceCertificateSigningRequestStatus MimeAny

-- | @application/json@
instance Produces ReplaceCertificateSigningRequestStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceCertificateSigningRequestStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceCertificateSigningRequestStatus MimeVndKubernetesProtobuf


-- ** Core

-- *** getAPIVersions

-- | @GET \/api\/@
-- 
-- get available API versions
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIVersions 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIVersions MimeNoContent V1APIVersions accept
getAPIVersions  _ =
  _mkRequest "GET" ["/api/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIVersions  

-- | @application/json@
instance Consumes GetAPIVersions MimeJSON
-- | @application/yaml@
instance Consumes GetAPIVersions MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIVersions MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIVersions MimeJSON
-- | @application/yaml@
instance Produces GetAPIVersions MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIVersions MimeVndKubernetesProtobuf


-- ** CoreV1

-- *** connectDeleteNamespacedPodProxy

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect DELETE requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectDeleteNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectDeleteNamespacedPodProxy MimeNoContent Text accept
connectDeleteNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectDeleteNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectDeleteNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectDeleteNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectDeleteNamespacedPodProxy MimeAny


-- *** connectDeleteNamespacedPodProxyWithPath

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect DELETE requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectDeleteNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectDeleteNamespacedPodProxyWithPath MimeNoContent Text accept
connectDeleteNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectDeleteNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectDeleteNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectDeleteNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectDeleteNamespacedPodProxyWithPath MimeAny


-- *** connectDeleteNamespacedServiceProxy

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect DELETE requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectDeleteNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectDeleteNamespacedServiceProxy MimeNoContent Text accept
connectDeleteNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectDeleteNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectDeleteNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectDeleteNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectDeleteNamespacedServiceProxy MimeAny


-- *** connectDeleteNamespacedServiceProxyWithPath

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect DELETE requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectDeleteNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectDeleteNamespacedServiceProxyWithPath MimeNoContent Text accept
connectDeleteNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectDeleteNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectDeleteNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectDeleteNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectDeleteNamespacedServiceProxyWithPath MimeAny


-- *** connectDeleteNodeProxy

-- | @DELETE \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect DELETE requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectDeleteNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectDeleteNodeProxy MimeNoContent Text accept
connectDeleteNodeProxy  _ (Name name) =
  _mkRequest "DELETE" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectDeleteNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectDeleteNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectDeleteNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectDeleteNodeProxy MimeAny


-- *** connectDeleteNodeProxyWithPath

-- | @DELETE \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect DELETE requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectDeleteNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectDeleteNodeProxyWithPath MimeNoContent Text accept
connectDeleteNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "DELETE" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectDeleteNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectDeleteNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectDeleteNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectDeleteNodeProxyWithPath MimeAny


-- *** connectGetNamespacedPodAttach

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/attach@
-- 
-- connect GET requests to attach of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedPodAttach 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectGetNamespacedPodAttach MimeNoContent Text accept
connectGetNamespacedPodAttach  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/attach"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedPodAttach  

-- | /Optional Param/ "container" - The container in which to execute the command. Defaults to only container if there is only one container in the pod.
instance HasOptionalParam ConnectGetNamespacedPodAttach Container where
  applyOptionalParam req (Container xs) =
    req `setQuery` toQuery ("container", Just xs)

-- | /Optional Param/ "stderr" - Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
instance HasOptionalParam ConnectGetNamespacedPodAttach Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "stdin" - Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
instance HasOptionalParam ConnectGetNamespacedPodAttach Stdin where
  applyOptionalParam req (Stdin xs) =
    req `setQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
instance HasOptionalParam ConnectGetNamespacedPodAttach Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "tty" - TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
instance HasOptionalParam ConnectGetNamespacedPodAttach Tty where
  applyOptionalParam req (Tty xs) =
    req `setQuery` toQuery ("tty", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedPodAttach MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedPodAttach MimeAny


-- *** connectGetNamespacedPodExec

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/exec@
-- 
-- connect GET requests to exec of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedPodExec 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectGetNamespacedPodExec MimeNoContent Text accept
connectGetNamespacedPodExec  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/exec"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedPodExec  

-- | /Optional Param/ "command" - Command is the remote command to execute. argv array. Not executed within a shell.
instance HasOptionalParam ConnectGetNamespacedPodExec Command where
  applyOptionalParam req (Command xs) =
    req `setQuery` toQuery ("command", Just xs)

-- | /Optional Param/ "container" - Container in which to execute the command. Defaults to only container if there is only one container in the pod.
instance HasOptionalParam ConnectGetNamespacedPodExec Container where
  applyOptionalParam req (Container xs) =
    req `setQuery` toQuery ("container", Just xs)

-- | /Optional Param/ "stderr" - Redirect the standard error stream of the pod for this call. Defaults to true.
instance HasOptionalParam ConnectGetNamespacedPodExec Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "stdin" - Redirect the standard input stream of the pod for this call. Defaults to false.
instance HasOptionalParam ConnectGetNamespacedPodExec Stdin where
  applyOptionalParam req (Stdin xs) =
    req `setQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Redirect the standard output stream of the pod for this call. Defaults to true.
instance HasOptionalParam ConnectGetNamespacedPodExec Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "tty" - TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
instance HasOptionalParam ConnectGetNamespacedPodExec Tty where
  applyOptionalParam req (Tty xs) =
    req `setQuery` toQuery ("tty", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedPodExec MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedPodExec MimeAny


-- *** connectGetNamespacedPodPortforward

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/portforward@
-- 
-- connect GET requests to portforward of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedPodPortforward 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectGetNamespacedPodPortforward MimeNoContent Text accept
connectGetNamespacedPodPortforward  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/portforward"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedPodPortforward  

-- | /Optional Param/ "ports" - List of ports to forward Required when using WebSockets
instance HasOptionalParam ConnectGetNamespacedPodPortforward Ports where
  applyOptionalParam req (Ports xs) =
    req `setQuery` toQuery ("ports", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedPodPortforward MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedPodPortforward MimeAny


-- *** connectGetNamespacedPodProxy

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect GET requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectGetNamespacedPodProxy MimeNoContent Text accept
connectGetNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectGetNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedPodProxy MimeAny


-- *** connectGetNamespacedPodProxyWithPath

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect GET requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectGetNamespacedPodProxyWithPath MimeNoContent Text accept
connectGetNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectGetNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedPodProxyWithPath MimeAny


-- *** connectGetNamespacedServiceProxy

-- | @GET \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect GET requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectGetNamespacedServiceProxy MimeNoContent Text accept
connectGetNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectGetNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedServiceProxy MimeAny


-- *** connectGetNamespacedServiceProxyWithPath

-- | @GET \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect GET requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectGetNamespacedServiceProxyWithPath MimeNoContent Text accept
connectGetNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectGetNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectGetNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectGetNamespacedServiceProxyWithPath MimeAny


-- *** connectGetNodeProxy

-- | @GET \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect GET requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectGetNodeProxy MimeNoContent Text accept
connectGetNodeProxy  _ (Name name) =
  _mkRequest "GET" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectGetNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectGetNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectGetNodeProxy MimeAny


-- *** connectGetNodeProxyWithPath

-- | @GET \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect GET requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectGetNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectGetNodeProxyWithPath MimeNoContent Text accept
connectGetNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "GET" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectGetNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectGetNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectGetNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectGetNodeProxyWithPath MimeAny


-- *** connectHeadNamespacedPodProxy

-- | @HEAD \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect HEAD requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectHeadNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectHeadNamespacedPodProxy MimeNoContent Text accept
connectHeadNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "HEAD" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectHeadNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectHeadNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectHeadNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectHeadNamespacedPodProxy MimeAny


-- *** connectHeadNamespacedPodProxyWithPath

-- | @HEAD \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect HEAD requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectHeadNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectHeadNamespacedPodProxyWithPath MimeNoContent Text accept
connectHeadNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "HEAD" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectHeadNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectHeadNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectHeadNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectHeadNamespacedPodProxyWithPath MimeAny


-- *** connectHeadNamespacedServiceProxy

-- | @HEAD \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect HEAD requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectHeadNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectHeadNamespacedServiceProxy MimeNoContent Text accept
connectHeadNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "HEAD" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectHeadNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectHeadNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectHeadNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectHeadNamespacedServiceProxy MimeAny


-- *** connectHeadNamespacedServiceProxyWithPath

-- | @HEAD \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect HEAD requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectHeadNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectHeadNamespacedServiceProxyWithPath MimeNoContent Text accept
connectHeadNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "HEAD" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectHeadNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectHeadNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectHeadNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectHeadNamespacedServiceProxyWithPath MimeAny


-- *** connectHeadNodeProxy

-- | @HEAD \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect HEAD requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectHeadNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectHeadNodeProxy MimeNoContent Text accept
connectHeadNodeProxy  _ (Name name) =
  _mkRequest "HEAD" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectHeadNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectHeadNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectHeadNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectHeadNodeProxy MimeAny


-- *** connectHeadNodeProxyWithPath

-- | @HEAD \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect HEAD requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectHeadNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectHeadNodeProxyWithPath MimeNoContent Text accept
connectHeadNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "HEAD" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectHeadNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectHeadNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectHeadNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectHeadNodeProxyWithPath MimeAny


-- *** connectOptionsNamespacedPodProxy

-- | @OPTIONS \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect OPTIONS requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectOptionsNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectOptionsNamespacedPodProxy MimeNoContent Text accept
connectOptionsNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "OPTIONS" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectOptionsNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectOptionsNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectOptionsNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectOptionsNamespacedPodProxy MimeAny


-- *** connectOptionsNamespacedPodProxyWithPath

-- | @OPTIONS \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect OPTIONS requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectOptionsNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectOptionsNamespacedPodProxyWithPath MimeNoContent Text accept
connectOptionsNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "OPTIONS" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectOptionsNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectOptionsNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectOptionsNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectOptionsNamespacedPodProxyWithPath MimeAny


-- *** connectOptionsNamespacedServiceProxy

-- | @OPTIONS \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect OPTIONS requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectOptionsNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectOptionsNamespacedServiceProxy MimeNoContent Text accept
connectOptionsNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "OPTIONS" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectOptionsNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectOptionsNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectOptionsNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectOptionsNamespacedServiceProxy MimeAny


-- *** connectOptionsNamespacedServiceProxyWithPath

-- | @OPTIONS \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect OPTIONS requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectOptionsNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectOptionsNamespacedServiceProxyWithPath MimeNoContent Text accept
connectOptionsNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "OPTIONS" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectOptionsNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectOptionsNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectOptionsNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectOptionsNamespacedServiceProxyWithPath MimeAny


-- *** connectOptionsNodeProxy

-- | @OPTIONS \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect OPTIONS requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectOptionsNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectOptionsNodeProxy MimeNoContent Text accept
connectOptionsNodeProxy  _ (Name name) =
  _mkRequest "OPTIONS" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectOptionsNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectOptionsNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectOptionsNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectOptionsNodeProxy MimeAny


-- *** connectOptionsNodeProxyWithPath

-- | @OPTIONS \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect OPTIONS requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectOptionsNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectOptionsNodeProxyWithPath MimeNoContent Text accept
connectOptionsNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "OPTIONS" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectOptionsNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectOptionsNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectOptionsNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectOptionsNodeProxyWithPath MimeAny


-- *** connectPatchNamespacedPodProxy

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect PATCH requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPatchNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPatchNamespacedPodProxy MimeNoContent Text accept
connectPatchNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPatchNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectPatchNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPatchNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectPatchNamespacedPodProxy MimeAny


-- *** connectPatchNamespacedPodProxyWithPath

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect PATCH requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPatchNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPatchNamespacedPodProxyWithPath MimeNoContent Text accept
connectPatchNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPatchNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectPatchNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPatchNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPatchNamespacedPodProxyWithPath MimeAny


-- *** connectPatchNamespacedServiceProxy

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect PATCH requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPatchNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPatchNamespacedServiceProxy MimeNoContent Text accept
connectPatchNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPatchNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectPatchNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPatchNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectPatchNamespacedServiceProxy MimeAny


-- *** connectPatchNamespacedServiceProxyWithPath

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect PATCH requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPatchNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPatchNamespacedServiceProxyWithPath MimeNoContent Text accept
connectPatchNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPatchNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectPatchNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPatchNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPatchNamespacedServiceProxyWithPath MimeAny


-- *** connectPatchNodeProxy

-- | @PATCH \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect PATCH requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPatchNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectPatchNodeProxy MimeNoContent Text accept
connectPatchNodeProxy  _ (Name name) =
  _mkRequest "PATCH" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPatchNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectPatchNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPatchNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectPatchNodeProxy MimeAny


-- *** connectPatchNodeProxyWithPath

-- | @PATCH \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect PATCH requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPatchNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPatchNodeProxyWithPath MimeNoContent Text accept
connectPatchNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "PATCH" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPatchNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectPatchNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPatchNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPatchNodeProxyWithPath MimeAny


-- *** connectPostNamespacedPodAttach

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/attach@
-- 
-- connect POST requests to attach of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedPodAttach 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPostNamespacedPodAttach MimeNoContent Text accept
connectPostNamespacedPodAttach  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/attach"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedPodAttach  

-- | /Optional Param/ "container" - The container in which to execute the command. Defaults to only container if there is only one container in the pod.
instance HasOptionalParam ConnectPostNamespacedPodAttach Container where
  applyOptionalParam req (Container xs) =
    req `setQuery` toQuery ("container", Just xs)

-- | /Optional Param/ "stderr" - Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
instance HasOptionalParam ConnectPostNamespacedPodAttach Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "stdin" - Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
instance HasOptionalParam ConnectPostNamespacedPodAttach Stdin where
  applyOptionalParam req (Stdin xs) =
    req `setQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
instance HasOptionalParam ConnectPostNamespacedPodAttach Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "tty" - TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
instance HasOptionalParam ConnectPostNamespacedPodAttach Tty where
  applyOptionalParam req (Tty xs) =
    req `setQuery` toQuery ("tty", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedPodAttach MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedPodAttach MimeAny


-- *** connectPostNamespacedPodExec

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/exec@
-- 
-- connect POST requests to exec of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedPodExec 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPostNamespacedPodExec MimeNoContent Text accept
connectPostNamespacedPodExec  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/exec"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedPodExec  

-- | /Optional Param/ "command" - Command is the remote command to execute. argv array. Not executed within a shell.
instance HasOptionalParam ConnectPostNamespacedPodExec Command where
  applyOptionalParam req (Command xs) =
    req `setQuery` toQuery ("command", Just xs)

-- | /Optional Param/ "container" - Container in which to execute the command. Defaults to only container if there is only one container in the pod.
instance HasOptionalParam ConnectPostNamespacedPodExec Container where
  applyOptionalParam req (Container xs) =
    req `setQuery` toQuery ("container", Just xs)

-- | /Optional Param/ "stderr" - Redirect the standard error stream of the pod for this call. Defaults to true.
instance HasOptionalParam ConnectPostNamespacedPodExec Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "stdin" - Redirect the standard input stream of the pod for this call. Defaults to false.
instance HasOptionalParam ConnectPostNamespacedPodExec Stdin where
  applyOptionalParam req (Stdin xs) =
    req `setQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Redirect the standard output stream of the pod for this call. Defaults to true.
instance HasOptionalParam ConnectPostNamespacedPodExec Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "tty" - TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
instance HasOptionalParam ConnectPostNamespacedPodExec Tty where
  applyOptionalParam req (Tty xs) =
    req `setQuery` toQuery ("tty", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedPodExec MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedPodExec MimeAny


-- *** connectPostNamespacedPodPortforward

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/portforward@
-- 
-- connect POST requests to portforward of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedPodPortforward 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPostNamespacedPodPortforward MimeNoContent Text accept
connectPostNamespacedPodPortforward  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/portforward"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedPodPortforward  

-- | /Optional Param/ "ports" - List of ports to forward Required when using WebSockets
instance HasOptionalParam ConnectPostNamespacedPodPortforward Ports where
  applyOptionalParam req (Ports xs) =
    req `setQuery` toQuery ("ports", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedPodPortforward MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedPodPortforward MimeAny


-- *** connectPostNamespacedPodProxy

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect POST requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPostNamespacedPodProxy MimeNoContent Text accept
connectPostNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectPostNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedPodProxy MimeAny


-- *** connectPostNamespacedPodProxyWithPath

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect POST requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPostNamespacedPodProxyWithPath MimeNoContent Text accept
connectPostNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectPostNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedPodProxyWithPath MimeAny


-- *** connectPostNamespacedServiceProxy

-- | @POST \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect POST requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPostNamespacedServiceProxy MimeNoContent Text accept
connectPostNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectPostNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedServiceProxy MimeAny


-- *** connectPostNamespacedServiceProxyWithPath

-- | @POST \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect POST requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPostNamespacedServiceProxyWithPath MimeNoContent Text accept
connectPostNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectPostNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPostNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPostNamespacedServiceProxyWithPath MimeAny


-- *** connectPostNodeProxy

-- | @POST \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect POST requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectPostNodeProxy MimeNoContent Text accept
connectPostNodeProxy  _ (Name name) =
  _mkRequest "POST" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectPostNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPostNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectPostNodeProxy MimeAny


-- *** connectPostNodeProxyWithPath

-- | @POST \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect POST requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPostNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPostNodeProxyWithPath MimeNoContent Text accept
connectPostNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "POST" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPostNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectPostNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPostNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPostNodeProxyWithPath MimeAny


-- *** connectPutNamespacedPodProxy

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy@
-- 
-- connect PUT requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPutNamespacedPodProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPutNamespacedPodProxy MimeNoContent Text accept
connectPutNamespacedPodProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPutNamespacedPodProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectPutNamespacedPodProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPutNamespacedPodProxy MimeAny

-- | @*/*@
instance Produces ConnectPutNamespacedPodProxy MimeAny


-- *** connectPutNamespacedPodProxyWithPath

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/proxy\/{path}@
-- 
-- connect PUT requests to proxy of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPutNamespacedPodProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPutNamespacedPodProxyWithPath MimeNoContent Text accept
connectPutNamespacedPodProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPutNamespacedPodProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to pod.
instance HasOptionalParam ConnectPutNamespacedPodProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPutNamespacedPodProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPutNamespacedPodProxyWithPath MimeAny


-- *** connectPutNamespacedServiceProxy

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy@
-- 
-- connect PUT requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPutNamespacedServiceProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ConnectPutNamespacedServiceProxy MimeNoContent Text accept
connectPutNamespacedServiceProxy  _ (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPutNamespacedServiceProxy  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectPutNamespacedServiceProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPutNamespacedServiceProxy MimeAny

-- | @*/*@
instance Produces ConnectPutNamespacedServiceProxy MimeAny


-- *** connectPutNamespacedServiceProxyWithPath

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/proxy\/{path}@
-- 
-- connect PUT requests to proxy of Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPutNamespacedServiceProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPutNamespacedServiceProxyWithPath MimeNoContent Text accept
connectPutNamespacedServiceProxyWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPutNamespacedServiceProxyWithPath  

-- | /Optional Param/ "path" - Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
instance HasOptionalParam ConnectPutNamespacedServiceProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPutNamespacedServiceProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPutNamespacedServiceProxyWithPath MimeAny


-- *** connectPutNodeProxy

-- | @PUT \/api\/v1\/nodes\/{name}\/proxy@
-- 
-- connect PUT requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPutNodeProxy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ConnectPutNodeProxy MimeNoContent Text accept
connectPutNodeProxy  _ (Name name) =
  _mkRequest "PUT" ["/api/v1/nodes/",toPath name,"/proxy"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPutNodeProxy  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectPutNodeProxy Path where
  applyOptionalParam req (Path xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPutNodeProxy MimeAny

-- | @*/*@
instance Produces ConnectPutNodeProxy MimeAny


-- *** connectPutNodeProxyWithPath

-- | @PUT \/api\/v1\/nodes\/{name}\/proxy\/{path}@
-- 
-- connect PUT requests to proxy of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
connectPutNodeProxyWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ConnectPutNodeProxyWithPath MimeNoContent Text accept
connectPutNodeProxyWithPath  _ (Name name) (Path path) =
  _mkRequest "PUT" ["/api/v1/nodes/",toPath name,"/proxy/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ConnectPutNodeProxyWithPath  

-- | /Optional Param/ "path" - Path is the URL path to use for the current proxy request to node.
instance HasOptionalParam ConnectPutNodeProxyWithPath Path2 where
  applyOptionalParam req (Path2 xs) =
    req `setQuery` toQuery ("path", Just xs)

-- | @*/*@
instance Consumes ConnectPutNodeProxyWithPath MimeAny

-- | @*/*@
instance Produces ConnectPutNodeProxyWithPath MimeAny


-- *** createNamespace

-- | @POST \/api\/v1\/namespaces@
-- 
-- create a Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespace 
  :: (Consumes CreateNamespace contentType, MimeRender contentType V1Namespace)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1Namespace -- ^ "body"
  -> KubernetesRequest CreateNamespace contentType V1Namespace accept
createNamespace _  _ body =
  _mkRequest "POST" ["/api/v1/namespaces"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespace 
instance HasBodyParam CreateNamespace V1Namespace 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespace Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespace MimeAny

-- | @application/json@
instance Produces CreateNamespace MimeJSON
-- | @application/yaml@
instance Produces CreateNamespace MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespace MimeVndKubernetesProtobuf


-- *** createNamespacedBinding

-- | @POST \/api\/v1\/namespaces\/{namespace}\/bindings@
-- 
-- create a Binding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedBinding 
  :: (Consumes CreateNamespacedBinding contentType, MimeRender contentType V1Binding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Binding -- ^ "body"
  -> KubernetesRequest CreateNamespacedBinding contentType V1Binding accept
createNamespacedBinding _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/bindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedBinding 
instance HasBodyParam CreateNamespacedBinding V1Binding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedBinding MimeAny

-- | @application/json@
instance Produces CreateNamespacedBinding MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedBinding MimeVndKubernetesProtobuf


-- *** createNamespacedConfigMap

-- | @POST \/api\/v1\/namespaces\/{namespace}\/configmaps@
-- 
-- create a ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedConfigMap 
  :: (Consumes CreateNamespacedConfigMap contentType, MimeRender contentType V1ConfigMap)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ConfigMap -- ^ "body"
  -> KubernetesRequest CreateNamespacedConfigMap contentType V1ConfigMap accept
createNamespacedConfigMap _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/configmaps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedConfigMap 
instance HasBodyParam CreateNamespacedConfigMap V1ConfigMap 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedConfigMap MimeAny

-- | @application/json@
instance Produces CreateNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedConfigMap MimeVndKubernetesProtobuf


-- *** createNamespacedEndpoints

-- | @POST \/api\/v1\/namespaces\/{namespace}\/endpoints@
-- 
-- create Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedEndpoints 
  :: (Consumes CreateNamespacedEndpoints contentType, MimeRender contentType V1Endpoints)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Endpoints -- ^ "body"
  -> KubernetesRequest CreateNamespacedEndpoints contentType V1Endpoints accept
createNamespacedEndpoints _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/endpoints"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedEndpoints 
instance HasBodyParam CreateNamespacedEndpoints V1Endpoints 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedEndpoints MimeAny

-- | @application/json@
instance Produces CreateNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedEndpoints MimeVndKubernetesProtobuf


-- *** createNamespacedEvent

-- | @POST \/api\/v1\/namespaces\/{namespace}\/events@
-- 
-- create an Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedEvent 
  :: (Consumes CreateNamespacedEvent contentType, MimeRender contentType V1Event)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Event -- ^ "body"
  -> KubernetesRequest CreateNamespacedEvent contentType V1Event accept
createNamespacedEvent _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedEvent 
instance HasBodyParam CreateNamespacedEvent V1Event 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedEvent MimeAny

-- | @application/json@
instance Produces CreateNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedEvent MimeVndKubernetesProtobuf


-- *** createNamespacedLimitRange

-- | @POST \/api\/v1\/namespaces\/{namespace}\/limitranges@
-- 
-- create a LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedLimitRange 
  :: (Consumes CreateNamespacedLimitRange contentType, MimeRender contentType V1LimitRange)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1LimitRange -- ^ "body"
  -> KubernetesRequest CreateNamespacedLimitRange contentType V1LimitRange accept
createNamespacedLimitRange _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/limitranges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedLimitRange 
instance HasBodyParam CreateNamespacedLimitRange V1LimitRange 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedLimitRange MimeAny

-- | @application/json@
instance Produces CreateNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedLimitRange MimeVndKubernetesProtobuf


-- *** createNamespacedPersistentVolumeClaim

-- | @POST \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims@
-- 
-- create a PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPersistentVolumeClaim 
  :: (Consumes CreateNamespacedPersistentVolumeClaim contentType, MimeRender contentType V1PersistentVolumeClaim)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1PersistentVolumeClaim -- ^ "body"
  -> KubernetesRequest CreateNamespacedPersistentVolumeClaim contentType V1PersistentVolumeClaim accept
createNamespacedPersistentVolumeClaim _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPersistentVolumeClaim 
instance HasBodyParam CreateNamespacedPersistentVolumeClaim V1PersistentVolumeClaim 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPersistentVolumeClaim MimeAny

-- | @application/json@
instance Produces CreateNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf


-- *** createNamespacedPod

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods@
-- 
-- create a Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPod 
  :: (Consumes CreateNamespacedPod contentType, MimeRender contentType V1Pod)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Pod -- ^ "body"
  -> KubernetesRequest CreateNamespacedPod contentType V1Pod accept
createNamespacedPod _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPod 
instance HasBodyParam CreateNamespacedPod V1Pod 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPod MimeAny

-- | @application/json@
instance Produces CreateNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPod MimeVndKubernetesProtobuf


-- *** createNamespacedPodBinding

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/binding@
-- 
-- create binding of a Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPodBinding 
  :: (Consumes CreateNamespacedPodBinding contentType, MimeRender contentType V1Binding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Binding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Binding -- ^ "body"
  -> KubernetesRequest CreateNamespacedPodBinding contentType V1Binding accept
createNamespacedPodBinding _  _ (Name name) (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/binding"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPodBinding 
instance HasBodyParam CreateNamespacedPodBinding V1Binding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPodBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPodBinding MimeAny

-- | @application/json@
instance Produces CreateNamespacedPodBinding MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPodBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPodBinding MimeVndKubernetesProtobuf


-- *** createNamespacedPodEviction

-- | @POST \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/eviction@
-- 
-- create eviction of a Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPodEviction 
  :: (Consumes CreateNamespacedPodEviction contentType, MimeRender contentType V1beta1Eviction)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Eviction
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Eviction -- ^ "body"
  -> KubernetesRequest CreateNamespacedPodEviction contentType V1beta1Eviction accept
createNamespacedPodEviction _  _ (Name name) (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/eviction"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPodEviction 
instance HasBodyParam CreateNamespacedPodEviction V1beta1Eviction 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPodEviction Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPodEviction MimeAny

-- | @application/json@
instance Produces CreateNamespacedPodEviction MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPodEviction MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPodEviction MimeVndKubernetesProtobuf


-- *** createNamespacedPodTemplate

-- | @POST \/api\/v1\/namespaces\/{namespace}\/podtemplates@
-- 
-- create a PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPodTemplate 
  :: (Consumes CreateNamespacedPodTemplate contentType, MimeRender contentType V1PodTemplate)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1PodTemplate -- ^ "body"
  -> KubernetesRequest CreateNamespacedPodTemplate contentType V1PodTemplate accept
createNamespacedPodTemplate _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/podtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPodTemplate 
instance HasBodyParam CreateNamespacedPodTemplate V1PodTemplate 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPodTemplate MimeAny

-- | @application/json@
instance Produces CreateNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPodTemplate MimeVndKubernetesProtobuf


-- *** createNamespacedReplicationController

-- | @POST \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers@
-- 
-- create a ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedReplicationController 
  :: (Consumes CreateNamespacedReplicationController contentType, MimeRender contentType V1ReplicationController)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ReplicationController -- ^ "body"
  -> KubernetesRequest CreateNamespacedReplicationController contentType V1ReplicationController accept
createNamespacedReplicationController _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedReplicationController 
instance HasBodyParam CreateNamespacedReplicationController V1ReplicationController 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedReplicationController MimeAny

-- | @application/json@
instance Produces CreateNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedReplicationController MimeVndKubernetesProtobuf


-- *** createNamespacedResourceQuota

-- | @POST \/api\/v1\/namespaces\/{namespace}\/resourcequotas@
-- 
-- create a ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedResourceQuota 
  :: (Consumes CreateNamespacedResourceQuota contentType, MimeRender contentType V1ResourceQuota)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ResourceQuota -- ^ "body"
  -> KubernetesRequest CreateNamespacedResourceQuota contentType V1ResourceQuota accept
createNamespacedResourceQuota _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedResourceQuota 
instance HasBodyParam CreateNamespacedResourceQuota V1ResourceQuota 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedResourceQuota MimeAny

-- | @application/json@
instance Produces CreateNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedResourceQuota MimeVndKubernetesProtobuf


-- *** createNamespacedSecret

-- | @POST \/api\/v1\/namespaces\/{namespace}\/secrets@
-- 
-- create a Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedSecret 
  :: (Consumes CreateNamespacedSecret contentType, MimeRender contentType V1Secret)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Secret -- ^ "body"
  -> KubernetesRequest CreateNamespacedSecret contentType V1Secret accept
createNamespacedSecret _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/secrets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedSecret 
instance HasBodyParam CreateNamespacedSecret V1Secret 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedSecret MimeAny

-- | @application/json@
instance Produces CreateNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedSecret MimeVndKubernetesProtobuf


-- *** createNamespacedService

-- | @POST \/api\/v1\/namespaces\/{namespace}\/services@
-- 
-- create a Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedService 
  :: (Consumes CreateNamespacedService contentType, MimeRender contentType V1Service)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Service -- ^ "body"
  -> KubernetesRequest CreateNamespacedService contentType V1Service accept
createNamespacedService _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/services"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedService 
instance HasBodyParam CreateNamespacedService V1Service 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedService MimeAny

-- | @application/json@
instance Produces CreateNamespacedService MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedService MimeVndKubernetesProtobuf


-- *** createNamespacedServiceAccount

-- | @POST \/api\/v1\/namespaces\/{namespace}\/serviceaccounts@
-- 
-- create a ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedServiceAccount 
  :: (Consumes CreateNamespacedServiceAccount contentType, MimeRender contentType V1ServiceAccount)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ServiceAccount -- ^ "body"
  -> KubernetesRequest CreateNamespacedServiceAccount contentType V1ServiceAccount accept
createNamespacedServiceAccount _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedServiceAccount 
instance HasBodyParam CreateNamespacedServiceAccount V1ServiceAccount 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedServiceAccount MimeAny

-- | @application/json@
instance Produces CreateNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedServiceAccount MimeVndKubernetesProtobuf


-- *** createNode

-- | @POST \/api\/v1\/nodes@
-- 
-- create a Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNode 
  :: (Consumes CreateNode contentType, MimeRender contentType V1Node)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1Node -- ^ "body"
  -> KubernetesRequest CreateNode contentType V1Node accept
createNode _  _ body =
  _mkRequest "POST" ["/api/v1/nodes"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNode 
instance HasBodyParam CreateNode V1Node 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNode MimeAny

-- | @application/json@
instance Produces CreateNode MimeJSON
-- | @application/yaml@
instance Produces CreateNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNode MimeVndKubernetesProtobuf


-- *** createPersistentVolume

-- | @POST \/api\/v1\/persistentvolumes@
-- 
-- create a PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createPersistentVolume 
  :: (Consumes CreatePersistentVolume contentType, MimeRender contentType V1PersistentVolume)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1PersistentVolume -- ^ "body"
  -> KubernetesRequest CreatePersistentVolume contentType V1PersistentVolume accept
createPersistentVolume _  _ body =
  _mkRequest "POST" ["/api/v1/persistentvolumes"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreatePersistentVolume 
instance HasBodyParam CreatePersistentVolume V1PersistentVolume 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreatePersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreatePersistentVolume MimeAny

-- | @application/json@
instance Produces CreatePersistentVolume MimeJSON
-- | @application/yaml@
instance Produces CreatePersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreatePersistentVolume MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedConfigMap

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/configmaps@
-- 
-- delete collection of ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedConfigMap 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedConfigMap MimeNoContent V1Status accept
deleteCollectionNamespacedConfigMap  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/configmaps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedConfigMap  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedConfigMap Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedConfigMap MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedConfigMap MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedEndpoints

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/endpoints@
-- 
-- delete collection of Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedEndpoints 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedEndpoints MimeNoContent V1Status accept
deleteCollectionNamespacedEndpoints  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/endpoints"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedEndpoints  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedEndpoints Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedEndpoints MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedEndpoints MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedEvent

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/events@
-- 
-- delete collection of Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedEvent 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedEvent MimeNoContent V1Status accept
deleteCollectionNamespacedEvent  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedEvent  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedEvent Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedEvent FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedEvent IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedEvent LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedEvent Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedEvent ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedEvent TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedEvent Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedEvent MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedEvent MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedLimitRange

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/limitranges@
-- 
-- delete collection of LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedLimitRange 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedLimitRange MimeNoContent V1Status accept
deleteCollectionNamespacedLimitRange  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/limitranges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedLimitRange  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedLimitRange Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedLimitRange MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedLimitRange MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedPersistentVolumeClaim

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims@
-- 
-- delete collection of PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedPersistentVolumeClaim 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedPersistentVolumeClaim MimeNoContent V1Status accept
deleteCollectionNamespacedPersistentVolumeClaim  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedPersistentVolumeClaim  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedPersistentVolumeClaim Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedPersistentVolumeClaim MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedPod

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/pods@
-- 
-- delete collection of Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedPod MimeNoContent V1Status accept
deleteCollectionNamespacedPod  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/pods"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedPod  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedPod Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPod FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedPod IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPod LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedPod Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedPod ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedPod TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedPod Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedPod MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedPod MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedPodTemplate

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/podtemplates@
-- 
-- delete collection of PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedPodTemplate 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedPodTemplate MimeNoContent V1Status accept
deleteCollectionNamespacedPodTemplate  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/podtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedPodTemplate  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedPodTemplate Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedPodTemplate MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedPodTemplate MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedReplicationController

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers@
-- 
-- delete collection of ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedReplicationController 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedReplicationController MimeNoContent V1Status accept
deleteCollectionNamespacedReplicationController  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedReplicationController  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedReplicationController Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedReplicationController MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedReplicationController MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedResourceQuota

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/resourcequotas@
-- 
-- delete collection of ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedResourceQuota 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedResourceQuota MimeNoContent V1Status accept
deleteCollectionNamespacedResourceQuota  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedResourceQuota  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedResourceQuota Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedResourceQuota MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedResourceQuota MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedSecret

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/secrets@
-- 
-- delete collection of Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedSecret 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedSecret MimeNoContent V1Status accept
deleteCollectionNamespacedSecret  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/secrets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedSecret  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedSecret Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedSecret FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedSecret IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedSecret LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedSecret Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedSecret ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedSecret TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedSecret Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedSecret MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedSecret MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedServiceAccount

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/serviceaccounts@
-- 
-- delete collection of ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedServiceAccount 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedServiceAccount MimeNoContent V1Status accept
deleteCollectionNamespacedServiceAccount  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedServiceAccount  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedServiceAccount Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedServiceAccount MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedServiceAccount MimeVndKubernetesProtobuf


-- *** deleteCollectionNode

-- | @DELETE \/api\/v1\/nodes@
-- 
-- delete collection of Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionNode MimeNoContent V1Status accept
deleteCollectionNode  _ =
  _mkRequest "DELETE" ["/api/v1/nodes"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNode  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNode Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNode FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNode IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNode LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNode Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNode ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNode TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNode Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNode MimeAny

-- | @application/json@
instance Produces DeleteCollectionNode MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNode MimeVndKubernetesProtobuf


-- *** deleteCollectionPersistentVolume

-- | @DELETE \/api\/v1\/persistentvolumes@
-- 
-- delete collection of PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionPersistentVolume 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionPersistentVolume MimeNoContent V1Status accept
deleteCollectionPersistentVolume  _ =
  _mkRequest "DELETE" ["/api/v1/persistentvolumes"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionPersistentVolume  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionPersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionPersistentVolume Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionPersistentVolume FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionPersistentVolume IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionPersistentVolume LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionPersistentVolume Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionPersistentVolume ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionPersistentVolume TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionPersistentVolume Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionPersistentVolume MimeAny

-- | @application/json@
instance Produces DeleteCollectionPersistentVolume MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionPersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionPersistentVolume MimeVndKubernetesProtobuf


-- *** deleteNamespace

-- | @DELETE \/api\/v1\/namespaces\/{name}@
-- 
-- delete a Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespace 
  :: (Consumes DeleteNamespace contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespace contentType V1Status accept
deleteNamespace _  _ (Name name) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespace 
instance HasBodyParam DeleteNamespace V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespace Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespace GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespace OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespace PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespace MimeAny

-- | @application/json@
instance Produces DeleteNamespace MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespace MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespace MimeVndKubernetesProtobuf


-- *** deleteNamespacedConfigMap

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/configmaps\/{name}@
-- 
-- delete a ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedConfigMap 
  :: (Consumes DeleteNamespacedConfigMap contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ConfigMap
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedConfigMap contentType V1Status accept
deleteNamespacedConfigMap _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/configmaps/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedConfigMap 
instance HasBodyParam DeleteNamespacedConfigMap V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedConfigMap GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedConfigMap OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedConfigMap PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedConfigMap MimeAny

-- | @application/json@
instance Produces DeleteNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedConfigMap MimeVndKubernetesProtobuf


-- *** deleteNamespacedEndpoints

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/endpoints\/{name}@
-- 
-- delete Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedEndpoints 
  :: (Consumes DeleteNamespacedEndpoints contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Endpoints
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedEndpoints contentType V1Status accept
deleteNamespacedEndpoints _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/endpoints/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedEndpoints 
instance HasBodyParam DeleteNamespacedEndpoints V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedEndpoints GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedEndpoints OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedEndpoints PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedEndpoints MimeAny

-- | @application/json@
instance Produces DeleteNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedEndpoints MimeVndKubernetesProtobuf


-- *** deleteNamespacedEvent

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- delete an Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedEvent 
  :: (Consumes DeleteNamespacedEvent contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedEvent contentType V1Status accept
deleteNamespacedEvent _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedEvent 
instance HasBodyParam DeleteNamespacedEvent V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedEvent GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedEvent OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedEvent PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedEvent MimeAny

-- | @application/json@
instance Produces DeleteNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedEvent MimeVndKubernetesProtobuf


-- *** deleteNamespacedLimitRange

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/limitranges\/{name}@
-- 
-- delete a LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedLimitRange 
  :: (Consumes DeleteNamespacedLimitRange contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the LimitRange
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedLimitRange contentType V1Status accept
deleteNamespacedLimitRange _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/limitranges/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedLimitRange 
instance HasBodyParam DeleteNamespacedLimitRange V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedLimitRange GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedLimitRange OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedLimitRange PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedLimitRange MimeAny

-- | @application/json@
instance Produces DeleteNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedLimitRange MimeVndKubernetesProtobuf


-- *** deleteNamespacedPersistentVolumeClaim

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}@
-- 
-- delete a PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedPersistentVolumeClaim 
  :: (Consumes DeleteNamespacedPersistentVolumeClaim contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedPersistentVolumeClaim contentType V1Status accept
deleteNamespacedPersistentVolumeClaim _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedPersistentVolumeClaim 
instance HasBodyParam DeleteNamespacedPersistentVolumeClaim V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedPersistentVolumeClaim GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedPersistentVolumeClaim OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedPersistentVolumeClaim PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedPersistentVolumeClaim MimeAny

-- | @application/json@
instance Produces DeleteNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf


-- *** deleteNamespacedPod

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- delete a Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedPod 
  :: (Consumes DeleteNamespacedPod contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedPod contentType V1Status accept
deleteNamespacedPod _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedPod 
instance HasBodyParam DeleteNamespacedPod V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedPod GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedPod OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedPod PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedPod MimeAny

-- | @application/json@
instance Produces DeleteNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedPod MimeVndKubernetesProtobuf


-- *** deleteNamespacedPodTemplate

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/podtemplates\/{name}@
-- 
-- delete a PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedPodTemplate 
  :: (Consumes DeleteNamespacedPodTemplate contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedPodTemplate contentType V1Status accept
deleteNamespacedPodTemplate _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/podtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedPodTemplate 
instance HasBodyParam DeleteNamespacedPodTemplate V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedPodTemplate GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedPodTemplate OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedPodTemplate PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedPodTemplate MimeAny

-- | @application/json@
instance Produces DeleteNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedPodTemplate MimeVndKubernetesProtobuf


-- *** deleteNamespacedReplicationController

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}@
-- 
-- delete a ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedReplicationController 
  :: (Consumes DeleteNamespacedReplicationController contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedReplicationController contentType V1Status accept
deleteNamespacedReplicationController _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedReplicationController 
instance HasBodyParam DeleteNamespacedReplicationController V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedReplicationController GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedReplicationController OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedReplicationController PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedReplicationController MimeAny

-- | @application/json@
instance Produces DeleteNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedReplicationController MimeVndKubernetesProtobuf


-- *** deleteNamespacedResourceQuota

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}@
-- 
-- delete a ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedResourceQuota 
  :: (Consumes DeleteNamespacedResourceQuota contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedResourceQuota contentType V1Status accept
deleteNamespacedResourceQuota _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedResourceQuota 
instance HasBodyParam DeleteNamespacedResourceQuota V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedResourceQuota GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedResourceQuota OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedResourceQuota PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedResourceQuota MimeAny

-- | @application/json@
instance Produces DeleteNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedResourceQuota MimeVndKubernetesProtobuf


-- *** deleteNamespacedSecret

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/secrets\/{name}@
-- 
-- delete a Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedSecret 
  :: (Consumes DeleteNamespacedSecret contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Secret
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedSecret contentType V1Status accept
deleteNamespacedSecret _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/secrets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedSecret 
instance HasBodyParam DeleteNamespacedSecret V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedSecret GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedSecret OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedSecret PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedSecret MimeAny

-- | @application/json@
instance Produces DeleteNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedSecret MimeVndKubernetesProtobuf


-- *** deleteNamespacedService

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/services\/{name}@
-- 
-- delete a Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedService MimeNoContent V1Status accept
deleteNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedService  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedService MimeAny

-- | @application/json@
instance Produces DeleteNamespacedService MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedService MimeVndKubernetesProtobuf


-- *** deleteNamespacedServiceAccount

-- | @DELETE \/api\/v1\/namespaces\/{namespace}\/serviceaccounts\/{name}@
-- 
-- delete a ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedServiceAccount 
  :: (Consumes DeleteNamespacedServiceAccount contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ServiceAccount
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedServiceAccount contentType V1Status accept
deleteNamespacedServiceAccount _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedServiceAccount 
instance HasBodyParam DeleteNamespacedServiceAccount V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedServiceAccount GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedServiceAccount OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedServiceAccount PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedServiceAccount MimeAny

-- | @application/json@
instance Produces DeleteNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedServiceAccount MimeVndKubernetesProtobuf


-- *** deleteNode

-- | @DELETE \/api\/v1\/nodes\/{name}@
-- 
-- delete a Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNode 
  :: (Consumes DeleteNode contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNode contentType V1Status accept
deleteNode _  _ (Name name) body =
  _mkRequest "DELETE" ["/api/v1/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNode 
instance HasBodyParam DeleteNode V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNode GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNode OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNode PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNode MimeAny

-- | @application/json@
instance Produces DeleteNode MimeJSON
-- | @application/yaml@
instance Produces DeleteNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNode MimeVndKubernetesProtobuf


-- *** deletePersistentVolume

-- | @DELETE \/api\/v1\/persistentvolumes\/{name}@
-- 
-- delete a PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deletePersistentVolume 
  :: (Consumes DeletePersistentVolume contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeletePersistentVolume contentType V1Status accept
deletePersistentVolume _  _ (Name name) body =
  _mkRequest "DELETE" ["/api/v1/persistentvolumes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeletePersistentVolume 
instance HasBodyParam DeletePersistentVolume V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeletePersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeletePersistentVolume GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeletePersistentVolume OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeletePersistentVolume PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeletePersistentVolume MimeAny

-- | @application/json@
instance Produces DeletePersistentVolume MimeJSON
-- | @application/yaml@
instance Produces DeletePersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeletePersistentVolume MimeVndKubernetesProtobuf


-- *** getAPIResources

-- | @GET \/api\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources MimeNoContent V1APIResourceList accept
getAPIResources  _ =
  _mkRequest "GET" ["/api/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources  

-- | @application/json@
instance Consumes GetAPIResources MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources MimeVndKubernetesProtobuf


-- *** listComponentStatus

-- | @GET \/api\/v1\/componentstatuses@
-- 
-- list objects of kind ComponentStatus
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listComponentStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListComponentStatus MimeNoContent V1ComponentStatusList accept
listComponentStatus  _ =
  _mkRequest "GET" ["/api/v1/componentstatuses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListComponentStatus  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListComponentStatus Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListComponentStatus FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListComponentStatus IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListComponentStatus LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListComponentStatus Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListComponentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListComponentStatus ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListComponentStatus TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListComponentStatus Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListComponentStatus MimeAny

-- | @application/json@
instance Produces ListComponentStatus MimeJSON
-- | @application/yaml@
instance Produces ListComponentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListComponentStatus MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListComponentStatus MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListComponentStatus MimeVndKubernetesProtobufstreamwatch


-- *** listConfigMapForAllNamespaces

-- | @GET \/api\/v1\/configmaps@
-- 
-- list or watch objects of kind ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listConfigMapForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListConfigMapForAllNamespaces MimeNoContent V1ConfigMapList accept
listConfigMapForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/configmaps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListConfigMapForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListConfigMapForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListConfigMapForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListConfigMapForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListConfigMapForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListConfigMapForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListConfigMapForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListConfigMapForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListConfigMapForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListConfigMapForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListConfigMapForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListConfigMapForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListConfigMapForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListConfigMapForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListConfigMapForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListConfigMapForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listEndpointsForAllNamespaces

-- | @GET \/api\/v1\/endpoints@
-- 
-- list or watch objects of kind Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listEndpointsForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListEndpointsForAllNamespaces MimeNoContent V1EndpointsList accept
listEndpointsForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/endpoints"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListEndpointsForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListEndpointsForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListEndpointsForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListEndpointsForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListEndpointsForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListEndpointsForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListEndpointsForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListEndpointsForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListEndpointsForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListEndpointsForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListEndpointsForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListEndpointsForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListEndpointsForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListEndpointsForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListEndpointsForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListEndpointsForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listEventForAllNamespaces

-- | @GET \/api\/v1\/events@
-- 
-- list or watch objects of kind Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listEventForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListEventForAllNamespaces MimeNoContent V1EventList accept
listEventForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListEventForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListEventForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListEventForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListEventForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListEventForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListEventForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListEventForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListEventForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListEventForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListEventForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListEventForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListEventForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListEventForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListEventForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListEventForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListEventForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listLimitRangeForAllNamespaces

-- | @GET \/api\/v1\/limitranges@
-- 
-- list or watch objects of kind LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listLimitRangeForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListLimitRangeForAllNamespaces MimeNoContent V1LimitRangeList accept
listLimitRangeForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/limitranges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListLimitRangeForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListLimitRangeForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListLimitRangeForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListLimitRangeForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListLimitRangeForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListLimitRangeForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListLimitRangeForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListLimitRangeForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListLimitRangeForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListLimitRangeForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListLimitRangeForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListLimitRangeForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListLimitRangeForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListLimitRangeForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListLimitRangeForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListLimitRangeForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespace

-- | @GET \/api\/v1\/namespaces@
-- 
-- list or watch objects of kind Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespace 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListNamespace MimeNoContent V1NamespaceList accept
listNamespace  _ =
  _mkRequest "GET" ["/api/v1/namespaces"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespace  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespace Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespace Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespace FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespace IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespace LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespace Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespace ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespace TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespace Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespace MimeAny

-- | @application/json@
instance Produces ListNamespace MimeJSON
-- | @application/yaml@
instance Produces ListNamespace MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespace MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespace MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespace MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedConfigMap

-- | @GET \/api\/v1\/namespaces\/{namespace}\/configmaps@
-- 
-- list or watch objects of kind ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedConfigMap 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedConfigMap MimeNoContent V1ConfigMapList accept
listNamespacedConfigMap  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/configmaps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedConfigMap  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedConfigMap Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedConfigMap FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedConfigMap IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedConfigMap LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedConfigMap Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedConfigMap ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedConfigMap TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedConfigMap Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedConfigMap MimeAny

-- | @application/json@
instance Produces ListNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedConfigMap MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedConfigMap MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedConfigMap MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedEndpoints

-- | @GET \/api\/v1\/namespaces\/{namespace}\/endpoints@
-- 
-- list or watch objects of kind Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedEndpoints 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedEndpoints MimeNoContent V1EndpointsList accept
listNamespacedEndpoints  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/endpoints"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedEndpoints  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedEndpoints Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedEndpoints FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedEndpoints IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedEndpoints LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedEndpoints Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedEndpoints ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedEndpoints TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedEndpoints Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedEndpoints MimeAny

-- | @application/json@
instance Produces ListNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedEndpoints MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedEndpoints MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedEndpoints MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedEvent

-- | @GET \/api\/v1\/namespaces\/{namespace}\/events@
-- 
-- list or watch objects of kind Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedEvent 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedEvent MimeNoContent V1EventList accept
listNamespacedEvent  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedEvent  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedEvent Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedEvent FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedEvent IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedEvent LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedEvent Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedEvent ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedEvent TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedEvent Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedEvent MimeAny

-- | @application/json@
instance Produces ListNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedEvent MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedEvent MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedEvent MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedLimitRange

-- | @GET \/api\/v1\/namespaces\/{namespace}\/limitranges@
-- 
-- list or watch objects of kind LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedLimitRange 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedLimitRange MimeNoContent V1LimitRangeList accept
listNamespacedLimitRange  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/limitranges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedLimitRange  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedLimitRange Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedLimitRange FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedLimitRange IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedLimitRange LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedLimitRange Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedLimitRange ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedLimitRange TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedLimitRange Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedLimitRange MimeAny

-- | @application/json@
instance Produces ListNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedLimitRange MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedLimitRange MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedLimitRange MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedPersistentVolumeClaim

-- | @GET \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims@
-- 
-- list or watch objects of kind PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedPersistentVolumeClaim 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedPersistentVolumeClaim MimeNoContent V1PersistentVolumeClaimList accept
listNamespacedPersistentVolumeClaim  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedPersistentVolumeClaim  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedPersistentVolumeClaim Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedPersistentVolumeClaim MimeAny

-- | @application/json@
instance Produces ListNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedPersistentVolumeClaim MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedPersistentVolumeClaim MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedPod

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods@
-- 
-- list or watch objects of kind Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedPod MimeNoContent V1PodList accept
listNamespacedPod  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedPod  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedPod Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedPod FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedPod IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedPod LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedPod Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedPod ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedPod TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedPod Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedPod MimeAny

-- | @application/json@
instance Produces ListNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedPod MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedPod MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedPod MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedPodTemplate

-- | @GET \/api\/v1\/namespaces\/{namespace}\/podtemplates@
-- 
-- list or watch objects of kind PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedPodTemplate 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedPodTemplate MimeNoContent V1PodTemplateList accept
listNamespacedPodTemplate  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/podtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedPodTemplate  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedPodTemplate Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedPodTemplate FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedPodTemplate IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedPodTemplate LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedPodTemplate Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedPodTemplate ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedPodTemplate TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedPodTemplate Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedPodTemplate MimeAny

-- | @application/json@
instance Produces ListNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedPodTemplate MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedPodTemplate MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedPodTemplate MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedReplicationController

-- | @GET \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers@
-- 
-- list or watch objects of kind ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedReplicationController 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedReplicationController MimeNoContent V1ReplicationControllerList accept
listNamespacedReplicationController  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedReplicationController  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedReplicationController Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicationController FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedReplicationController IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicationController LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedReplicationController Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedReplicationController ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedReplicationController TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedReplicationController Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedReplicationController MimeAny

-- | @application/json@
instance Produces ListNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedReplicationController MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedReplicationController MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedReplicationController MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedResourceQuota

-- | @GET \/api\/v1\/namespaces\/{namespace}\/resourcequotas@
-- 
-- list or watch objects of kind ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedResourceQuota 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedResourceQuota MimeNoContent V1ResourceQuotaList accept
listNamespacedResourceQuota  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedResourceQuota  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedResourceQuota Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedResourceQuota FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedResourceQuota IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedResourceQuota LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedResourceQuota Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedResourceQuota ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedResourceQuota TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedResourceQuota Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedResourceQuota MimeAny

-- | @application/json@
instance Produces ListNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedResourceQuota MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedResourceQuota MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedResourceQuota MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedSecret

-- | @GET \/api\/v1\/namespaces\/{namespace}\/secrets@
-- 
-- list or watch objects of kind Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedSecret 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedSecret MimeNoContent V1SecretList accept
listNamespacedSecret  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/secrets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedSecret  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedSecret Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedSecret FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedSecret IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedSecret LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedSecret Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedSecret ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedSecret TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedSecret Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedSecret MimeAny

-- | @application/json@
instance Produces ListNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedSecret MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedSecret MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedSecret MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedService

-- | @GET \/api\/v1\/namespaces\/{namespace}\/services@
-- 
-- list or watch objects of kind Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedService MimeNoContent V1ServiceList accept
listNamespacedService  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/services"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedService  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedService Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedService FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedService IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedService LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedService Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedService ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedService TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedService Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedService MimeAny

-- | @application/json@
instance Produces ListNamespacedService MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedService MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedService MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedService MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedServiceAccount

-- | @GET \/api\/v1\/namespaces\/{namespace}\/serviceaccounts@
-- 
-- list or watch objects of kind ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedServiceAccount 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedServiceAccount MimeNoContent V1ServiceAccountList accept
listNamespacedServiceAccount  _ (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedServiceAccount  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedServiceAccount Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedServiceAccount FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedServiceAccount IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedServiceAccount LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedServiceAccount Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedServiceAccount ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedServiceAccount TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedServiceAccount Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedServiceAccount MimeAny

-- | @application/json@
instance Produces ListNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedServiceAccount MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedServiceAccount MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedServiceAccount MimeVndKubernetesProtobufstreamwatch


-- *** listNode

-- | @GET \/api\/v1\/nodes@
-- 
-- list or watch objects of kind Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListNode MimeNoContent V1NodeList accept
listNode  _ =
  _mkRequest "GET" ["/api/v1/nodes"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNode  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNode Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNode FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNode IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNode LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNode Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNode ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNode TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNode Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNode MimeAny

-- | @application/json@
instance Produces ListNode MimeJSON
-- | @application/yaml@
instance Produces ListNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNode MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNode MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNode MimeVndKubernetesProtobufstreamwatch


-- *** listPersistentVolume

-- | @GET \/api\/v1\/persistentvolumes@
-- 
-- list or watch objects of kind PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPersistentVolume 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPersistentVolume MimeNoContent V1PersistentVolumeList accept
listPersistentVolume  _ =
  _mkRequest "GET" ["/api/v1/persistentvolumes"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPersistentVolume  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPersistentVolume Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPersistentVolume FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPersistentVolume IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPersistentVolume LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPersistentVolume Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPersistentVolume ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPersistentVolume TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPersistentVolume Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPersistentVolume MimeAny

-- | @application/json@
instance Produces ListPersistentVolume MimeJSON
-- | @application/yaml@
instance Produces ListPersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPersistentVolume MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPersistentVolume MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPersistentVolume MimeVndKubernetesProtobufstreamwatch


-- *** listPersistentVolumeClaimForAllNamespaces

-- | @GET \/api\/v1\/persistentvolumeclaims@
-- 
-- list or watch objects of kind PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPersistentVolumeClaimForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPersistentVolumeClaimForAllNamespaces MimeNoContent V1PersistentVolumeClaimList accept
listPersistentVolumeClaimForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/persistentvolumeclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPersistentVolumeClaimForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPersistentVolumeClaimForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPersistentVolumeClaimForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListPersistentVolumeClaimForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListPersistentVolumeClaimForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPersistentVolumeClaimForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPersistentVolumeClaimForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPersistentVolumeClaimForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listPodForAllNamespaces

-- | @GET \/api\/v1\/pods@
-- 
-- list or watch objects of kind Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodForAllNamespaces MimeNoContent V1PodList accept
listPodForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/pods"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPodForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPodForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPodForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPodForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListPodForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListPodForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPodForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listPodTemplateForAllNamespaces

-- | @GET \/api\/v1\/podtemplates@
-- 
-- list or watch objects of kind PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodTemplateForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodTemplateForAllNamespaces MimeNoContent V1PodTemplateList accept
listPodTemplateForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/podtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodTemplateForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodTemplateForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodTemplateForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPodTemplateForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodTemplateForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodTemplateForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodTemplateForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPodTemplateForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPodTemplateForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodTemplateForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPodTemplateForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListPodTemplateForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListPodTemplateForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodTemplateForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPodTemplateForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodTemplateForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listReplicationControllerForAllNamespaces

-- | @GET \/api\/v1\/replicationcontrollers@
-- 
-- list or watch objects of kind ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listReplicationControllerForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListReplicationControllerForAllNamespaces MimeNoContent V1ReplicationControllerList accept
listReplicationControllerForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/replicationcontrollers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListReplicationControllerForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListReplicationControllerForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListReplicationControllerForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListReplicationControllerForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListReplicationControllerForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListReplicationControllerForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListReplicationControllerForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListReplicationControllerForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListReplicationControllerForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListReplicationControllerForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListReplicationControllerForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListReplicationControllerForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListReplicationControllerForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListReplicationControllerForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListReplicationControllerForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListReplicationControllerForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listResourceQuotaForAllNamespaces

-- | @GET \/api\/v1\/resourcequotas@
-- 
-- list or watch objects of kind ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listResourceQuotaForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListResourceQuotaForAllNamespaces MimeNoContent V1ResourceQuotaList accept
listResourceQuotaForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/resourcequotas"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListResourceQuotaForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListResourceQuotaForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListResourceQuotaForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListResourceQuotaForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListResourceQuotaForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListResourceQuotaForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListResourceQuotaForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListResourceQuotaForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListResourceQuotaForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListResourceQuotaForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListResourceQuotaForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListResourceQuotaForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListResourceQuotaForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListResourceQuotaForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListResourceQuotaForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListResourceQuotaForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listSecretForAllNamespaces

-- | @GET \/api\/v1\/secrets@
-- 
-- list or watch objects of kind Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listSecretForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListSecretForAllNamespaces MimeNoContent V1SecretList accept
listSecretForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/secrets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListSecretForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListSecretForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListSecretForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListSecretForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListSecretForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListSecretForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListSecretForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListSecretForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListSecretForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListSecretForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListSecretForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListSecretForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListSecretForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListSecretForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListSecretForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListSecretForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listServiceAccountForAllNamespaces

-- | @GET \/api\/v1\/serviceaccounts@
-- 
-- list or watch objects of kind ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listServiceAccountForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListServiceAccountForAllNamespaces MimeNoContent V1ServiceAccountList accept
listServiceAccountForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/serviceaccounts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListServiceAccountForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListServiceAccountForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListServiceAccountForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListServiceAccountForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListServiceAccountForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListServiceAccountForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListServiceAccountForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListServiceAccountForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListServiceAccountForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListServiceAccountForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListServiceAccountForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListServiceAccountForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListServiceAccountForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListServiceAccountForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListServiceAccountForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListServiceAccountForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listServiceForAllNamespaces

-- | @GET \/api\/v1\/services@
-- 
-- list or watch objects of kind Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listServiceForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListServiceForAllNamespaces MimeNoContent V1ServiceList accept
listServiceForAllNamespaces  _ =
  _mkRequest "GET" ["/api/v1/services"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListServiceForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListServiceForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListServiceForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListServiceForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListServiceForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListServiceForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListServiceForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListServiceForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListServiceForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListServiceForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListServiceForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListServiceForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListServiceForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListServiceForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListServiceForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListServiceForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespace

-- | @PATCH \/api\/v1\/namespaces\/{name}@
-- 
-- partially update the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespace 
  :: (Consumes PatchNamespace contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespace contentType V1Namespace accept
patchNamespace _  _ (Name name) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespace 
instance HasBodyParam PatchNamespace A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespace Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespace MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespace MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespace MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespace MimeJSON
-- | @application/yaml@
instance Produces PatchNamespace MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespace MimeVndKubernetesProtobuf


-- *** patchNamespaceStatus

-- | @PATCH \/api\/v1\/namespaces\/{name}\/status@
-- 
-- partially update status of the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespaceStatus 
  :: (Consumes PatchNamespaceStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespaceStatus contentType V1Namespace accept
patchNamespaceStatus _  _ (Name name) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespaceStatus 
instance HasBodyParam PatchNamespaceStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespaceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespaceStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespaceStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespaceStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespaceStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespaceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespaceStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedConfigMap

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/configmaps\/{name}@
-- 
-- partially update the specified ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedConfigMap 
  :: (Consumes PatchNamespacedConfigMap contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ConfigMap
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedConfigMap contentType V1ConfigMap accept
patchNamespacedConfigMap _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/configmaps/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedConfigMap 
instance HasBodyParam PatchNamespacedConfigMap A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedConfigMap MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedConfigMap MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedConfigMap MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedConfigMap MimeVndKubernetesProtobuf


-- *** patchNamespacedEndpoints

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/endpoints\/{name}@
-- 
-- partially update the specified Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedEndpoints 
  :: (Consumes PatchNamespacedEndpoints contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Endpoints
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedEndpoints contentType V1Endpoints accept
patchNamespacedEndpoints _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/endpoints/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedEndpoints 
instance HasBodyParam PatchNamespacedEndpoints A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedEndpoints MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedEndpoints MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedEndpoints MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedEndpoints MimeVndKubernetesProtobuf


-- *** patchNamespacedEvent

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- partially update the specified Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedEvent 
  :: (Consumes PatchNamespacedEvent contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedEvent contentType V1Event accept
patchNamespacedEvent _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedEvent 
instance HasBodyParam PatchNamespacedEvent A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedEvent MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedEvent MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedEvent MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedEvent MimeVndKubernetesProtobuf


-- *** patchNamespacedLimitRange

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/limitranges\/{name}@
-- 
-- partially update the specified LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedLimitRange 
  :: (Consumes PatchNamespacedLimitRange contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the LimitRange
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedLimitRange contentType V1LimitRange accept
patchNamespacedLimitRange _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/limitranges/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedLimitRange 
instance HasBodyParam PatchNamespacedLimitRange A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedLimitRange MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedLimitRange MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedLimitRange MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedLimitRange MimeVndKubernetesProtobuf


-- *** patchNamespacedPersistentVolumeClaim

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}@
-- 
-- partially update the specified PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPersistentVolumeClaim 
  :: (Consumes PatchNamespacedPersistentVolumeClaim contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPersistentVolumeClaim contentType V1PersistentVolumeClaim accept
patchNamespacedPersistentVolumeClaim _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPersistentVolumeClaim 
instance HasBodyParam PatchNamespacedPersistentVolumeClaim A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPersistentVolumeClaim MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPersistentVolumeClaim MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPersistentVolumeClaim MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf


-- *** patchNamespacedPersistentVolumeClaimStatus

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}\/status@
-- 
-- partially update status of the specified PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPersistentVolumeClaimStatus 
  :: (Consumes PatchNamespacedPersistentVolumeClaimStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPersistentVolumeClaimStatus contentType V1PersistentVolumeClaim accept
patchNamespacedPersistentVolumeClaimStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPersistentVolumeClaimStatus 
instance HasBodyParam PatchNamespacedPersistentVolumeClaimStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPersistentVolumeClaimStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPersistentVolumeClaimStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPersistentVolumeClaimStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPersistentVolumeClaimStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPersistentVolumeClaimStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPersistentVolumeClaimStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPersistentVolumeClaimStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedPod

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- partially update the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPod 
  :: (Consumes PatchNamespacedPod contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPod contentType V1Pod accept
patchNamespacedPod _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPod 
instance HasBodyParam PatchNamespacedPod A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPod MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPod MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPod MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPod MimeVndKubernetesProtobuf


-- *** patchNamespacedPodStatus

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/status@
-- 
-- partially update status of the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodStatus 
  :: (Consumes PatchNamespacedPodStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPodStatus contentType V1Pod accept
patchNamespacedPodStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodStatus 
instance HasBodyParam PatchNamespacedPodStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPodStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedPodTemplate

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/podtemplates\/{name}@
-- 
-- partially update the specified PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodTemplate 
  :: (Consumes PatchNamespacedPodTemplate contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPodTemplate contentType V1PodTemplate accept
patchNamespacedPodTemplate _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/podtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodTemplate 
instance HasBodyParam PatchNamespacedPodTemplate A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodTemplate MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodTemplate MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodTemplate MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodTemplate MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicationController

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}@
-- 
-- partially update the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicationController 
  :: (Consumes PatchNamespacedReplicationController contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicationController contentType V1ReplicationController accept
patchNamespacedReplicationController _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicationController 
instance HasBodyParam PatchNamespacedReplicationController A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicationController MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicationController MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicationController MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicationController MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicationControllerScale

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicationControllerScale 
  :: (Consumes PatchNamespacedReplicationControllerScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicationControllerScale contentType V1Scale accept
patchNamespacedReplicationControllerScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicationControllerScale 
instance HasBodyParam PatchNamespacedReplicationControllerScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicationControllerScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicationControllerScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicationControllerScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicationControllerScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicationControllerScale MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicationControllerStatus

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/status@
-- 
-- partially update status of the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicationControllerStatus 
  :: (Consumes PatchNamespacedReplicationControllerStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicationControllerStatus contentType V1ReplicationController accept
patchNamespacedReplicationControllerStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicationControllerStatus 
instance HasBodyParam PatchNamespacedReplicationControllerStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicationControllerStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicationControllerStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicationControllerStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicationControllerStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicationControllerStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedResourceQuota

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}@
-- 
-- partially update the specified ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedResourceQuota 
  :: (Consumes PatchNamespacedResourceQuota contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedResourceQuota contentType V1ResourceQuota accept
patchNamespacedResourceQuota _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedResourceQuota 
instance HasBodyParam PatchNamespacedResourceQuota A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedResourceQuota MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedResourceQuota MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedResourceQuota MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedResourceQuota MimeVndKubernetesProtobuf


-- *** patchNamespacedResourceQuotaStatus

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}\/status@
-- 
-- partially update status of the specified ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedResourceQuotaStatus 
  :: (Consumes PatchNamespacedResourceQuotaStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedResourceQuotaStatus contentType V1ResourceQuota accept
patchNamespacedResourceQuotaStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedResourceQuotaStatus 
instance HasBodyParam PatchNamespacedResourceQuotaStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedResourceQuotaStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedResourceQuotaStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedResourceQuotaStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedResourceQuotaStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedResourceQuotaStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedResourceQuotaStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedResourceQuotaStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedSecret

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/secrets\/{name}@
-- 
-- partially update the specified Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedSecret 
  :: (Consumes PatchNamespacedSecret contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Secret
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedSecret contentType V1Secret accept
patchNamespacedSecret _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/secrets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedSecret 
instance HasBodyParam PatchNamespacedSecret A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedSecret MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedSecret MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedSecret MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedSecret MimeVndKubernetesProtobuf


-- *** patchNamespacedService

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/services\/{name}@
-- 
-- partially update the specified Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedService 
  :: (Consumes PatchNamespacedService contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedService contentType V1Service accept
patchNamespacedService _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedService 
instance HasBodyParam PatchNamespacedService A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedService MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedService MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedService MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedService MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedService MimeVndKubernetesProtobuf


-- *** patchNamespacedServiceAccount

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/serviceaccounts\/{name}@
-- 
-- partially update the specified ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedServiceAccount 
  :: (Consumes PatchNamespacedServiceAccount contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ServiceAccount
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedServiceAccount contentType V1ServiceAccount accept
patchNamespacedServiceAccount _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedServiceAccount 
instance HasBodyParam PatchNamespacedServiceAccount A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedServiceAccount MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedServiceAccount MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedServiceAccount MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedServiceAccount MimeVndKubernetesProtobuf


-- *** patchNamespacedServiceStatus

-- | @PATCH \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/status@
-- 
-- partially update status of the specified Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedServiceStatus 
  :: (Consumes PatchNamespacedServiceStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedServiceStatus contentType V1Service accept
patchNamespacedServiceStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedServiceStatus 
instance HasBodyParam PatchNamespacedServiceStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedServiceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedServiceStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedServiceStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedServiceStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedServiceStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedServiceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedServiceStatus MimeVndKubernetesProtobuf


-- *** patchNode

-- | @PATCH \/api\/v1\/nodes\/{name}@
-- 
-- partially update the specified Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNode 
  :: (Consumes PatchNode contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNode contentType V1Node accept
patchNode _  _ (Name name) body =
  _mkRequest "PATCH" ["/api/v1/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNode 
instance HasBodyParam PatchNode A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNode MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNode MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNode MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNode MimeJSON
-- | @application/yaml@
instance Produces PatchNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNode MimeVndKubernetesProtobuf


-- *** patchNodeStatus

-- | @PATCH \/api\/v1\/nodes\/{name}\/status@
-- 
-- partially update status of the specified Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNodeStatus 
  :: (Consumes PatchNodeStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNodeStatus contentType V1Node accept
patchNodeStatus _  _ (Name name) body =
  _mkRequest "PATCH" ["/api/v1/nodes/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNodeStatus 
instance HasBodyParam PatchNodeStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNodeStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNodeStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNodeStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNodeStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNodeStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNodeStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNodeStatus MimeVndKubernetesProtobuf


-- *** patchPersistentVolume

-- | @PATCH \/api\/v1\/persistentvolumes\/{name}@
-- 
-- partially update the specified PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchPersistentVolume 
  :: (Consumes PatchPersistentVolume contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchPersistentVolume contentType V1PersistentVolume accept
patchPersistentVolume _  _ (Name name) body =
  _mkRequest "PATCH" ["/api/v1/persistentvolumes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchPersistentVolume 
instance HasBodyParam PatchPersistentVolume A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchPersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchPersistentVolume MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchPersistentVolume MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchPersistentVolume MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchPersistentVolume MimeJSON
-- | @application/yaml@
instance Produces PatchPersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchPersistentVolume MimeVndKubernetesProtobuf


-- *** patchPersistentVolumeStatus

-- | @PATCH \/api\/v1\/persistentvolumes\/{name}\/status@
-- 
-- partially update status of the specified PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchPersistentVolumeStatus 
  :: (Consumes PatchPersistentVolumeStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchPersistentVolumeStatus contentType V1PersistentVolume accept
patchPersistentVolumeStatus _  _ (Name name) body =
  _mkRequest "PATCH" ["/api/v1/persistentvolumes/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchPersistentVolumeStatus 
instance HasBodyParam PatchPersistentVolumeStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchPersistentVolumeStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchPersistentVolumeStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchPersistentVolumeStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchPersistentVolumeStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchPersistentVolumeStatus MimeJSON
-- | @application/yaml@
instance Produces PatchPersistentVolumeStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchPersistentVolumeStatus MimeVndKubernetesProtobuf


-- *** proxyDELETENamespacedPod

-- | @DELETE \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy DELETE requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyDELETENamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyDELETENamespacedPod MimeNoContent Text accept
proxyDELETENamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyDELETENamespacedPod  

-- | @*/*@
instance Consumes ProxyDELETENamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyDELETENamespacedPod MimeAny


-- *** proxyDELETENamespacedPodWithPath

-- | @DELETE \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy DELETE requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyDELETENamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyDELETENamespacedPodWithPath MimeNoContent Text accept
proxyDELETENamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "DELETE" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyDELETENamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyDELETENamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyDELETENamespacedPodWithPath MimeAny


-- *** proxyDELETENamespacedService

-- | @DELETE \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy DELETE requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyDELETENamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyDELETENamespacedService MimeNoContent Text accept
proxyDELETENamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyDELETENamespacedService  

-- | @*/*@
instance Consumes ProxyDELETENamespacedService MimeAny

-- | @*/*@
instance Produces ProxyDELETENamespacedService MimeAny


-- *** proxyDELETENamespacedServiceWithPath

-- | @DELETE \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy DELETE requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyDELETENamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyDELETENamespacedServiceWithPath MimeNoContent Text accept
proxyDELETENamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "DELETE" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyDELETENamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyDELETENamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyDELETENamespacedServiceWithPath MimeAny


-- *** proxyDELETENode

-- | @DELETE \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy DELETE requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyDELETENode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyDELETENode MimeNoContent Text accept
proxyDELETENode  _ (Name name) =
  _mkRequest "DELETE" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyDELETENode  

-- | @*/*@
instance Consumes ProxyDELETENode MimeAny

-- | @*/*@
instance Produces ProxyDELETENode MimeAny


-- *** proxyDELETENodeWithPath

-- | @DELETE \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy DELETE requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyDELETENodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyDELETENodeWithPath MimeNoContent Text accept
proxyDELETENodeWithPath  _ (Name name) (Path path) =
  _mkRequest "DELETE" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyDELETENodeWithPath  

-- | @*/*@
instance Consumes ProxyDELETENodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyDELETENodeWithPath MimeAny


-- *** proxyGETNamespacedPod

-- | @GET \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy GET requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyGETNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyGETNamespacedPod MimeNoContent Text accept
proxyGETNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyGETNamespacedPod  

-- | @*/*@
instance Consumes ProxyGETNamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyGETNamespacedPod MimeAny


-- *** proxyGETNamespacedPodWithPath

-- | @GET \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy GET requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyGETNamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyGETNamespacedPodWithPath MimeNoContent Text accept
proxyGETNamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "GET" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyGETNamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyGETNamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyGETNamespacedPodWithPath MimeAny


-- *** proxyGETNamespacedService

-- | @GET \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy GET requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyGETNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyGETNamespacedService MimeNoContent Text accept
proxyGETNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyGETNamespacedService  

-- | @*/*@
instance Consumes ProxyGETNamespacedService MimeAny

-- | @*/*@
instance Produces ProxyGETNamespacedService MimeAny


-- *** proxyGETNamespacedServiceWithPath

-- | @GET \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy GET requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyGETNamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyGETNamespacedServiceWithPath MimeNoContent Text accept
proxyGETNamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "GET" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyGETNamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyGETNamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyGETNamespacedServiceWithPath MimeAny


-- *** proxyGETNode

-- | @GET \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy GET requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyGETNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyGETNode MimeNoContent Text accept
proxyGETNode  _ (Name name) =
  _mkRequest "GET" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyGETNode  

-- | @*/*@
instance Consumes ProxyGETNode MimeAny

-- | @*/*@
instance Produces ProxyGETNode MimeAny


-- *** proxyGETNodeWithPath

-- | @GET \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy GET requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyGETNodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyGETNodeWithPath MimeNoContent Text accept
proxyGETNodeWithPath  _ (Name name) (Path path) =
  _mkRequest "GET" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyGETNodeWithPath  

-- | @*/*@
instance Consumes ProxyGETNodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyGETNodeWithPath MimeAny


-- *** proxyHEADNamespacedPod

-- | @HEAD \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy HEAD requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyHEADNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyHEADNamespacedPod MimeNoContent Text accept
proxyHEADNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "HEAD" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyHEADNamespacedPod  

-- | @*/*@
instance Consumes ProxyHEADNamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyHEADNamespacedPod MimeAny


-- *** proxyHEADNamespacedPodWithPath

-- | @HEAD \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy HEAD requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyHEADNamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyHEADNamespacedPodWithPath MimeNoContent Text accept
proxyHEADNamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "HEAD" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyHEADNamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyHEADNamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyHEADNamespacedPodWithPath MimeAny


-- *** proxyHEADNamespacedService

-- | @HEAD \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy HEAD requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyHEADNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyHEADNamespacedService MimeNoContent Text accept
proxyHEADNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "HEAD" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyHEADNamespacedService  

-- | @*/*@
instance Consumes ProxyHEADNamespacedService MimeAny

-- | @*/*@
instance Produces ProxyHEADNamespacedService MimeAny


-- *** proxyHEADNamespacedServiceWithPath

-- | @HEAD \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy HEAD requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyHEADNamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyHEADNamespacedServiceWithPath MimeNoContent Text accept
proxyHEADNamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "HEAD" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyHEADNamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyHEADNamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyHEADNamespacedServiceWithPath MimeAny


-- *** proxyHEADNode

-- | @HEAD \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy HEAD requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyHEADNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyHEADNode MimeNoContent Text accept
proxyHEADNode  _ (Name name) =
  _mkRequest "HEAD" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyHEADNode  

-- | @*/*@
instance Consumes ProxyHEADNode MimeAny

-- | @*/*@
instance Produces ProxyHEADNode MimeAny


-- *** proxyHEADNodeWithPath

-- | @HEAD \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy HEAD requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyHEADNodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyHEADNodeWithPath MimeNoContent Text accept
proxyHEADNodeWithPath  _ (Name name) (Path path) =
  _mkRequest "HEAD" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyHEADNodeWithPath  

-- | @*/*@
instance Consumes ProxyHEADNodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyHEADNodeWithPath MimeAny


-- *** proxyOPTIONSNamespacedPod

-- | @OPTIONS \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy OPTIONS requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyOPTIONSNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyOPTIONSNamespacedPod MimeNoContent Text accept
proxyOPTIONSNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "OPTIONS" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyOPTIONSNamespacedPod  

-- | @*/*@
instance Consumes ProxyOPTIONSNamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyOPTIONSNamespacedPod MimeAny


-- *** proxyOPTIONSNamespacedPodWithPath

-- | @OPTIONS \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy OPTIONS requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyOPTIONSNamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyOPTIONSNamespacedPodWithPath MimeNoContent Text accept
proxyOPTIONSNamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "OPTIONS" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyOPTIONSNamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyOPTIONSNamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyOPTIONSNamespacedPodWithPath MimeAny


-- *** proxyOPTIONSNamespacedService

-- | @OPTIONS \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy OPTIONS requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyOPTIONSNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyOPTIONSNamespacedService MimeNoContent Text accept
proxyOPTIONSNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "OPTIONS" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyOPTIONSNamespacedService  

-- | @*/*@
instance Consumes ProxyOPTIONSNamespacedService MimeAny

-- | @*/*@
instance Produces ProxyOPTIONSNamespacedService MimeAny


-- *** proxyOPTIONSNamespacedServiceWithPath

-- | @OPTIONS \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy OPTIONS requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyOPTIONSNamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyOPTIONSNamespacedServiceWithPath MimeNoContent Text accept
proxyOPTIONSNamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "OPTIONS" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyOPTIONSNamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyOPTIONSNamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyOPTIONSNamespacedServiceWithPath MimeAny


-- *** proxyOPTIONSNode

-- | @OPTIONS \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy OPTIONS requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyOPTIONSNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyOPTIONSNode MimeNoContent Text accept
proxyOPTIONSNode  _ (Name name) =
  _mkRequest "OPTIONS" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyOPTIONSNode  

-- | @*/*@
instance Consumes ProxyOPTIONSNode MimeAny

-- | @*/*@
instance Produces ProxyOPTIONSNode MimeAny


-- *** proxyOPTIONSNodeWithPath

-- | @OPTIONS \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy OPTIONS requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyOPTIONSNodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyOPTIONSNodeWithPath MimeNoContent Text accept
proxyOPTIONSNodeWithPath  _ (Name name) (Path path) =
  _mkRequest "OPTIONS" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyOPTIONSNodeWithPath  

-- | @*/*@
instance Consumes ProxyOPTIONSNodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyOPTIONSNodeWithPath MimeAny


-- *** proxyPATCHNamespacedPod

-- | @PATCH \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy PATCH requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPATCHNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyPATCHNamespacedPod MimeNoContent Text accept
proxyPATCHNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPATCHNamespacedPod  

-- | @*/*@
instance Consumes ProxyPATCHNamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyPATCHNamespacedPod MimeAny


-- *** proxyPATCHNamespacedPodWithPath

-- | @PATCH \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy PATCH requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPATCHNamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPATCHNamespacedPodWithPath MimeNoContent Text accept
proxyPATCHNamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PATCH" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPATCHNamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyPATCHNamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyPATCHNamespacedPodWithPath MimeAny


-- *** proxyPATCHNamespacedService

-- | @PATCH \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy PATCH requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPATCHNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyPATCHNamespacedService MimeNoContent Text accept
proxyPATCHNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPATCHNamespacedService  

-- | @*/*@
instance Consumes ProxyPATCHNamespacedService MimeAny

-- | @*/*@
instance Produces ProxyPATCHNamespacedService MimeAny


-- *** proxyPATCHNamespacedServiceWithPath

-- | @PATCH \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy PATCH requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPATCHNamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPATCHNamespacedServiceWithPath MimeNoContent Text accept
proxyPATCHNamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PATCH" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPATCHNamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyPATCHNamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyPATCHNamespacedServiceWithPath MimeAny


-- *** proxyPATCHNode

-- | @PATCH \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy PATCH requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPATCHNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyPATCHNode MimeNoContent Text accept
proxyPATCHNode  _ (Name name) =
  _mkRequest "PATCH" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPATCHNode  

-- | @*/*@
instance Consumes ProxyPATCHNode MimeAny

-- | @*/*@
instance Produces ProxyPATCHNode MimeAny


-- *** proxyPATCHNodeWithPath

-- | @PATCH \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy PATCH requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPATCHNodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPATCHNodeWithPath MimeNoContent Text accept
proxyPATCHNodeWithPath  _ (Name name) (Path path) =
  _mkRequest "PATCH" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPATCHNodeWithPath  

-- | @*/*@
instance Consumes ProxyPATCHNodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyPATCHNodeWithPath MimeAny


-- *** proxyPOSTNamespacedPod

-- | @POST \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy POST requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPOSTNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyPOSTNamespacedPod MimeNoContent Text accept
proxyPOSTNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPOSTNamespacedPod  

-- | @*/*@
instance Consumes ProxyPOSTNamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyPOSTNamespacedPod MimeAny


-- *** proxyPOSTNamespacedPodWithPath

-- | @POST \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy POST requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPOSTNamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPOSTNamespacedPodWithPath MimeNoContent Text accept
proxyPOSTNamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "POST" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPOSTNamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyPOSTNamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyPOSTNamespacedPodWithPath MimeAny


-- *** proxyPOSTNamespacedService

-- | @POST \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy POST requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPOSTNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyPOSTNamespacedService MimeNoContent Text accept
proxyPOSTNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "POST" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPOSTNamespacedService  

-- | @*/*@
instance Consumes ProxyPOSTNamespacedService MimeAny

-- | @*/*@
instance Produces ProxyPOSTNamespacedService MimeAny


-- *** proxyPOSTNamespacedServiceWithPath

-- | @POST \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy POST requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPOSTNamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPOSTNamespacedServiceWithPath MimeNoContent Text accept
proxyPOSTNamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "POST" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPOSTNamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyPOSTNamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyPOSTNamespacedServiceWithPath MimeAny


-- *** proxyPOSTNode

-- | @POST \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy POST requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPOSTNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyPOSTNode MimeNoContent Text accept
proxyPOSTNode  _ (Name name) =
  _mkRequest "POST" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPOSTNode  

-- | @*/*@
instance Consumes ProxyPOSTNode MimeAny

-- | @*/*@
instance Produces ProxyPOSTNode MimeAny


-- *** proxyPOSTNodeWithPath

-- | @POST \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy POST requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPOSTNodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPOSTNodeWithPath MimeNoContent Text accept
proxyPOSTNodeWithPath  _ (Name name) (Path path) =
  _mkRequest "POST" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPOSTNodeWithPath  

-- | @*/*@
instance Consumes ProxyPOSTNodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyPOSTNodeWithPath MimeAny


-- *** proxyPUTNamespacedPod

-- | @PUT \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- proxy PUT requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPUTNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyPUTNamespacedPod MimeNoContent Text accept
proxyPUTNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPUTNamespacedPod  

-- | @*/*@
instance Consumes ProxyPUTNamespacedPod MimeAny

-- | @*/*@
instance Produces ProxyPUTNamespacedPod MimeAny


-- *** proxyPUTNamespacedPodWithPath

-- | @PUT \/api\/v1\/proxy\/namespaces\/{namespace}\/pods\/{name}\/{path}@
-- 
-- proxy PUT requests to Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPUTNamespacedPodWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPUTNamespacedPodWithPath MimeNoContent Text accept
proxyPUTNamespacedPodWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PUT" ["/api/v1/proxy/namespaces/",toPath namespace,"/pods/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPUTNamespacedPodWithPath  

-- | @*/*@
instance Consumes ProxyPUTNamespacedPodWithPath MimeAny

-- | @*/*@
instance Produces ProxyPUTNamespacedPodWithPath MimeAny


-- *** proxyPUTNamespacedService

-- | @PUT \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}@
-- 
-- proxy PUT requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPUTNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ProxyPUTNamespacedService MimeNoContent Text accept
proxyPUTNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPUTNamespacedService  

-- | @*/*@
instance Consumes ProxyPUTNamespacedService MimeAny

-- | @*/*@
instance Produces ProxyPUTNamespacedService MimeAny


-- *** proxyPUTNamespacedServiceWithPath

-- | @PUT \/api\/v1\/proxy\/namespaces\/{namespace}\/services\/{name}\/{path}@
-- 
-- proxy PUT requests to Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPUTNamespacedServiceWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPUTNamespacedServiceWithPath MimeNoContent Text accept
proxyPUTNamespacedServiceWithPath  _ (Name name) (Namespace namespace) (Path path) =
  _mkRequest "PUT" ["/api/v1/proxy/namespaces/",toPath namespace,"/services/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPUTNamespacedServiceWithPath  

-- | @*/*@
instance Consumes ProxyPUTNamespacedServiceWithPath MimeAny

-- | @*/*@
instance Produces ProxyPUTNamespacedServiceWithPath MimeAny


-- *** proxyPUTNode

-- | @PUT \/api\/v1\/proxy\/nodes\/{name}@
-- 
-- proxy PUT requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPUTNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ProxyPUTNode MimeNoContent Text accept
proxyPUTNode  _ (Name name) =
  _mkRequest "PUT" ["/api/v1/proxy/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPUTNode  

-- | @*/*@
instance Consumes ProxyPUTNode MimeAny

-- | @*/*@
instance Produces ProxyPUTNode MimeAny


-- *** proxyPUTNodeWithPath

-- | @PUT \/api\/v1\/proxy\/nodes\/{name}\/{path}@
-- 
-- proxy PUT requests to Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
proxyPUTNodeWithPath 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> Path -- ^ "path" -  path to the resource
  -> KubernetesRequest ProxyPUTNodeWithPath MimeNoContent Text accept
proxyPUTNodeWithPath  _ (Name name) (Path path) =
  _mkRequest "PUT" ["/api/v1/proxy/nodes/",toPath name,"/",toPath path]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ProxyPUTNodeWithPath  

-- | @*/*@
instance Consumes ProxyPUTNodeWithPath MimeAny

-- | @*/*@
instance Produces ProxyPUTNodeWithPath MimeAny


-- *** readComponentStatus

-- | @GET \/api\/v1\/componentstatuses\/{name}@
-- 
-- read the specified ComponentStatus
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readComponentStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ComponentStatus
  -> KubernetesRequest ReadComponentStatus MimeNoContent V1ComponentStatus accept
readComponentStatus  _ (Name name) =
  _mkRequest "GET" ["/api/v1/componentstatuses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadComponentStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadComponentStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadComponentStatus MimeAny

-- | @application/json@
instance Produces ReadComponentStatus MimeJSON
-- | @application/yaml@
instance Produces ReadComponentStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadComponentStatus MimeVndKubernetesProtobuf


-- *** readNamespace

-- | @GET \/api\/v1\/namespaces\/{name}@
-- 
-- read the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespace 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> KubernetesRequest ReadNamespace MimeNoContent V1Namespace accept
readNamespace  _ (Name name) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespace  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespace Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespace Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespace Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespace MimeAny

-- | @application/json@
instance Produces ReadNamespace MimeJSON
-- | @application/yaml@
instance Produces ReadNamespace MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespace MimeVndKubernetesProtobuf


-- *** readNamespaceStatus

-- | @GET \/api\/v1\/namespaces\/{name}\/status@
-- 
-- read status of the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespaceStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> KubernetesRequest ReadNamespaceStatus MimeNoContent V1Namespace accept
readNamespaceStatus  _ (Name name) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespaceStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespaceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespaceStatus MimeAny

-- | @application/json@
instance Produces ReadNamespaceStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespaceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespaceStatus MimeVndKubernetesProtobuf


-- *** readNamespacedConfigMap

-- | @GET \/api\/v1\/namespaces\/{namespace}\/configmaps\/{name}@
-- 
-- read the specified ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedConfigMap 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ConfigMap
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedConfigMap MimeNoContent V1ConfigMap accept
readNamespacedConfigMap  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/configmaps/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedConfigMap  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedConfigMap Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedConfigMap Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedConfigMap MimeAny

-- | @application/json@
instance Produces ReadNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedConfigMap MimeVndKubernetesProtobuf


-- *** readNamespacedEndpoints

-- | @GET \/api\/v1\/namespaces\/{namespace}\/endpoints\/{name}@
-- 
-- read the specified Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedEndpoints 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Endpoints
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedEndpoints MimeNoContent V1Endpoints accept
readNamespacedEndpoints  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/endpoints/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedEndpoints  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedEndpoints Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedEndpoints Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedEndpoints MimeAny

-- | @application/json@
instance Produces ReadNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedEndpoints MimeVndKubernetesProtobuf


-- *** readNamespacedEvent

-- | @GET \/api\/v1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- read the specified Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedEvent 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedEvent MimeNoContent V1Event accept
readNamespacedEvent  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedEvent  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedEvent Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedEvent Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedEvent MimeAny

-- | @application/json@
instance Produces ReadNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedEvent MimeVndKubernetesProtobuf


-- *** readNamespacedLimitRange

-- | @GET \/api\/v1\/namespaces\/{namespace}\/limitranges\/{name}@
-- 
-- read the specified LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedLimitRange 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the LimitRange
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedLimitRange MimeNoContent V1LimitRange accept
readNamespacedLimitRange  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/limitranges/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedLimitRange  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedLimitRange Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedLimitRange Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedLimitRange MimeAny

-- | @application/json@
instance Produces ReadNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedLimitRange MimeVndKubernetesProtobuf


-- *** readNamespacedPersistentVolumeClaim

-- | @GET \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}@
-- 
-- read the specified PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPersistentVolumeClaim 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPersistentVolumeClaim MimeNoContent V1PersistentVolumeClaim accept
readNamespacedPersistentVolumeClaim  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPersistentVolumeClaim  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedPersistentVolumeClaim Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedPersistentVolumeClaim Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPersistentVolumeClaim MimeAny

-- | @application/json@
instance Produces ReadNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf


-- *** readNamespacedPersistentVolumeClaimStatus

-- | @GET \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}\/status@
-- 
-- read status of the specified PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPersistentVolumeClaimStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPersistentVolumeClaimStatus MimeNoContent V1PersistentVolumeClaim accept
readNamespacedPersistentVolumeClaimStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPersistentVolumeClaimStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPersistentVolumeClaimStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPersistentVolumeClaimStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedPersistentVolumeClaimStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPersistentVolumeClaimStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPersistentVolumeClaimStatus MimeVndKubernetesProtobuf


-- *** readNamespacedPod

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- read the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPod 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPod MimeNoContent V1Pod accept
readNamespacedPod  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPod  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedPod Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedPod Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPod MimeAny

-- | @application/json@
instance Produces ReadNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPod MimeVndKubernetesProtobuf


-- *** readNamespacedPodLog

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/log@
-- 
-- read log of the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodLog 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodLog MimeNoContent Text accept
readNamespacedPodLog  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/log"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodLog  

-- | /Optional Param/ "container" - The container for which to stream logs. Defaults to only container if there is one container in the pod.
instance HasOptionalParam ReadNamespacedPodLog Container where
  applyOptionalParam req (Container xs) =
    req `setQuery` toQuery ("container", Just xs)

-- | /Optional Param/ "follow" - Follow the log stream of the pod. Defaults to false.
instance HasOptionalParam ReadNamespacedPodLog Follow where
  applyOptionalParam req (Follow xs) =
    req `setQuery` toQuery ("follow", Just xs)

-- | /Optional Param/ "limitBytes" - If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
instance HasOptionalParam ReadNamespacedPodLog LimitBytes where
  applyOptionalParam req (LimitBytes xs) =
    req `setQuery` toQuery ("limitBytes", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodLog Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "previous" - Return previous terminated container logs. Defaults to false.
instance HasOptionalParam ReadNamespacedPodLog Previous where
  applyOptionalParam req (Previous xs) =
    req `setQuery` toQuery ("previous", Just xs)

-- | /Optional Param/ "sinceSeconds" - A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
instance HasOptionalParam ReadNamespacedPodLog SinceSeconds where
  applyOptionalParam req (SinceSeconds xs) =
    req `setQuery` toQuery ("sinceSeconds", Just xs)

-- | /Optional Param/ "tailLines" - If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
instance HasOptionalParam ReadNamespacedPodLog TailLines where
  applyOptionalParam req (TailLines xs) =
    req `setQuery` toQuery ("tailLines", Just xs)

-- | /Optional Param/ "timestamps" - If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
instance HasOptionalParam ReadNamespacedPodLog Timestamps where
  applyOptionalParam req (Timestamps xs) =
    req `setQuery` toQuery ("timestamps", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPodLog MimeAny

-- | @text/plain@
instance Produces ReadNamespacedPodLog MimePlainText
-- | @application/json@
instance Produces ReadNamespacedPodLog MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPodLog MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodLog MimeVndKubernetesProtobuf


-- *** readNamespacedPodStatus

-- | @GET \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/status@
-- 
-- read status of the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodStatus MimeNoContent V1Pod accept
readNamespacedPodStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPodStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedPodStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPodStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodStatus MimeVndKubernetesProtobuf


-- *** readNamespacedPodTemplate

-- | @GET \/api\/v1\/namespaces\/{namespace}\/podtemplates\/{name}@
-- 
-- read the specified PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodTemplate 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodTemplate MimeNoContent V1PodTemplate accept
readNamespacedPodTemplate  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/podtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodTemplate  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedPodTemplate Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedPodTemplate Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPodTemplate MimeAny

-- | @application/json@
instance Produces ReadNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodTemplate MimeVndKubernetesProtobuf


-- *** readNamespacedReplicationController

-- | @GET \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}@
-- 
-- read the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicationController 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicationController MimeNoContent V1ReplicationController accept
readNamespacedReplicationController  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicationController  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedReplicationController Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedReplicationController Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicationController MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicationController MimeVndKubernetesProtobuf


-- *** readNamespacedReplicationControllerScale

-- | @GET \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- read scale of the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicationControllerScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicationControllerScale MimeNoContent V1Scale accept
readNamespacedReplicationControllerScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicationControllerScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicationControllerScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicationControllerScale MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicationControllerScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicationControllerScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicationControllerScale MimeVndKubernetesProtobuf


-- *** readNamespacedReplicationControllerStatus

-- | @GET \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/status@
-- 
-- read status of the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicationControllerStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicationControllerStatus MimeNoContent V1ReplicationController accept
readNamespacedReplicationControllerStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicationControllerStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicationControllerStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicationControllerStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicationControllerStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicationControllerStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicationControllerStatus MimeVndKubernetesProtobuf


-- *** readNamespacedResourceQuota

-- | @GET \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}@
-- 
-- read the specified ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedResourceQuota 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedResourceQuota MimeNoContent V1ResourceQuota accept
readNamespacedResourceQuota  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedResourceQuota  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedResourceQuota Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedResourceQuota Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedResourceQuota MimeAny

-- | @application/json@
instance Produces ReadNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedResourceQuota MimeVndKubernetesProtobuf


-- *** readNamespacedResourceQuotaStatus

-- | @GET \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}\/status@
-- 
-- read status of the specified ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedResourceQuotaStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedResourceQuotaStatus MimeNoContent V1ResourceQuota accept
readNamespacedResourceQuotaStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedResourceQuotaStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedResourceQuotaStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedResourceQuotaStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedResourceQuotaStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedResourceQuotaStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedResourceQuotaStatus MimeVndKubernetesProtobuf


-- *** readNamespacedSecret

-- | @GET \/api\/v1\/namespaces\/{namespace}\/secrets\/{name}@
-- 
-- read the specified Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedSecret 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Secret
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedSecret MimeNoContent V1Secret accept
readNamespacedSecret  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/secrets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedSecret  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedSecret Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedSecret Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedSecret MimeAny

-- | @application/json@
instance Produces ReadNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedSecret MimeVndKubernetesProtobuf


-- *** readNamespacedService

-- | @GET \/api\/v1\/namespaces\/{namespace}\/services\/{name}@
-- 
-- read the specified Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedService 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedService MimeNoContent V1Service accept
readNamespacedService  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedService  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedService Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedService Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedService MimeAny

-- | @application/json@
instance Produces ReadNamespacedService MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedService MimeVndKubernetesProtobuf


-- *** readNamespacedServiceAccount

-- | @GET \/api\/v1\/namespaces\/{namespace}\/serviceaccounts\/{name}@
-- 
-- read the specified ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedServiceAccount 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ServiceAccount
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedServiceAccount MimeNoContent V1ServiceAccount accept
readNamespacedServiceAccount  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedServiceAccount  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedServiceAccount Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedServiceAccount Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedServiceAccount MimeAny

-- | @application/json@
instance Produces ReadNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedServiceAccount MimeVndKubernetesProtobuf


-- *** readNamespacedServiceStatus

-- | @GET \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/status@
-- 
-- read status of the specified Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedServiceStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedServiceStatus MimeNoContent V1Service accept
readNamespacedServiceStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedServiceStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedServiceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedServiceStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedServiceStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedServiceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedServiceStatus MimeVndKubernetesProtobuf


-- *** readNode

-- | @GET \/api\/v1\/nodes\/{name}@
-- 
-- read the specified Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ReadNode MimeNoContent V1Node accept
readNode  _ (Name name) =
  _mkRequest "GET" ["/api/v1/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNode  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNode Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNode Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNode MimeAny

-- | @application/json@
instance Produces ReadNode MimeJSON
-- | @application/yaml@
instance Produces ReadNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNode MimeVndKubernetesProtobuf


-- *** readNodeStatus

-- | @GET \/api\/v1\/nodes\/{name}\/status@
-- 
-- read status of the specified Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNodeStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> KubernetesRequest ReadNodeStatus MimeNoContent V1Node accept
readNodeStatus  _ (Name name) =
  _mkRequest "GET" ["/api/v1/nodes/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNodeStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNodeStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNodeStatus MimeAny

-- | @application/json@
instance Produces ReadNodeStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNodeStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNodeStatus MimeVndKubernetesProtobuf


-- *** readPersistentVolume

-- | @GET \/api\/v1\/persistentvolumes\/{name}@
-- 
-- read the specified PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readPersistentVolume 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> KubernetesRequest ReadPersistentVolume MimeNoContent V1PersistentVolume accept
readPersistentVolume  _ (Name name) =
  _mkRequest "GET" ["/api/v1/persistentvolumes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadPersistentVolume  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadPersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadPersistentVolume Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadPersistentVolume Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadPersistentVolume MimeAny

-- | @application/json@
instance Produces ReadPersistentVolume MimeJSON
-- | @application/yaml@
instance Produces ReadPersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadPersistentVolume MimeVndKubernetesProtobuf


-- *** readPersistentVolumeStatus

-- | @GET \/api\/v1\/persistentvolumes\/{name}\/status@
-- 
-- read status of the specified PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readPersistentVolumeStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> KubernetesRequest ReadPersistentVolumeStatus MimeNoContent V1PersistentVolume accept
readPersistentVolumeStatus  _ (Name name) =
  _mkRequest "GET" ["/api/v1/persistentvolumes/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadPersistentVolumeStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadPersistentVolumeStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadPersistentVolumeStatus MimeAny

-- | @application/json@
instance Produces ReadPersistentVolumeStatus MimeJSON
-- | @application/yaml@
instance Produces ReadPersistentVolumeStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadPersistentVolumeStatus MimeVndKubernetesProtobuf


-- *** replaceNamespace

-- | @PUT \/api\/v1\/namespaces\/{name}@
-- 
-- replace the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespace 
  :: (Consumes ReplaceNamespace contentType, MimeRender contentType V1Namespace)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> V1Namespace -- ^ "body"
  -> KubernetesRequest ReplaceNamespace contentType V1Namespace accept
replaceNamespace _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespace 
instance HasBodyParam ReplaceNamespace V1Namespace 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespace Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespace MimeAny

-- | @application/json@
instance Produces ReplaceNamespace MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespace MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespace MimeVndKubernetesProtobuf


-- *** replaceNamespaceFinalize

-- | @PUT \/api\/v1\/namespaces\/{name}\/finalize@
-- 
-- replace finalize of the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespaceFinalize 
  :: (Consumes ReplaceNamespaceFinalize contentType, MimeRender contentType V1Namespace)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> V1Namespace -- ^ "body"
  -> KubernetesRequest ReplaceNamespaceFinalize contentType V1Namespace accept
replaceNamespaceFinalize _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath name,"/finalize"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespaceFinalize 
instance HasBodyParam ReplaceNamespaceFinalize V1Namespace 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespaceFinalize Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespaceFinalize MimeAny

-- | @application/json@
instance Produces ReplaceNamespaceFinalize MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespaceFinalize MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespaceFinalize MimeVndKubernetesProtobuf


-- *** replaceNamespaceStatus

-- | @PUT \/api\/v1\/namespaces\/{name}\/status@
-- 
-- replace status of the specified Namespace
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespaceStatus 
  :: (Consumes ReplaceNamespaceStatus contentType, MimeRender contentType V1Namespace)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Namespace
  -> V1Namespace -- ^ "body"
  -> KubernetesRequest ReplaceNamespaceStatus contentType V1Namespace accept
replaceNamespaceStatus _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespaceStatus 
instance HasBodyParam ReplaceNamespaceStatus V1Namespace 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespaceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespaceStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespaceStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespaceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespaceStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedConfigMap

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/configmaps\/{name}@
-- 
-- replace the specified ConfigMap
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedConfigMap 
  :: (Consumes ReplaceNamespacedConfigMap contentType, MimeRender contentType V1ConfigMap)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ConfigMap
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ConfigMap -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedConfigMap contentType V1ConfigMap accept
replaceNamespacedConfigMap _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/configmaps/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedConfigMap 
instance HasBodyParam ReplaceNamespacedConfigMap V1ConfigMap 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedConfigMap Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedConfigMap MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedConfigMap MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedConfigMap MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedConfigMap MimeVndKubernetesProtobuf


-- *** replaceNamespacedEndpoints

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/endpoints\/{name}@
-- 
-- replace the specified Endpoints
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedEndpoints 
  :: (Consumes ReplaceNamespacedEndpoints contentType, MimeRender contentType V1Endpoints)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Endpoints
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Endpoints -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedEndpoints contentType V1Endpoints accept
replaceNamespacedEndpoints _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/endpoints/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedEndpoints 
instance HasBodyParam ReplaceNamespacedEndpoints V1Endpoints 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedEndpoints Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedEndpoints MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedEndpoints MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedEndpoints MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedEndpoints MimeVndKubernetesProtobuf


-- *** replaceNamespacedEvent

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- replace the specified Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedEvent 
  :: (Consumes ReplaceNamespacedEvent contentType, MimeRender contentType V1Event)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Event -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedEvent contentType V1Event accept
replaceNamespacedEvent _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedEvent 
instance HasBodyParam ReplaceNamespacedEvent V1Event 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedEvent Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedEvent MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedEvent MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedEvent MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedEvent MimeVndKubernetesProtobuf


-- *** replaceNamespacedLimitRange

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/limitranges\/{name}@
-- 
-- replace the specified LimitRange
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedLimitRange 
  :: (Consumes ReplaceNamespacedLimitRange contentType, MimeRender contentType V1LimitRange)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the LimitRange
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1LimitRange -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedLimitRange contentType V1LimitRange accept
replaceNamespacedLimitRange _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/limitranges/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedLimitRange 
instance HasBodyParam ReplaceNamespacedLimitRange V1LimitRange 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedLimitRange Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedLimitRange MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedLimitRange MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedLimitRange MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedLimitRange MimeVndKubernetesProtobuf


-- *** replaceNamespacedPersistentVolumeClaim

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}@
-- 
-- replace the specified PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPersistentVolumeClaim 
  :: (Consumes ReplaceNamespacedPersistentVolumeClaim contentType, MimeRender contentType V1PersistentVolumeClaim)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1PersistentVolumeClaim -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPersistentVolumeClaim contentType V1PersistentVolumeClaim accept
replaceNamespacedPersistentVolumeClaim _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPersistentVolumeClaim 
instance HasBodyParam ReplaceNamespacedPersistentVolumeClaim V1PersistentVolumeClaim 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPersistentVolumeClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPersistentVolumeClaim MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPersistentVolumeClaim MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPersistentVolumeClaim MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPersistentVolumeClaim MimeVndKubernetesProtobuf


-- *** replaceNamespacedPersistentVolumeClaimStatus

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/persistentvolumeclaims\/{name}\/status@
-- 
-- replace status of the specified PersistentVolumeClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPersistentVolumeClaimStatus 
  :: (Consumes ReplaceNamespacedPersistentVolumeClaimStatus contentType, MimeRender contentType V1PersistentVolumeClaim)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolumeClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1PersistentVolumeClaim -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPersistentVolumeClaimStatus contentType V1PersistentVolumeClaim accept
replaceNamespacedPersistentVolumeClaimStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/persistentvolumeclaims/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPersistentVolumeClaimStatus 
instance HasBodyParam ReplaceNamespacedPersistentVolumeClaimStatus V1PersistentVolumeClaim 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPersistentVolumeClaimStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPersistentVolumeClaimStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPersistentVolumeClaimStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPersistentVolumeClaimStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPersistentVolumeClaimStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedPod

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/pods\/{name}@
-- 
-- replace the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPod 
  :: (Consumes ReplaceNamespacedPod contentType, MimeRender contentType V1Pod)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Pod -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPod contentType V1Pod accept
replaceNamespacedPod _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPod 
instance HasBodyParam ReplaceNamespacedPod V1Pod 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPod Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPod MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPod MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPod MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPod MimeVndKubernetesProtobuf


-- *** replaceNamespacedPodStatus

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/pods\/{name}\/status@
-- 
-- replace status of the specified Pod
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodStatus 
  :: (Consumes ReplaceNamespacedPodStatus contentType, MimeRender contentType V1Pod)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Pod
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Pod -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPodStatus contentType V1Pod accept
replaceNamespacedPodStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/pods/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodStatus 
instance HasBodyParam ReplaceNamespacedPodStatus V1Pod 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPodStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPodStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPodStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedPodTemplate

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/podtemplates\/{name}@
-- 
-- replace the specified PodTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodTemplate 
  :: (Consumes ReplaceNamespacedPodTemplate contentType, MimeRender contentType V1PodTemplate)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1PodTemplate -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPodTemplate contentType V1PodTemplate accept
replaceNamespacedPodTemplate _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/podtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodTemplate 
instance HasBodyParam ReplaceNamespacedPodTemplate V1PodTemplate 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPodTemplate MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPodTemplate MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPodTemplate MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodTemplate MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicationController

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}@
-- 
-- replace the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicationController 
  :: (Consumes ReplaceNamespacedReplicationController contentType, MimeRender contentType V1ReplicationController)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ReplicationController -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicationController contentType V1ReplicationController accept
replaceNamespacedReplicationController _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicationController 
instance HasBodyParam ReplaceNamespacedReplicationController V1ReplicationController 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicationController Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicationController MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicationController MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicationController MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicationController MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicationControllerScale

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- replace scale of the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicationControllerScale 
  :: (Consumes ReplaceNamespacedReplicationControllerScale contentType, MimeRender contentType V1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicationControllerScale contentType V1Scale accept
replaceNamespacedReplicationControllerScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicationControllerScale 
instance HasBodyParam ReplaceNamespacedReplicationControllerScale V1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicationControllerScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicationControllerScale MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicationControllerScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicationControllerScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicationControllerScale MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicationControllerStatus

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/status@
-- 
-- replace status of the specified ReplicationController
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicationControllerStatus 
  :: (Consumes ReplaceNamespacedReplicationControllerStatus contentType, MimeRender contentType V1ReplicationController)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicationController
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ReplicationController -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicationControllerStatus contentType V1ReplicationController accept
replaceNamespacedReplicationControllerStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicationControllerStatus 
instance HasBodyParam ReplaceNamespacedReplicationControllerStatus V1ReplicationController 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicationControllerStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicationControllerStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicationControllerStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicationControllerStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicationControllerStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedResourceQuota

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}@
-- 
-- replace the specified ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedResourceQuota 
  :: (Consumes ReplaceNamespacedResourceQuota contentType, MimeRender contentType V1ResourceQuota)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ResourceQuota -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedResourceQuota contentType V1ResourceQuota accept
replaceNamespacedResourceQuota _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedResourceQuota 
instance HasBodyParam ReplaceNamespacedResourceQuota V1ResourceQuota 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedResourceQuota Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedResourceQuota MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedResourceQuota MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedResourceQuota MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedResourceQuota MimeVndKubernetesProtobuf


-- *** replaceNamespacedResourceQuotaStatus

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/resourcequotas\/{name}\/status@
-- 
-- replace status of the specified ResourceQuota
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedResourceQuotaStatus 
  :: (Consumes ReplaceNamespacedResourceQuotaStatus contentType, MimeRender contentType V1ResourceQuota)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceQuota
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ResourceQuota -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedResourceQuotaStatus contentType V1ResourceQuota accept
replaceNamespacedResourceQuotaStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/resourcequotas/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedResourceQuotaStatus 
instance HasBodyParam ReplaceNamespacedResourceQuotaStatus V1ResourceQuota 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedResourceQuotaStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedResourceQuotaStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedResourceQuotaStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedResourceQuotaStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedResourceQuotaStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedSecret

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/secrets\/{name}@
-- 
-- replace the specified Secret
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedSecret 
  :: (Consumes ReplaceNamespacedSecret contentType, MimeRender contentType V1Secret)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Secret
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Secret -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedSecret contentType V1Secret accept
replaceNamespacedSecret _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/secrets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedSecret 
instance HasBodyParam ReplaceNamespacedSecret V1Secret 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedSecret Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedSecret MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedSecret MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedSecret MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedSecret MimeVndKubernetesProtobuf


-- *** replaceNamespacedService

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/services\/{name}@
-- 
-- replace the specified Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedService 
  :: (Consumes ReplaceNamespacedService contentType, MimeRender contentType V1Service)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Service -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedService contentType V1Service accept
replaceNamespacedService _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedService 
instance HasBodyParam ReplaceNamespacedService V1Service 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedService Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedService MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedService MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedService MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedService MimeVndKubernetesProtobuf


-- *** replaceNamespacedServiceAccount

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/serviceaccounts\/{name}@
-- 
-- replace the specified ServiceAccount
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedServiceAccount 
  :: (Consumes ReplaceNamespacedServiceAccount contentType, MimeRender contentType V1ServiceAccount)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ServiceAccount
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1ServiceAccount -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedServiceAccount contentType V1ServiceAccount accept
replaceNamespacedServiceAccount _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/serviceaccounts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedServiceAccount 
instance HasBodyParam ReplaceNamespacedServiceAccount V1ServiceAccount 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedServiceAccount Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedServiceAccount MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedServiceAccount MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedServiceAccount MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedServiceAccount MimeVndKubernetesProtobuf


-- *** replaceNamespacedServiceStatus

-- | @PUT \/api\/v1\/namespaces\/{namespace}\/services\/{name}\/status@
-- 
-- replace status of the specified Service
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedServiceStatus 
  :: (Consumes ReplaceNamespacedServiceStatus contentType, MimeRender contentType V1Service)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Service
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Service -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedServiceStatus contentType V1Service accept
replaceNamespacedServiceStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/api/v1/namespaces/",toPath namespace,"/services/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedServiceStatus 
instance HasBodyParam ReplaceNamespacedServiceStatus V1Service 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedServiceStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedServiceStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedServiceStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedServiceStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedServiceStatus MimeVndKubernetesProtobuf


-- *** replaceNode

-- | @PUT \/api\/v1\/nodes\/{name}@
-- 
-- replace the specified Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNode 
  :: (Consumes ReplaceNode contentType, MimeRender contentType V1Node)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> V1Node -- ^ "body"
  -> KubernetesRequest ReplaceNode contentType V1Node accept
replaceNode _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/nodes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNode 
instance HasBodyParam ReplaceNode V1Node 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNode Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNode MimeAny

-- | @application/json@
instance Produces ReplaceNode MimeJSON
-- | @application/yaml@
instance Produces ReplaceNode MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNode MimeVndKubernetesProtobuf


-- *** replaceNodeStatus

-- | @PUT \/api\/v1\/nodes\/{name}\/status@
-- 
-- replace status of the specified Node
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNodeStatus 
  :: (Consumes ReplaceNodeStatus contentType, MimeRender contentType V1Node)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Node
  -> V1Node -- ^ "body"
  -> KubernetesRequest ReplaceNodeStatus contentType V1Node accept
replaceNodeStatus _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/nodes/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNodeStatus 
instance HasBodyParam ReplaceNodeStatus V1Node 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNodeStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNodeStatus MimeAny

-- | @application/json@
instance Produces ReplaceNodeStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNodeStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNodeStatus MimeVndKubernetesProtobuf


-- *** replacePersistentVolume

-- | @PUT \/api\/v1\/persistentvolumes\/{name}@
-- 
-- replace the specified PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replacePersistentVolume 
  :: (Consumes ReplacePersistentVolume contentType, MimeRender contentType V1PersistentVolume)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> V1PersistentVolume -- ^ "body"
  -> KubernetesRequest ReplacePersistentVolume contentType V1PersistentVolume accept
replacePersistentVolume _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/persistentvolumes/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplacePersistentVolume 
instance HasBodyParam ReplacePersistentVolume V1PersistentVolume 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplacePersistentVolume Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplacePersistentVolume MimeAny

-- | @application/json@
instance Produces ReplacePersistentVolume MimeJSON
-- | @application/yaml@
instance Produces ReplacePersistentVolume MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplacePersistentVolume MimeVndKubernetesProtobuf


-- *** replacePersistentVolumeStatus

-- | @PUT \/api\/v1\/persistentvolumes\/{name}\/status@
-- 
-- replace status of the specified PersistentVolume
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replacePersistentVolumeStatus 
  :: (Consumes ReplacePersistentVolumeStatus contentType, MimeRender contentType V1PersistentVolume)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PersistentVolume
  -> V1PersistentVolume -- ^ "body"
  -> KubernetesRequest ReplacePersistentVolumeStatus contentType V1PersistentVolume accept
replacePersistentVolumeStatus _  _ (Name name) body =
  _mkRequest "PUT" ["/api/v1/persistentvolumes/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplacePersistentVolumeStatus 
instance HasBodyParam ReplacePersistentVolumeStatus V1PersistentVolume 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplacePersistentVolumeStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplacePersistentVolumeStatus MimeAny

-- | @application/json@
instance Produces ReplacePersistentVolumeStatus MimeJSON
-- | @application/yaml@
instance Produces ReplacePersistentVolumeStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplacePersistentVolumeStatus MimeVndKubernetesProtobuf


-- ** CustomObjects

-- *** createClusterCustomObject

-- | @POST \/apis\/{group}\/{version}\/{plural}@
-- 
-- Creates a cluster scoped Custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterCustomObject 
  :: (Consumes CreateClusterCustomObject contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  The custom resource's group name
  -> Version -- ^ "version" -  The custom resource's version
  -> Plural -- ^ "plural" -  The custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> A.Value -- ^ "body" -  The JSON schema of the Resource to create.
  -> KubernetesRequest CreateClusterCustomObject contentType A.Value accept
createClusterCustomObject _  _ (Group group) (Version version) (Plural plural) body =
  _mkRequest "POST" ["/apis/",toPath group,"/",toPath version,"/",toPath plural]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterCustomObject 

-- | /Body Param/ "body" - The JSON schema of the Resource to create.
instance HasBodyParam CreateClusterCustomObject A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterCustomObject Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces CreateClusterCustomObject MimeJSON


-- *** createNamespacedCustomObject

-- | @POST \/apis\/{group}\/{version}\/namespaces\/{namespace}\/{plural}@
-- 
-- Creates a namespace scoped Custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedCustomObject 
  :: (Consumes CreateNamespacedCustomObject contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  The custom resource's group name
  -> Version -- ^ "version" -  The custom resource's version
  -> Namespace -- ^ "namespace" -  The custom resource's namespace
  -> Plural -- ^ "plural" -  The custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> A.Value -- ^ "body" -  The JSON schema of the Resource to create.
  -> KubernetesRequest CreateNamespacedCustomObject contentType A.Value accept
createNamespacedCustomObject _  _ (Group group) (Version version) (Namespace namespace) (Plural plural) body =
  _mkRequest "POST" ["/apis/",toPath group,"/",toPath version,"/namespaces/",toPath namespace,"/",toPath plural]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedCustomObject 

-- | /Body Param/ "body" - The JSON schema of the Resource to create.
instance HasBodyParam CreateNamespacedCustomObject A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedCustomObject Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces CreateNamespacedCustomObject MimeJSON


-- *** deleteClusterCustomObject

-- | @DELETE \/apis\/{group}\/{version}\/{plural}\/{name}@
-- 
-- Deletes the specified cluster scoped custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterCustomObject 
  :: (Consumes DeleteClusterCustomObject contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  the custom resource's group
  -> Version -- ^ "version" -  the custom resource's version
  -> Plural -- ^ "plural" -  the custom object's plural name. For TPRs this would be lowercase plural kind.
  -> Name -- ^ "name" -  the custom object's name
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterCustomObject contentType A.Value accept
deleteClusterCustomObject _  _ (Group group) (Version version) (Plural plural) (Name name) body =
  _mkRequest "DELETE" ["/apis/",toPath group,"/",toPath version,"/",toPath plural,"/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterCustomObject 
instance HasBodyParam DeleteClusterCustomObject V1DeleteOptions 

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterCustomObject GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterCustomObject OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
instance HasOptionalParam DeleteClusterCustomObject PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterCustomObject MimeAny

-- | @application/json@
instance Produces DeleteClusterCustomObject MimeJSON


-- *** deleteNamespacedCustomObject

-- | @DELETE \/apis\/{group}\/{version}\/namespaces\/{namespace}\/{plural}\/{name}@
-- 
-- Deletes the specified namespace scoped custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedCustomObject 
  :: (Consumes DeleteNamespacedCustomObject contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  the custom resource's group
  -> Version -- ^ "version" -  the custom resource's version
  -> Namespace -- ^ "namespace" -  The custom resource's namespace
  -> Plural -- ^ "plural" -  the custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> Name -- ^ "name" -  the custom object's name
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedCustomObject contentType A.Value accept
deleteNamespacedCustomObject _  _ (Group group) (Version version) (Namespace namespace) (Plural plural) (Name name) body =
  _mkRequest "DELETE" ["/apis/",toPath group,"/",toPath version,"/namespaces/",toPath namespace,"/",toPath plural,"/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedCustomObject 
instance HasBodyParam DeleteNamespacedCustomObject V1DeleteOptions 

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedCustomObject GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedCustomObject OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
instance HasOptionalParam DeleteNamespacedCustomObject PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedCustomObject MimeAny

-- | @application/json@
instance Produces DeleteNamespacedCustomObject MimeJSON


-- *** getClusterCustomObject

-- | @GET \/apis\/{group}\/{version}\/{plural}\/{name}@
-- 
-- Returns a cluster scoped custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getClusterCustomObject 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  the custom resource's group
  -> Version -- ^ "version" -  the custom resource's version
  -> Plural -- ^ "plural" -  the custom object's plural name. For TPRs this would be lowercase plural kind.
  -> Name -- ^ "name" -  the custom object's name
  -> KubernetesRequest GetClusterCustomObject MimeNoContent A.Value accept
getClusterCustomObject  _ (Group group) (Version version) (Plural plural) (Name name) =
  _mkRequest "GET" ["/apis/",toPath group,"/",toPath version,"/",toPath plural,"/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetClusterCustomObject  

-- | @*/*@
instance Consumes GetClusterCustomObject MimeAny

-- | @application/json@
instance Produces GetClusterCustomObject MimeJSON


-- *** getNamespacedCustomObject

-- | @GET \/apis\/{group}\/{version}\/namespaces\/{namespace}\/{plural}\/{name}@
-- 
-- Returns a namespace scoped custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getNamespacedCustomObject 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  the custom resource's group
  -> Version -- ^ "version" -  the custom resource's version
  -> Namespace -- ^ "namespace" -  The custom resource's namespace
  -> Plural -- ^ "plural" -  the custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> Name -- ^ "name" -  the custom object's name
  -> KubernetesRequest GetNamespacedCustomObject MimeNoContent A.Value accept
getNamespacedCustomObject  _ (Group group) (Version version) (Namespace namespace) (Plural plural) (Name name) =
  _mkRequest "GET" ["/apis/",toPath group,"/",toPath version,"/namespaces/",toPath namespace,"/",toPath plural,"/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetNamespacedCustomObject  

-- | @*/*@
instance Consumes GetNamespacedCustomObject MimeAny

-- | @application/json@
instance Produces GetNamespacedCustomObject MimeJSON


-- *** listClusterCustomObject

-- | @GET \/apis\/{group}\/{version}\/{plural}@
-- 
-- list or watch cluster scoped custom objects
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterCustomObject 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  The custom resource's group name
  -> Version -- ^ "version" -  The custom resource's version
  -> Plural -- ^ "plural" -  The custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> KubernetesRequest ListClusterCustomObject MimeNoContent A.Value accept
listClusterCustomObject  _ (Group group) (Version version) (Plural plural) =
  _mkRequest "GET" ["/apis/",toPath group,"/",toPath version,"/",toPath plural]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterCustomObject  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterCustomObject Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterCustomObject LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterCustomObject ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
instance HasOptionalParam ListClusterCustomObject Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterCustomObject MimeAny

-- | @application/json@
instance Produces ListClusterCustomObject MimeJSON
-- | @application/json;stream=watch@
instance Produces ListClusterCustomObject MimeJsonstreamwatch


-- *** listNamespacedCustomObject

-- | @GET \/apis\/{group}\/{version}\/namespaces\/{namespace}\/{plural}@
-- 
-- list or watch namespace scoped custom objects
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedCustomObject 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  The custom resource's group name
  -> Version -- ^ "version" -  The custom resource's version
  -> Namespace -- ^ "namespace" -  The custom resource's namespace
  -> Plural -- ^ "plural" -  The custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> KubernetesRequest ListNamespacedCustomObject MimeNoContent A.Value accept
listNamespacedCustomObject  _ (Group group) (Version version) (Namespace namespace) (Plural plural) =
  _mkRequest "GET" ["/apis/",toPath group,"/",toPath version,"/namespaces/",toPath namespace,"/",toPath plural]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedCustomObject  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedCustomObject Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedCustomObject LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedCustomObject ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
instance HasOptionalParam ListNamespacedCustomObject Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedCustomObject MimeAny

-- | @application/json@
instance Produces ListNamespacedCustomObject MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedCustomObject MimeJsonstreamwatch


-- *** replaceClusterCustomObject

-- | @PUT \/apis\/{group}\/{version}\/{plural}\/{name}@
-- 
-- replace the specified cluster scoped custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterCustomObject 
  :: (Consumes ReplaceClusterCustomObject contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  the custom resource's group
  -> Version -- ^ "version" -  the custom resource's version
  -> Plural -- ^ "plural" -  the custom object's plural name. For TPRs this would be lowercase plural kind.
  -> Name -- ^ "name" -  the custom object's name
  -> A.Value -- ^ "body" -  The JSON schema of the Resource to replace.
  -> KubernetesRequest ReplaceClusterCustomObject contentType A.Value accept
replaceClusterCustomObject _  _ (Group group) (Version version) (Plural plural) (Name name) body =
  _mkRequest "PUT" ["/apis/",toPath group,"/",toPath version,"/",toPath plural,"/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterCustomObject 

-- | /Body Param/ "body" - The JSON schema of the Resource to replace.
instance HasBodyParam ReplaceClusterCustomObject A.Value 

-- | @*/*@
instance Consumes ReplaceClusterCustomObject MimeAny

-- | @application/json@
instance Produces ReplaceClusterCustomObject MimeJSON


-- *** replaceNamespacedCustomObject

-- | @PUT \/apis\/{group}\/{version}\/namespaces\/{namespace}\/{plural}\/{name}@
-- 
-- replace the specified namespace scoped custom object
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedCustomObject 
  :: (Consumes ReplaceNamespacedCustomObject contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Group -- ^ "group" -  the custom resource's group
  -> Version -- ^ "version" -  the custom resource's version
  -> Namespace -- ^ "namespace" -  The custom resource's namespace
  -> Plural -- ^ "plural" -  the custom resource's plural name. For TPRs this would be lowercase plural kind.
  -> Name -- ^ "name" -  the custom object's name
  -> A.Value -- ^ "body" -  The JSON schema of the Resource to replace.
  -> KubernetesRequest ReplaceNamespacedCustomObject contentType A.Value accept
replaceNamespacedCustomObject _  _ (Group group) (Version version) (Namespace namespace) (Plural plural) (Name name) body =
  _mkRequest "PUT" ["/apis/",toPath group,"/",toPath version,"/namespaces/",toPath namespace,"/",toPath plural,"/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedCustomObject 

-- | /Body Param/ "body" - The JSON schema of the Resource to replace.
instance HasBodyParam ReplaceNamespacedCustomObject A.Value 

-- | @*/*@
instance Consumes ReplaceNamespacedCustomObject MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedCustomObject MimeJSON


-- ** Events

-- *** getAPIGroup10

-- | @GET \/apis\/events.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup10 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup10 MimeNoContent V1APIGroup accept
getAPIGroup10  _ =
  _mkRequest "GET" ["/apis/events.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup10  

-- | @application/json@
instance Consumes GetAPIGroup10 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup10 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup10 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup10 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup10 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup10 MimeVndKubernetesProtobuf


-- ** EventsV1beta1

-- *** createNamespacedEvent2

-- | @POST \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events@
-- 
-- create an Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedEvent2 
  :: (Consumes CreateNamespacedEvent2 contentType, MimeRender contentType V1beta1Event)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Event -- ^ "body"
  -> KubernetesRequest CreateNamespacedEvent2 contentType V1beta1Event accept
createNamespacedEvent2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedEvent2 
instance HasBodyParam CreateNamespacedEvent2 V1beta1Event 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedEvent2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedEvent2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedEvent2

-- | @DELETE \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events@
-- 
-- delete collection of Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedEvent2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedEvent2 MimeNoContent V1Status accept
deleteCollectionNamespacedEvent2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedEvent2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedEvent2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedEvent2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedEvent2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedEvent2

-- | @DELETE \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- delete an Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedEvent2 
  :: (Consumes DeleteNamespacedEvent2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedEvent2 contentType V1Status accept
deleteNamespacedEvent2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedEvent2 
instance HasBodyParam DeleteNamespacedEvent2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedEvent2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedEvent2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedEvent2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedEvent2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedEvent2 MimeVndKubernetesProtobuf


-- *** getAPIResources19

-- | @GET \/apis\/events.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources19 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources19 MimeNoContent V1APIResourceList accept
getAPIResources19  _ =
  _mkRequest "GET" ["/apis/events.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources19  

-- | @application/json@
instance Consumes GetAPIResources19 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources19 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources19 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources19 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources19 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources19 MimeVndKubernetesProtobuf


-- *** listEventForAllNamespaces2

-- | @GET \/apis\/events.k8s.io\/v1beta1\/events@
-- 
-- list or watch objects of kind Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listEventForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListEventForAllNamespaces2 MimeNoContent V1beta1EventList accept
listEventForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/events.k8s.io/v1beta1/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListEventForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListEventForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListEventForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListEventForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListEventForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListEventForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListEventForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListEventForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListEventForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListEventForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListEventForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListEventForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListEventForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListEventForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListEventForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListEventForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedEvent2

-- | @GET \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events@
-- 
-- list or watch objects of kind Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedEvent2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedEvent2 MimeNoContent V1beta1EventList accept
listNamespacedEvent2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedEvent2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedEvent2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedEvent2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedEvent2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedEvent2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedEvent2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedEvent2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedEvent2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedEvent2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedEvent2 MimeAny

-- | @application/json@
instance Produces ListNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedEvent2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedEvent2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedEvent2 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedEvent2

-- | @PATCH \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- partially update the specified Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedEvent2 
  :: (Consumes PatchNamespacedEvent2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedEvent2 contentType V1beta1Event accept
patchNamespacedEvent2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedEvent2 
instance HasBodyParam PatchNamespacedEvent2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedEvent2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedEvent2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedEvent2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedEvent2 MimeVndKubernetesProtobuf


-- *** readNamespacedEvent2

-- | @GET \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- read the specified Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedEvent2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedEvent2 MimeNoContent V1beta1Event accept
readNamespacedEvent2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedEvent2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedEvent2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedEvent2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedEvent2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedEvent2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedEvent2

-- | @PUT \/apis\/events.k8s.io\/v1beta1\/namespaces\/{namespace}\/events\/{name}@
-- 
-- replace the specified Event
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedEvent2 
  :: (Consumes ReplaceNamespacedEvent2 contentType, MimeRender contentType V1beta1Event)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Event
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Event -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedEvent2 contentType V1beta1Event accept
replaceNamespacedEvent2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/events.k8s.io/v1beta1/namespaces/",toPath namespace,"/events/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedEvent2 
instance HasBodyParam ReplaceNamespacedEvent2 V1beta1Event 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedEvent2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedEvent2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedEvent2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedEvent2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedEvent2 MimeVndKubernetesProtobuf


-- ** Extensions

-- *** getAPIGroup11

-- | @GET \/apis\/extensions\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup11 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup11 MimeNoContent V1APIGroup accept
getAPIGroup11  _ =
  _mkRequest "GET" ["/apis/extensions/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup11  

-- | @application/json@
instance Consumes GetAPIGroup11 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup11 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup11 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup11 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup11 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup11 MimeVndKubernetesProtobuf


-- ** ExtensionsV1beta1

-- *** createNamespacedDaemonSet3

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets@
-- 
-- create a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDaemonSet3 
  :: (Consumes CreateNamespacedDaemonSet3 contentType, MimeRender contentType V1beta1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1DaemonSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedDaemonSet3 contentType V1beta1DaemonSet accept
createNamespacedDaemonSet3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDaemonSet3 
instance HasBodyParam CreateNamespacedDaemonSet3 V1beta1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDaemonSet3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDaemonSet3 MimeVndKubernetesProtobuf


-- *** createNamespacedDeployment4

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- create a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeployment4 
  :: (Consumes CreateNamespacedDeployment4 contentType, MimeRender contentType ExtensionsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1Deployment -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeployment4 contentType ExtensionsV1beta1Deployment accept
createNamespacedDeployment4 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeployment4 
instance HasBodyParam CreateNamespacedDeployment4 ExtensionsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDeployment4 MimeAny

-- | @application/json@
instance Produces CreateNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeployment4 MimeVndKubernetesProtobuf


-- *** createNamespacedDeploymentRollback2

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/rollback@
-- 
-- create rollback of a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedDeploymentRollback2 
  :: (Consumes CreateNamespacedDeploymentRollback2 contentType, MimeRender contentType ExtensionsV1beta1DeploymentRollback)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DeploymentRollback
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1DeploymentRollback -- ^ "body"
  -> KubernetesRequest CreateNamespacedDeploymentRollback2 contentType ExtensionsV1beta1DeploymentRollback accept
createNamespacedDeploymentRollback2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/rollback"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedDeploymentRollback2 
instance HasBodyParam CreateNamespacedDeploymentRollback2 ExtensionsV1beta1DeploymentRollback 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedDeploymentRollback2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedDeploymentRollback2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedDeploymentRollback2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedDeploymentRollback2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedDeploymentRollback2 MimeVndKubernetesProtobuf


-- *** createNamespacedIngress

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses@
-- 
-- create an Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedIngress 
  :: (Consumes CreateNamespacedIngress contentType, MimeRender contentType V1beta1Ingress)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Ingress -- ^ "body"
  -> KubernetesRequest CreateNamespacedIngress contentType V1beta1Ingress accept
createNamespacedIngress _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedIngress 
instance HasBodyParam CreateNamespacedIngress V1beta1Ingress 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedIngress MimeAny

-- | @application/json@
instance Produces CreateNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedIngress MimeVndKubernetesProtobuf


-- *** createNamespacedNetworkPolicy

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- create a NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedNetworkPolicy 
  :: (Consumes CreateNamespacedNetworkPolicy contentType, MimeRender contentType V1beta1NetworkPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1NetworkPolicy -- ^ "body"
  -> KubernetesRequest CreateNamespacedNetworkPolicy contentType V1beta1NetworkPolicy accept
createNamespacedNetworkPolicy _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedNetworkPolicy 
instance HasBodyParam CreateNamespacedNetworkPolicy V1beta1NetworkPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedNetworkPolicy MimeAny

-- | @application/json@
instance Produces CreateNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedNetworkPolicy MimeVndKubernetesProtobuf


-- *** createNamespacedReplicaSet3

-- | @POST \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets@
-- 
-- create a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedReplicaSet3 
  :: (Consumes CreateNamespacedReplicaSet3 contentType, MimeRender contentType V1beta1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1ReplicaSet -- ^ "body"
  -> KubernetesRequest CreateNamespacedReplicaSet3 contentType V1beta1ReplicaSet accept
createNamespacedReplicaSet3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedReplicaSet3 
instance HasBodyParam CreateNamespacedReplicaSet3 V1beta1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedReplicaSet3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedReplicaSet3 MimeVndKubernetesProtobuf


-- *** createPodSecurityPolicy

-- | @POST \/apis\/extensions\/v1beta1\/podsecuritypolicies@
-- 
-- create a PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createPodSecurityPolicy 
  :: (Consumes CreatePodSecurityPolicy contentType, MimeRender contentType V1beta1PodSecurityPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1PodSecurityPolicy -- ^ "body"
  -> KubernetesRequest CreatePodSecurityPolicy contentType V1beta1PodSecurityPolicy accept
createPodSecurityPolicy _  _ body =
  _mkRequest "POST" ["/apis/extensions/v1beta1/podsecuritypolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreatePodSecurityPolicy 
instance HasBodyParam CreatePodSecurityPolicy V1beta1PodSecurityPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreatePodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreatePodSecurityPolicy MimeAny

-- | @application/json@
instance Produces CreatePodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces CreatePodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreatePodSecurityPolicy MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDaemonSet3

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets@
-- 
-- delete collection of DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDaemonSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDaemonSet3 MimeNoContent V1Status accept
deleteCollectionNamespacedDaemonSet3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDaemonSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDaemonSet3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDaemonSet3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDaemonSet3 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedDeployment4

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- delete collection of Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedDeployment4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedDeployment4 MimeNoContent V1Status accept
deleteCollectionNamespacedDeployment4  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedDeployment4  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedDeployment4 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedDeployment4 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedDeployment4 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedIngress

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses@
-- 
-- delete collection of Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedIngress 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedIngress MimeNoContent V1Status accept
deleteCollectionNamespacedIngress  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedIngress  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedIngress Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedIngress FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedIngress IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedIngress LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedIngress Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedIngress ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedIngress TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedIngress Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedIngress MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedIngress MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedNetworkPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- delete collection of NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedNetworkPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedNetworkPolicy MimeNoContent V1Status accept
deleteCollectionNamespacedNetworkPolicy  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedNetworkPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedNetworkPolicy MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedNetworkPolicy MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedReplicaSet3

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets@
-- 
-- delete collection of ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedReplicaSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedReplicaSet3 MimeNoContent V1Status accept
deleteCollectionNamespacedReplicaSet3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedReplicaSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedReplicaSet3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedReplicaSet3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedReplicaSet3 MimeVndKubernetesProtobuf


-- *** deleteCollectionPodSecurityPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/podsecuritypolicies@
-- 
-- delete collection of PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionPodSecurityPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionPodSecurityPolicy MimeNoContent V1Status accept
deleteCollectionPodSecurityPolicy  _ =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/podsecuritypolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionPodSecurityPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionPodSecurityPolicy Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionPodSecurityPolicy MimeAny

-- | @application/json@
instance Produces DeleteCollectionPodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionPodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionPodSecurityPolicy MimeVndKubernetesProtobuf


-- *** deleteNamespacedDaemonSet3

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- delete a DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDaemonSet3 
  :: (Consumes DeleteNamespacedDaemonSet3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDaemonSet3 contentType V1Status accept
deleteNamespacedDaemonSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDaemonSet3 
instance HasBodyParam DeleteNamespacedDaemonSet3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDaemonSet3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDaemonSet3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDaemonSet3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDaemonSet3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDaemonSet3 MimeVndKubernetesProtobuf


-- *** deleteNamespacedDeployment4

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- delete a Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedDeployment4 
  :: (Consumes DeleteNamespacedDeployment4 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedDeployment4 contentType V1Status accept
deleteNamespacedDeployment4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedDeployment4 
instance HasBodyParam DeleteNamespacedDeployment4 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedDeployment4 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedDeployment4 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedDeployment4 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedDeployment4 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedDeployment4 MimeVndKubernetesProtobuf


-- *** deleteNamespacedIngress

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- delete an Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedIngress 
  :: (Consumes DeleteNamespacedIngress contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedIngress contentType V1Status accept
deleteNamespacedIngress _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedIngress 
instance HasBodyParam DeleteNamespacedIngress V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedIngress GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedIngress OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedIngress PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedIngress MimeAny

-- | @application/json@
instance Produces DeleteNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedIngress MimeVndKubernetesProtobuf


-- *** deleteNamespacedNetworkPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- delete a NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedNetworkPolicy 
  :: (Consumes DeleteNamespacedNetworkPolicy contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedNetworkPolicy contentType V1Status accept
deleteNamespacedNetworkPolicy _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedNetworkPolicy 
instance HasBodyParam DeleteNamespacedNetworkPolicy V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedNetworkPolicy GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedNetworkPolicy OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedNetworkPolicy PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedNetworkPolicy MimeAny

-- | @application/json@
instance Produces DeleteNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedNetworkPolicy MimeVndKubernetesProtobuf


-- *** deleteNamespacedReplicaSet3

-- | @DELETE \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- delete a ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedReplicaSet3 
  :: (Consumes DeleteNamespacedReplicaSet3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedReplicaSet3 contentType V1Status accept
deleteNamespacedReplicaSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedReplicaSet3 
instance HasBodyParam DeleteNamespacedReplicaSet3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedReplicaSet3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedReplicaSet3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedReplicaSet3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedReplicaSet3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedReplicaSet3 MimeVndKubernetesProtobuf


-- *** deletePodSecurityPolicy

-- | @DELETE \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- delete a PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deletePodSecurityPolicy 
  :: (Consumes DeletePodSecurityPolicy contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeletePodSecurityPolicy contentType V1Status accept
deletePodSecurityPolicy _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeletePodSecurityPolicy 
instance HasBodyParam DeletePodSecurityPolicy V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeletePodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeletePodSecurityPolicy GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeletePodSecurityPolicy OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeletePodSecurityPolicy PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeletePodSecurityPolicy MimeAny

-- | @application/json@
instance Produces DeletePodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces DeletePodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeletePodSecurityPolicy MimeVndKubernetesProtobuf


-- *** getAPIResources20

-- | @GET \/apis\/extensions\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources20 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources20 MimeNoContent V1APIResourceList accept
getAPIResources20  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources20  

-- | @application/json@
instance Consumes GetAPIResources20 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources20 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources20 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources20 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources20 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources20 MimeVndKubernetesProtobuf


-- *** listDaemonSetForAllNamespaces3

-- | @GET \/apis\/extensions\/v1beta1\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDaemonSetForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDaemonSetForAllNamespaces3 MimeNoContent V1beta1DaemonSetList accept
listDaemonSetForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDaemonSetForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDaemonSetForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDaemonSetForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListDaemonSetForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListDaemonSetForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDaemonSetForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDaemonSetForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDaemonSetForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** listDeploymentForAllNamespaces4

-- | @GET \/apis\/extensions\/v1beta1\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listDeploymentForAllNamespaces4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListDeploymentForAllNamespaces4 MimeNoContent ExtensionsV1beta1DeploymentList accept
listDeploymentForAllNamespaces4  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListDeploymentForAllNamespaces4  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListDeploymentForAllNamespaces4 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces4 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListDeploymentForAllNamespaces4 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListDeploymentForAllNamespaces4 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListDeploymentForAllNamespaces4 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListDeploymentForAllNamespaces4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListDeploymentForAllNamespaces4 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListDeploymentForAllNamespaces4 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListDeploymentForAllNamespaces4 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListDeploymentForAllNamespaces4 MimeAny

-- | @application/json@
instance Produces ListDeploymentForAllNamespaces4 MimeJSON
-- | @application/yaml@
instance Produces ListDeploymentForAllNamespaces4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListDeploymentForAllNamespaces4 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListDeploymentForAllNamespaces4 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListDeploymentForAllNamespaces4 MimeVndKubernetesProtobufstreamwatch


-- *** listIngressForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/ingresses@
-- 
-- list or watch objects of kind Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listIngressForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListIngressForAllNamespaces MimeNoContent V1beta1IngressList accept
listIngressForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListIngressForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListIngressForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListIngressForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListIngressForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListIngressForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListIngressForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListIngressForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListIngressForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListIngressForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListIngressForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListIngressForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListIngressForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListIngressForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListIngressForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListIngressForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListIngressForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDaemonSet3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets@
-- 
-- list or watch objects of kind DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDaemonSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDaemonSet3 MimeNoContent V1beta1DaemonSetList accept
listNamespacedDaemonSet3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDaemonSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDaemonSet3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDaemonSet3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDaemonSet3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDaemonSet3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDaemonSet3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDaemonSet3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDaemonSet3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDaemonSet3 MimeAny

-- | @application/json@
instance Produces ListNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDaemonSet3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDaemonSet3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDaemonSet3 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedDeployment4

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments@
-- 
-- list or watch objects of kind Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedDeployment4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedDeployment4 MimeNoContent ExtensionsV1beta1DeploymentList accept
listNamespacedDeployment4  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedDeployment4  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedDeployment4 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment4 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedDeployment4 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedDeployment4 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedDeployment4 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedDeployment4 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedDeployment4 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedDeployment4 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedDeployment4 MimeAny

-- | @application/json@
instance Produces ListNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedDeployment4 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedDeployment4 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedDeployment4 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedIngress

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses@
-- 
-- list or watch objects of kind Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedIngress 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedIngress MimeNoContent V1beta1IngressList accept
listNamespacedIngress  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedIngress  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedIngress Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedIngress FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedIngress IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedIngress LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedIngress Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedIngress ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedIngress TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedIngress Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedIngress MimeAny

-- | @application/json@
instance Produces ListNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedIngress MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedIngress MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedIngress MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedNetworkPolicy

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- list or watch objects of kind NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedNetworkPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedNetworkPolicy MimeNoContent V1beta1NetworkPolicyList accept
listNamespacedNetworkPolicy  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedNetworkPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedNetworkPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedNetworkPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedNetworkPolicy IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedNetworkPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedNetworkPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedNetworkPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedNetworkPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedNetworkPolicy Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedNetworkPolicy MimeAny

-- | @application/json@
instance Produces ListNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedNetworkPolicy MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedNetworkPolicy MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedNetworkPolicy MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedReplicaSet3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedReplicaSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedReplicaSet3 MimeNoContent V1beta1ReplicaSetList accept
listNamespacedReplicaSet3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedReplicaSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedReplicaSet3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedReplicaSet3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedReplicaSet3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedReplicaSet3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedReplicaSet3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedReplicaSet3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedReplicaSet3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedReplicaSet3 MimeAny

-- | @application/json@
instance Produces ListNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedReplicaSet3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedReplicaSet3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedReplicaSet3 MimeVndKubernetesProtobufstreamwatch


-- *** listNetworkPolicyForAllNamespaces

-- | @GET \/apis\/extensions\/v1beta1\/networkpolicies@
-- 
-- list or watch objects of kind NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNetworkPolicyForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListNetworkPolicyForAllNamespaces MimeNoContent V1beta1NetworkPolicyList accept
listNetworkPolicyForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNetworkPolicyForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNetworkPolicyForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListNetworkPolicyForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListNetworkPolicyForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNetworkPolicyForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNetworkPolicyForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNetworkPolicyForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listPodSecurityPolicy

-- | @GET \/apis\/extensions\/v1beta1\/podsecuritypolicies@
-- 
-- list or watch objects of kind PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodSecurityPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodSecurityPolicy MimeNoContent V1beta1PodSecurityPolicyList accept
listPodSecurityPolicy  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/podsecuritypolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodSecurityPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodSecurityPolicy Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodSecurityPolicy FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPodSecurityPolicy IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodSecurityPolicy LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodSecurityPolicy Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPodSecurityPolicy ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPodSecurityPolicy TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodSecurityPolicy Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPodSecurityPolicy MimeAny

-- | @application/json@
instance Produces ListPodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces ListPodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodSecurityPolicy MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPodSecurityPolicy MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodSecurityPolicy MimeVndKubernetesProtobufstreamwatch


-- *** listReplicaSetForAllNamespaces3

-- | @GET \/apis\/extensions\/v1beta1\/replicasets@
-- 
-- list or watch objects of kind ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listReplicaSetForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListReplicaSetForAllNamespaces3 MimeNoContent V1beta1ReplicaSetList accept
listReplicaSetForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/extensions/v1beta1/replicasets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListReplicaSetForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListReplicaSetForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListReplicaSetForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListReplicaSetForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListReplicaSetForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListReplicaSetForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListReplicaSetForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListReplicaSetForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedDaemonSet3

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- partially update the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSet3 
  :: (Consumes PatchNamespacedDaemonSet3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSet3 contentType V1beta1DaemonSet accept
patchNamespacedDaemonSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSet3 
instance HasBodyParam PatchNamespacedDaemonSet3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSet3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSet3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSet3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSet3 MimeVndKubernetesProtobuf


-- *** patchNamespacedDaemonSetStatus3

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- partially update status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDaemonSetStatus3 
  :: (Consumes PatchNamespacedDaemonSetStatus3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDaemonSetStatus3 contentType V1beta1DaemonSet accept
patchNamespacedDaemonSetStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDaemonSetStatus3 
instance HasBodyParam PatchNamespacedDaemonSetStatus3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDaemonSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDaemonSetStatus3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDaemonSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDaemonSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDaemonSetStatus3 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeployment4

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- partially update the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeployment4 
  :: (Consumes PatchNamespacedDeployment4 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeployment4 contentType ExtensionsV1beta1Deployment accept
patchNamespacedDeployment4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeployment4 
instance HasBodyParam PatchNamespacedDeployment4 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeployment4 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeployment4 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeployment4 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeployment4 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentScale4

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- partially update scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentScale4 
  :: (Consumes PatchNamespacedDeploymentScale4 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentScale4 contentType ExtensionsV1beta1Scale accept
patchNamespacedDeploymentScale4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentScale4 
instance HasBodyParam PatchNamespacedDeploymentScale4 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentScale4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentScale4 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale4 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentScale4 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentScale4 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentScale4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentScale4 MimeVndKubernetesProtobuf


-- *** patchNamespacedDeploymentStatus4

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- partially update status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedDeploymentStatus4 
  :: (Consumes PatchNamespacedDeploymentStatus4 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedDeploymentStatus4 contentType ExtensionsV1beta1Deployment accept
patchNamespacedDeploymentStatus4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedDeploymentStatus4 
instance HasBodyParam PatchNamespacedDeploymentStatus4 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedDeploymentStatus4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedDeploymentStatus4 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus4 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedDeploymentStatus4 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedDeploymentStatus4 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedDeploymentStatus4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedDeploymentStatus4 MimeVndKubernetesProtobuf


-- *** patchNamespacedIngress

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- partially update the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedIngress 
  :: (Consumes PatchNamespacedIngress contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedIngress contentType V1beta1Ingress accept
patchNamespacedIngress _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedIngress 
instance HasBodyParam PatchNamespacedIngress A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedIngress MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedIngress MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedIngress MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedIngress MimeVndKubernetesProtobuf


-- *** patchNamespacedIngressStatus

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}\/status@
-- 
-- partially update status of the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedIngressStatus 
  :: (Consumes PatchNamespacedIngressStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedIngressStatus contentType V1beta1Ingress accept
patchNamespacedIngressStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedIngressStatus 
instance HasBodyParam PatchNamespacedIngressStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedIngressStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedIngressStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedIngressStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedIngressStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedIngressStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedIngressStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedIngressStatus MimeVndKubernetesProtobuf


-- *** patchNamespacedNetworkPolicy

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- partially update the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedNetworkPolicy 
  :: (Consumes PatchNamespacedNetworkPolicy contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedNetworkPolicy contentType V1beta1NetworkPolicy accept
patchNamespacedNetworkPolicy _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedNetworkPolicy 
instance HasBodyParam PatchNamespacedNetworkPolicy A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedNetworkPolicy MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedNetworkPolicy MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedNetworkPolicy MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedNetworkPolicy MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSet3

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- partially update the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSet3 
  :: (Consumes PatchNamespacedReplicaSet3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSet3 contentType V1beta1ReplicaSet accept
patchNamespacedReplicaSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSet3 
instance HasBodyParam PatchNamespacedReplicaSet3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSet3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSet3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSet3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSet3 MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetScale3

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetScale3 
  :: (Consumes PatchNamespacedReplicaSetScale3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetScale3 contentType ExtensionsV1beta1Scale accept
patchNamespacedReplicaSetScale3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetScale3 
instance HasBodyParam PatchNamespacedReplicaSetScale3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetScale3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetScale3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetScale3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetScale3 MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicaSetStatus3

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- partially update status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicaSetStatus3 
  :: (Consumes PatchNamespacedReplicaSetStatus3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicaSetStatus3 contentType V1beta1ReplicaSet accept
patchNamespacedReplicaSetStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicaSetStatus3 
instance HasBodyParam PatchNamespacedReplicaSetStatus3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicaSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicaSetStatus3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicaSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicaSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicaSetStatus3 MimeVndKubernetesProtobuf


-- *** patchNamespacedReplicationControllerDummyScale

-- | @PATCH \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- partially update scale of the specified ReplicationControllerDummy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedReplicationControllerDummyScale 
  :: (Consumes PatchNamespacedReplicationControllerDummyScale contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedReplicationControllerDummyScale contentType ExtensionsV1beta1Scale accept
patchNamespacedReplicationControllerDummyScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedReplicationControllerDummyScale 
instance HasBodyParam PatchNamespacedReplicationControllerDummyScale A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedReplicationControllerDummyScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedReplicationControllerDummyScale MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedReplicationControllerDummyScale MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedReplicationControllerDummyScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedReplicationControllerDummyScale MimeVndKubernetesProtobuf


-- *** patchPodSecurityPolicy

-- | @PATCH \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- partially update the specified PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchPodSecurityPolicy 
  :: (Consumes PatchPodSecurityPolicy contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchPodSecurityPolicy contentType V1beta1PodSecurityPolicy accept
patchPodSecurityPolicy _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchPodSecurityPolicy 
instance HasBodyParam PatchPodSecurityPolicy A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchPodSecurityPolicy MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchPodSecurityPolicy MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchPodSecurityPolicy MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchPodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces PatchPodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchPodSecurityPolicy MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSet3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- read the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSet3 MimeNoContent V1beta1DaemonSet accept
readNamespacedDaemonSet3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDaemonSet3 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDaemonSet3 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDaemonSet3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSet3 MimeVndKubernetesProtobuf


-- *** readNamespacedDaemonSetStatus3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- read status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDaemonSetStatus3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDaemonSetStatus3 MimeNoContent V1beta1DaemonSet accept
readNamespacedDaemonSetStatus3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDaemonSetStatus3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDaemonSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDaemonSetStatus3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDaemonSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDaemonSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDaemonSetStatus3 MimeVndKubernetesProtobuf


-- *** readNamespacedDeployment4

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- read the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeployment4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeployment4 MimeNoContent ExtensionsV1beta1Deployment accept
readNamespacedDeployment4  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeployment4  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedDeployment4 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedDeployment4 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeployment4 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeployment4 MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentScale4

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- read scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentScale4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentScale4 MimeNoContent ExtensionsV1beta1Scale accept
readNamespacedDeploymentScale4  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentScale4  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentScale4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentScale4 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentScale4 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentScale4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentScale4 MimeVndKubernetesProtobuf


-- *** readNamespacedDeploymentStatus4

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- read status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedDeploymentStatus4 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedDeploymentStatus4 MimeNoContent ExtensionsV1beta1Deployment accept
readNamespacedDeploymentStatus4  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedDeploymentStatus4  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedDeploymentStatus4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedDeploymentStatus4 MimeAny

-- | @application/json@
instance Produces ReadNamespacedDeploymentStatus4 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedDeploymentStatus4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedDeploymentStatus4 MimeVndKubernetesProtobuf


-- *** readNamespacedIngress

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- read the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedIngress 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedIngress MimeNoContent V1beta1Ingress accept
readNamespacedIngress  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedIngress  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedIngress Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedIngress Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedIngress MimeAny

-- | @application/json@
instance Produces ReadNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedIngress MimeVndKubernetesProtobuf


-- *** readNamespacedIngressStatus

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}\/status@
-- 
-- read status of the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedIngressStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedIngressStatus MimeNoContent V1beta1Ingress accept
readNamespacedIngressStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedIngressStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedIngressStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedIngressStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedIngressStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedIngressStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedIngressStatus MimeVndKubernetesProtobuf


-- *** readNamespacedNetworkPolicy

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- read the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedNetworkPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedNetworkPolicy MimeNoContent V1beta1NetworkPolicy accept
readNamespacedNetworkPolicy  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedNetworkPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedNetworkPolicy Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedNetworkPolicy Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedNetworkPolicy MimeAny

-- | @application/json@
instance Produces ReadNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedNetworkPolicy MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSet3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- read the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSet3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSet3 MimeNoContent V1beta1ReplicaSet accept
readNamespacedReplicaSet3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSet3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedReplicaSet3 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedReplicaSet3 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSet3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSet3 MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetScale3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- read scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetScale3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetScale3 MimeNoContent ExtensionsV1beta1Scale accept
readNamespacedReplicaSetScale3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetScale3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSetScale3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSetScale3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetScale3 MimeVndKubernetesProtobuf


-- *** readNamespacedReplicaSetStatus3

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- read status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicaSetStatus3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicaSetStatus3 MimeNoContent V1beta1ReplicaSet accept
readNamespacedReplicaSetStatus3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicaSetStatus3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicaSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicaSetStatus3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicaSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicaSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicaSetStatus3 MimeVndKubernetesProtobuf


-- *** readNamespacedReplicationControllerDummyScale

-- | @GET \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- read scale of the specified ReplicationControllerDummy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedReplicationControllerDummyScale 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedReplicationControllerDummyScale MimeNoContent ExtensionsV1beta1Scale accept
readNamespacedReplicationControllerDummyScale  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedReplicationControllerDummyScale  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedReplicationControllerDummyScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedReplicationControllerDummyScale MimeAny

-- | @application/json@
instance Produces ReadNamespacedReplicationControllerDummyScale MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedReplicationControllerDummyScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedReplicationControllerDummyScale MimeVndKubernetesProtobuf


-- *** readPodSecurityPolicy

-- | @GET \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- read the specified PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readPodSecurityPolicy 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> KubernetesRequest ReadPodSecurityPolicy MimeNoContent V1beta1PodSecurityPolicy accept
readPodSecurityPolicy  _ (Name name) =
  _mkRequest "GET" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadPodSecurityPolicy  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadPodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadPodSecurityPolicy Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadPodSecurityPolicy Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadPodSecurityPolicy MimeAny

-- | @application/json@
instance Produces ReadPodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces ReadPodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadPodSecurityPolicy MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSet3

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}@
-- 
-- replace the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSet3 
  :: (Consumes ReplaceNamespacedDaemonSet3 contentType, MimeRender contentType V1beta1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSet3 contentType V1beta1DaemonSet accept
replaceNamespacedDaemonSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSet3 
instance HasBodyParam ReplaceNamespacedDaemonSet3 V1beta1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDaemonSet3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSet3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSet3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDaemonSetStatus3

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/daemonsets\/{name}\/status@
-- 
-- replace status of the specified DaemonSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDaemonSetStatus3 
  :: (Consumes ReplaceNamespacedDaemonSetStatus3 contentType, MimeRender contentType V1beta1DaemonSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the DaemonSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1DaemonSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDaemonSetStatus3 contentType V1beta1DaemonSet accept
replaceNamespacedDaemonSetStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/daemonsets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDaemonSetStatus3 
instance HasBodyParam ReplaceNamespacedDaemonSetStatus3 V1beta1DaemonSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDaemonSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDaemonSetStatus3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDaemonSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDaemonSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDaemonSetStatus3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeployment4

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}@
-- 
-- replace the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeployment4 
  :: (Consumes ReplaceNamespacedDeployment4 contentType, MimeRender contentType ExtensionsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeployment4 contentType ExtensionsV1beta1Deployment accept
replaceNamespacedDeployment4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeployment4 
instance HasBodyParam ReplaceNamespacedDeployment4 ExtensionsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeployment4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeployment4 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeployment4 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeployment4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeployment4 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentScale4

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/scale@
-- 
-- replace scale of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentScale4 
  :: (Consumes ReplaceNamespacedDeploymentScale4 contentType, MimeRender contentType ExtensionsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentScale4 contentType ExtensionsV1beta1Scale accept
replaceNamespacedDeploymentScale4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentScale4 
instance HasBodyParam ReplaceNamespacedDeploymentScale4 ExtensionsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentScale4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentScale4 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentScale4 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentScale4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentScale4 MimeVndKubernetesProtobuf


-- *** replaceNamespacedDeploymentStatus4

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/deployments\/{name}\/status@
-- 
-- replace status of the specified Deployment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedDeploymentStatus4 
  :: (Consumes ReplaceNamespacedDeploymentStatus4 contentType, MimeRender contentType ExtensionsV1beta1Deployment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Deployment
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1Deployment -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedDeploymentStatus4 contentType ExtensionsV1beta1Deployment accept
replaceNamespacedDeploymentStatus4 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/deployments/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedDeploymentStatus4 
instance HasBodyParam ReplaceNamespacedDeploymentStatus4 ExtensionsV1beta1Deployment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedDeploymentStatus4 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedDeploymentStatus4 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedDeploymentStatus4 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedDeploymentStatus4 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedDeploymentStatus4 MimeVndKubernetesProtobuf


-- *** replaceNamespacedIngress

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}@
-- 
-- replace the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedIngress 
  :: (Consumes ReplaceNamespacedIngress contentType, MimeRender contentType V1beta1Ingress)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Ingress -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedIngress contentType V1beta1Ingress accept
replaceNamespacedIngress _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedIngress 
instance HasBodyParam ReplaceNamespacedIngress V1beta1Ingress 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedIngress Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedIngress MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedIngress MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedIngress MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedIngress MimeVndKubernetesProtobuf


-- *** replaceNamespacedIngressStatus

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/ingresses\/{name}\/status@
-- 
-- replace status of the specified Ingress
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedIngressStatus 
  :: (Consumes ReplaceNamespacedIngressStatus contentType, MimeRender contentType V1beta1Ingress)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Ingress
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Ingress -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedIngressStatus contentType V1beta1Ingress accept
replaceNamespacedIngressStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/ingresses/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedIngressStatus 
instance HasBodyParam ReplaceNamespacedIngressStatus V1beta1Ingress 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedIngressStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedIngressStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedIngressStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedIngressStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedIngressStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedNetworkPolicy

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- replace the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedNetworkPolicy 
  :: (Consumes ReplaceNamespacedNetworkPolicy contentType, MimeRender contentType V1beta1NetworkPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1NetworkPolicy -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedNetworkPolicy contentType V1beta1NetworkPolicy accept
replaceNamespacedNetworkPolicy _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedNetworkPolicy 
instance HasBodyParam ReplaceNamespacedNetworkPolicy V1beta1NetworkPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedNetworkPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedNetworkPolicy MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedNetworkPolicy MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedNetworkPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedNetworkPolicy MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSet3

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}@
-- 
-- replace the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSet3 
  :: (Consumes ReplaceNamespacedReplicaSet3 contentType, MimeRender contentType V1beta1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSet3 contentType V1beta1ReplicaSet accept
replaceNamespacedReplicaSet3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSet3 
instance HasBodyParam ReplaceNamespacedReplicaSet3 V1beta1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSet3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSet3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSet3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSet3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSet3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetScale3

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/scale@
-- 
-- replace scale of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetScale3 
  :: (Consumes ReplaceNamespacedReplicaSetScale3 contentType, MimeRender contentType ExtensionsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetScale3 contentType ExtensionsV1beta1Scale accept
replaceNamespacedReplicaSetScale3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetScale3 
instance HasBodyParam ReplaceNamespacedReplicaSetScale3 ExtensionsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetScale3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSetScale3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetScale3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetScale3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetScale3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicaSetStatus3

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicasets\/{name}\/status@
-- 
-- replace status of the specified ReplicaSet
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicaSetStatus3 
  :: (Consumes ReplaceNamespacedReplicaSetStatus3 contentType, MimeRender contentType V1beta1ReplicaSet)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ReplicaSet
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1ReplicaSet -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicaSetStatus3 contentType V1beta1ReplicaSet accept
replaceNamespacedReplicaSetStatus3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicasets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicaSetStatus3 
instance HasBodyParam ReplaceNamespacedReplicaSetStatus3 V1beta1ReplicaSet 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicaSetStatus3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicaSetStatus3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicaSetStatus3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicaSetStatus3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicaSetStatus3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedReplicationControllerDummyScale

-- | @PUT \/apis\/extensions\/v1beta1\/namespaces\/{namespace}\/replicationcontrollers\/{name}\/scale@
-- 
-- replace scale of the specified ReplicationControllerDummy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedReplicationControllerDummyScale 
  :: (Consumes ReplaceNamespacedReplicationControllerDummyScale contentType, MimeRender contentType ExtensionsV1beta1Scale)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Scale
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> ExtensionsV1beta1Scale -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedReplicationControllerDummyScale contentType ExtensionsV1beta1Scale accept
replaceNamespacedReplicationControllerDummyScale _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/namespaces/",toPath namespace,"/replicationcontrollers/",toPath name,"/scale"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedReplicationControllerDummyScale 
instance HasBodyParam ReplaceNamespacedReplicationControllerDummyScale ExtensionsV1beta1Scale 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedReplicationControllerDummyScale Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedReplicationControllerDummyScale MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedReplicationControllerDummyScale MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedReplicationControllerDummyScale MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedReplicationControllerDummyScale MimeVndKubernetesProtobuf


-- *** replacePodSecurityPolicy

-- | @PUT \/apis\/extensions\/v1beta1\/podsecuritypolicies\/{name}@
-- 
-- replace the specified PodSecurityPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replacePodSecurityPolicy 
  :: (Consumes ReplacePodSecurityPolicy contentType, MimeRender contentType V1beta1PodSecurityPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSecurityPolicy
  -> V1beta1PodSecurityPolicy -- ^ "body"
  -> KubernetesRequest ReplacePodSecurityPolicy contentType V1beta1PodSecurityPolicy accept
replacePodSecurityPolicy _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/extensions/v1beta1/podsecuritypolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplacePodSecurityPolicy 
instance HasBodyParam ReplacePodSecurityPolicy V1beta1PodSecurityPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplacePodSecurityPolicy Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplacePodSecurityPolicy MimeAny

-- | @application/json@
instance Produces ReplacePodSecurityPolicy MimeJSON
-- | @application/yaml@
instance Produces ReplacePodSecurityPolicy MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplacePodSecurityPolicy MimeVndKubernetesProtobuf


-- ** Logs

-- *** logFileHandler

-- | @GET \/logs\/{logpath}@
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
logFileHandler 
  :: Logpath -- ^ "logpath" -  path to the log
  -> KubernetesRequest LogFileHandler MimeNoContent NoContent MimeNoContent
logFileHandler (Logpath logpath) =
  _mkRequest "GET" ["/logs/",toPath logpath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data LogFileHandler  

-- *** logFileListHandler

-- | @GET \/logs\/@
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
logFileListHandler 
  :: KubernetesRequest LogFileListHandler MimeNoContent NoContent MimeNoContent
logFileListHandler =
  _mkRequest "GET" ["/logs/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data LogFileListHandler  

-- ** Networking

-- *** getAPIGroup12

-- | @GET \/apis\/networking.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup12 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup12 MimeNoContent V1APIGroup accept
getAPIGroup12  _ =
  _mkRequest "GET" ["/apis/networking.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup12  

-- | @application/json@
instance Consumes GetAPIGroup12 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup12 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup12 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup12 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup12 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup12 MimeVndKubernetesProtobuf


-- ** NetworkingV1

-- *** createNamespacedNetworkPolicy2

-- | @POST \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- create a NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedNetworkPolicy2 
  :: (Consumes CreateNamespacedNetworkPolicy2 contentType, MimeRender contentType V1NetworkPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1NetworkPolicy -- ^ "body"
  -> KubernetesRequest CreateNamespacedNetworkPolicy2 contentType V1NetworkPolicy accept
createNamespacedNetworkPolicy2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedNetworkPolicy2 
instance HasBodyParam CreateNamespacedNetworkPolicy2 V1NetworkPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedNetworkPolicy2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedNetworkPolicy2

-- | @DELETE \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- delete collection of NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedNetworkPolicy2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedNetworkPolicy2 MimeNoContent V1Status accept
deleteCollectionNamespacedNetworkPolicy2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedNetworkPolicy2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedNetworkPolicy2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedNetworkPolicy2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedNetworkPolicy2

-- | @DELETE \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- delete a NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedNetworkPolicy2 
  :: (Consumes DeleteNamespacedNetworkPolicy2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedNetworkPolicy2 contentType V1Status accept
deleteNamespacedNetworkPolicy2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedNetworkPolicy2 
instance HasBodyParam DeleteNamespacedNetworkPolicy2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedNetworkPolicy2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedNetworkPolicy2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedNetworkPolicy2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedNetworkPolicy2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf


-- *** getAPIResources21

-- | @GET \/apis\/networking.k8s.io\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources21 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources21 MimeNoContent V1APIResourceList accept
getAPIResources21  _ =
  _mkRequest "GET" ["/apis/networking.k8s.io/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources21  

-- | @application/json@
instance Consumes GetAPIResources21 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources21 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources21 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources21 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources21 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources21 MimeVndKubernetesProtobuf


-- *** listNamespacedNetworkPolicy2

-- | @GET \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies@
-- 
-- list or watch objects of kind NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedNetworkPolicy2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedNetworkPolicy2 MimeNoContent V1NetworkPolicyList accept
listNamespacedNetworkPolicy2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedNetworkPolicy2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedNetworkPolicy2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedNetworkPolicy2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedNetworkPolicy2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedNetworkPolicy2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedNetworkPolicy2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedNetworkPolicy2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedNetworkPolicy2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedNetworkPolicy2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedNetworkPolicy2 MimeAny

-- | @application/json@
instance Produces ListNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedNetworkPolicy2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedNetworkPolicy2 MimeVndKubernetesProtobufstreamwatch


-- *** listNetworkPolicyForAllNamespaces2

-- | @GET \/apis\/networking.k8s.io\/v1\/networkpolicies@
-- 
-- list or watch objects of kind NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNetworkPolicyForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListNetworkPolicyForAllNamespaces2 MimeNoContent V1NetworkPolicyList accept
listNetworkPolicyForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/networking.k8s.io/v1/networkpolicies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNetworkPolicyForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNetworkPolicyForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNetworkPolicyForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListNetworkPolicyForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListNetworkPolicyForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNetworkPolicyForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNetworkPolicyForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNetworkPolicyForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedNetworkPolicy2

-- | @PATCH \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- partially update the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedNetworkPolicy2 
  :: (Consumes PatchNamespacedNetworkPolicy2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedNetworkPolicy2 contentType V1NetworkPolicy accept
patchNamespacedNetworkPolicy2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedNetworkPolicy2 
instance HasBodyParam PatchNamespacedNetworkPolicy2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedNetworkPolicy2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedNetworkPolicy2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedNetworkPolicy2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf


-- *** readNamespacedNetworkPolicy2

-- | @GET \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- read the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedNetworkPolicy2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedNetworkPolicy2 MimeNoContent V1NetworkPolicy accept
readNamespacedNetworkPolicy2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedNetworkPolicy2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedNetworkPolicy2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedNetworkPolicy2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedNetworkPolicy2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedNetworkPolicy2

-- | @PUT \/apis\/networking.k8s.io\/v1\/namespaces\/{namespace}\/networkpolicies\/{name}@
-- 
-- replace the specified NetworkPolicy
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedNetworkPolicy2 
  :: (Consumes ReplaceNamespacedNetworkPolicy2 contentType, MimeRender contentType V1NetworkPolicy)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the NetworkPolicy
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1NetworkPolicy -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedNetworkPolicy2 contentType V1NetworkPolicy accept
replaceNamespacedNetworkPolicy2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/networking.k8s.io/v1/namespaces/",toPath namespace,"/networkpolicies/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedNetworkPolicy2 
instance HasBodyParam ReplaceNamespacedNetworkPolicy2 V1NetworkPolicy 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedNetworkPolicy2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedNetworkPolicy2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedNetworkPolicy2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedNetworkPolicy2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedNetworkPolicy2 MimeVndKubernetesProtobuf


-- ** Policy

-- *** getAPIGroup13

-- | @GET \/apis\/policy\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup13 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup13 MimeNoContent V1APIGroup accept
getAPIGroup13  _ =
  _mkRequest "GET" ["/apis/policy/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup13  

-- | @application/json@
instance Consumes GetAPIGroup13 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup13 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup13 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup13 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup13 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup13 MimeVndKubernetesProtobuf


-- ** PolicyV1beta1

-- *** createNamespacedPodDisruptionBudget

-- | @POST \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets@
-- 
-- create a PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPodDisruptionBudget 
  :: (Consumes CreateNamespacedPodDisruptionBudget contentType, MimeRender contentType V1beta1PodDisruptionBudget)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1PodDisruptionBudget -- ^ "body"
  -> KubernetesRequest CreateNamespacedPodDisruptionBudget contentType V1beta1PodDisruptionBudget accept
createNamespacedPodDisruptionBudget _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPodDisruptionBudget 
instance HasBodyParam CreateNamespacedPodDisruptionBudget V1beta1PodDisruptionBudget 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPodDisruptionBudget MimeAny

-- | @application/json@
instance Produces CreateNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedPodDisruptionBudget

-- | @DELETE \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets@
-- 
-- delete collection of PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedPodDisruptionBudget 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedPodDisruptionBudget MimeNoContent V1Status accept
deleteCollectionNamespacedPodDisruptionBudget  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedPodDisruptionBudget  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedPodDisruptionBudget Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedPodDisruptionBudget MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf


-- *** deleteNamespacedPodDisruptionBudget

-- | @DELETE \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}@
-- 
-- delete a PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedPodDisruptionBudget 
  :: (Consumes DeleteNamespacedPodDisruptionBudget contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedPodDisruptionBudget contentType V1Status accept
deleteNamespacedPodDisruptionBudget _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedPodDisruptionBudget 
instance HasBodyParam DeleteNamespacedPodDisruptionBudget V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedPodDisruptionBudget GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedPodDisruptionBudget OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedPodDisruptionBudget PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedPodDisruptionBudget MimeAny

-- | @application/json@
instance Produces DeleteNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf


-- *** getAPIResources22

-- | @GET \/apis\/policy\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources22 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources22 MimeNoContent V1APIResourceList accept
getAPIResources22  _ =
  _mkRequest "GET" ["/apis/policy/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources22  

-- | @application/json@
instance Consumes GetAPIResources22 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources22 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources22 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources22 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources22 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources22 MimeVndKubernetesProtobuf


-- *** listNamespacedPodDisruptionBudget

-- | @GET \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets@
-- 
-- list or watch objects of kind PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedPodDisruptionBudget 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedPodDisruptionBudget MimeNoContent V1beta1PodDisruptionBudgetList accept
listNamespacedPodDisruptionBudget  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedPodDisruptionBudget  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedPodDisruptionBudget Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedPodDisruptionBudget FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedPodDisruptionBudget IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedPodDisruptionBudget LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedPodDisruptionBudget Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedPodDisruptionBudget ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedPodDisruptionBudget TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedPodDisruptionBudget Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedPodDisruptionBudget MimeAny

-- | @application/json@
instance Produces ListNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedPodDisruptionBudget MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedPodDisruptionBudget MimeVndKubernetesProtobufstreamwatch


-- *** listPodDisruptionBudgetForAllNamespaces

-- | @GET \/apis\/policy\/v1beta1\/poddisruptionbudgets@
-- 
-- list or watch objects of kind PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodDisruptionBudgetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodDisruptionBudgetForAllNamespaces MimeNoContent V1beta1PodDisruptionBudgetList accept
listPodDisruptionBudgetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/policy/v1beta1/poddisruptionbudgets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodDisruptionBudgetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodDisruptionBudgetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPodDisruptionBudgetForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListPodDisruptionBudgetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListPodDisruptionBudgetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodDisruptionBudgetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPodDisruptionBudgetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodDisruptionBudgetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedPodDisruptionBudget

-- | @PATCH \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}@
-- 
-- partially update the specified PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodDisruptionBudget 
  :: (Consumes PatchNamespacedPodDisruptionBudget contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPodDisruptionBudget contentType V1beta1PodDisruptionBudget accept
patchNamespacedPodDisruptionBudget _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodDisruptionBudget 
instance HasBodyParam PatchNamespacedPodDisruptionBudget A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodDisruptionBudget MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodDisruptionBudget MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodDisruptionBudget MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf


-- *** patchNamespacedPodDisruptionBudgetStatus

-- | @PATCH \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}\/status@
-- 
-- partially update status of the specified PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodDisruptionBudgetStatus 
  :: (Consumes PatchNamespacedPodDisruptionBudgetStatus contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPodDisruptionBudgetStatus contentType V1beta1PodDisruptionBudget accept
patchNamespacedPodDisruptionBudgetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodDisruptionBudgetStatus 
instance HasBodyParam PatchNamespacedPodDisruptionBudgetStatus A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodDisruptionBudgetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodDisruptionBudgetStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodDisruptionBudgetStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodDisruptionBudgetStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodDisruptionBudgetStatus MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPodDisruptionBudgetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodDisruptionBudgetStatus MimeVndKubernetesProtobuf


-- *** readNamespacedPodDisruptionBudget

-- | @GET \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}@
-- 
-- read the specified PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodDisruptionBudget 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodDisruptionBudget MimeNoContent V1beta1PodDisruptionBudget accept
readNamespacedPodDisruptionBudget  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodDisruptionBudget  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedPodDisruptionBudget Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedPodDisruptionBudget Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPodDisruptionBudget MimeAny

-- | @application/json@
instance Produces ReadNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf


-- *** readNamespacedPodDisruptionBudgetStatus

-- | @GET \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}\/status@
-- 
-- read status of the specified PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodDisruptionBudgetStatus 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodDisruptionBudgetStatus MimeNoContent V1beta1PodDisruptionBudget accept
readNamespacedPodDisruptionBudgetStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodDisruptionBudgetStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodDisruptionBudgetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPodDisruptionBudgetStatus MimeAny

-- | @application/json@
instance Produces ReadNamespacedPodDisruptionBudgetStatus MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPodDisruptionBudgetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodDisruptionBudgetStatus MimeVndKubernetesProtobuf


-- *** replaceNamespacedPodDisruptionBudget

-- | @PUT \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}@
-- 
-- replace the specified PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodDisruptionBudget 
  :: (Consumes ReplaceNamespacedPodDisruptionBudget contentType, MimeRender contentType V1beta1PodDisruptionBudget)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1PodDisruptionBudget -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPodDisruptionBudget contentType V1beta1PodDisruptionBudget accept
replaceNamespacedPodDisruptionBudget _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodDisruptionBudget 
instance HasBodyParam ReplaceNamespacedPodDisruptionBudget V1beta1PodDisruptionBudget 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodDisruptionBudget Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPodDisruptionBudget MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPodDisruptionBudget MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPodDisruptionBudget MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodDisruptionBudget MimeVndKubernetesProtobuf


-- *** replaceNamespacedPodDisruptionBudgetStatus

-- | @PUT \/apis\/policy\/v1beta1\/namespaces\/{namespace}\/poddisruptionbudgets\/{name}\/status@
-- 
-- replace status of the specified PodDisruptionBudget
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodDisruptionBudgetStatus 
  :: (Consumes ReplaceNamespacedPodDisruptionBudgetStatus contentType, MimeRender contentType V1beta1PodDisruptionBudget)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodDisruptionBudget
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1PodDisruptionBudget -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPodDisruptionBudgetStatus contentType V1beta1PodDisruptionBudget accept
replaceNamespacedPodDisruptionBudgetStatus _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/policy/v1beta1/namespaces/",toPath namespace,"/poddisruptionbudgets/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodDisruptionBudgetStatus 
instance HasBodyParam ReplaceNamespacedPodDisruptionBudgetStatus V1beta1PodDisruptionBudget 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodDisruptionBudgetStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPodDisruptionBudgetStatus MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPodDisruptionBudgetStatus MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPodDisruptionBudgetStatus MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodDisruptionBudgetStatus MimeVndKubernetesProtobuf


-- ** RbacAuthorization

-- *** getAPIGroup14

-- | @GET \/apis\/rbac.authorization.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup14 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup14 MimeNoContent V1APIGroup accept
getAPIGroup14  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup14  

-- | @application/json@
instance Consumes GetAPIGroup14 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup14 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup14 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup14 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup14 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup14 MimeVndKubernetesProtobuf


-- ** RbacAuthorizationV1

-- *** createClusterRole

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles@
-- 
-- create a ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterRole 
  :: (Consumes CreateClusterRole contentType, MimeRender contentType V1ClusterRole)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1ClusterRole -- ^ "body"
  -> KubernetesRequest CreateClusterRole contentType V1ClusterRole accept
createClusterRole _  _ body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterRole 
instance HasBodyParam CreateClusterRole V1ClusterRole 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateClusterRole MimeAny

-- | @application/json@
instance Produces CreateClusterRole MimeJSON
-- | @application/yaml@
instance Produces CreateClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateClusterRole MimeVndKubernetesProtobuf


-- *** createClusterRoleBinding

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings@
-- 
-- create a ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterRoleBinding 
  :: (Consumes CreateClusterRoleBinding contentType, MimeRender contentType V1ClusterRoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1ClusterRoleBinding -- ^ "body"
  -> KubernetesRequest CreateClusterRoleBinding contentType V1ClusterRoleBinding accept
createClusterRoleBinding _  _ body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterRoleBinding 
instance HasBodyParam CreateClusterRoleBinding V1ClusterRoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateClusterRoleBinding MimeAny

-- | @application/json@
instance Produces CreateClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces CreateClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateClusterRoleBinding MimeVndKubernetesProtobuf


-- *** createNamespacedRole

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles@
-- 
-- create a Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedRole 
  :: (Consumes CreateNamespacedRole contentType, MimeRender contentType V1Role)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Role -- ^ "body"
  -> KubernetesRequest CreateNamespacedRole contentType V1Role accept
createNamespacedRole _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedRole 
instance HasBodyParam CreateNamespacedRole V1Role 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedRole MimeAny

-- | @application/json@
instance Produces CreateNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedRole MimeVndKubernetesProtobuf


-- *** createNamespacedRoleBinding

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings@
-- 
-- create a RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedRoleBinding 
  :: (Consumes CreateNamespacedRoleBinding contentType, MimeRender contentType V1RoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1RoleBinding -- ^ "body"
  -> KubernetesRequest CreateNamespacedRoleBinding contentType V1RoleBinding accept
createNamespacedRoleBinding _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedRoleBinding 
instance HasBodyParam CreateNamespacedRoleBinding V1RoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedRoleBinding MimeAny

-- | @application/json@
instance Produces CreateNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedRoleBinding MimeVndKubernetesProtobuf


-- *** deleteClusterRole

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles\/{name}@
-- 
-- delete a ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterRole 
  :: (Consumes DeleteClusterRole contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterRole contentType V1Status accept
deleteClusterRole _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterRole 
instance HasBodyParam DeleteClusterRole V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterRole GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterRole OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteClusterRole PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterRole MimeAny

-- | @application/json@
instance Produces DeleteClusterRole MimeJSON
-- | @application/yaml@
instance Produces DeleteClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteClusterRole MimeVndKubernetesProtobuf


-- *** deleteClusterRoleBinding

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings\/{name}@
-- 
-- delete a ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterRoleBinding 
  :: (Consumes DeleteClusterRoleBinding contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterRoleBinding contentType V1Status accept
deleteClusterRoleBinding _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterRoleBinding 
instance HasBodyParam DeleteClusterRoleBinding V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterRoleBinding GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterRoleBinding OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteClusterRoleBinding PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterRoleBinding MimeAny

-- | @application/json@
instance Produces DeleteClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces DeleteClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteClusterRoleBinding MimeVndKubernetesProtobuf


-- *** deleteCollectionClusterRole

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles@
-- 
-- delete collection of ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionClusterRole 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionClusterRole MimeNoContent V1Status accept
deleteCollectionClusterRole  _ =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionClusterRole  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionClusterRole Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRole FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionClusterRole IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRole LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionClusterRole Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionClusterRole ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionClusterRole TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionClusterRole Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionClusterRole MimeAny

-- | @application/json@
instance Produces DeleteCollectionClusterRole MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionClusterRole MimeVndKubernetesProtobuf


-- *** deleteCollectionClusterRoleBinding

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings@
-- 
-- delete collection of ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionClusterRoleBinding 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionClusterRoleBinding MimeNoContent V1Status accept
deleteCollectionClusterRoleBinding  _ =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionClusterRoleBinding  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionClusterRoleBinding Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRoleBinding FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionClusterRoleBinding IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRoleBinding LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionClusterRoleBinding Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionClusterRoleBinding ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionClusterRoleBinding TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionClusterRoleBinding Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionClusterRoleBinding MimeAny

-- | @application/json@
instance Produces DeleteCollectionClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionClusterRoleBinding MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedRole

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles@
-- 
-- delete collection of Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedRole 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedRole MimeNoContent V1Status accept
deleteCollectionNamespacedRole  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedRole  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedRole Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRole FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedRole IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRole LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedRole Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedRole ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedRole TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedRole Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedRole MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedRole MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedRoleBinding

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings@
-- 
-- delete collection of RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedRoleBinding 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedRoleBinding MimeNoContent V1Status accept
deleteCollectionNamespacedRoleBinding  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedRoleBinding  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedRoleBinding MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedRoleBinding MimeVndKubernetesProtobuf


-- *** deleteNamespacedRole

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- delete a Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedRole 
  :: (Consumes DeleteNamespacedRole contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedRole contentType V1Status accept
deleteNamespacedRole _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedRole 
instance HasBodyParam DeleteNamespacedRole V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedRole GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedRole OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedRole PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedRole MimeAny

-- | @application/json@
instance Produces DeleteNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedRole MimeVndKubernetesProtobuf


-- *** deleteNamespacedRoleBinding

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- delete a RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedRoleBinding 
  :: (Consumes DeleteNamespacedRoleBinding contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedRoleBinding contentType V1Status accept
deleteNamespacedRoleBinding _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedRoleBinding 
instance HasBodyParam DeleteNamespacedRoleBinding V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedRoleBinding GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedRoleBinding OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedRoleBinding PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedRoleBinding MimeAny

-- | @application/json@
instance Produces DeleteNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedRoleBinding MimeVndKubernetesProtobuf


-- *** getAPIResources23

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources23 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources23 MimeNoContent V1APIResourceList accept
getAPIResources23  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources23  

-- | @application/json@
instance Consumes GetAPIResources23 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources23 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources23 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources23 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources23 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources23 MimeVndKubernetesProtobuf


-- *** listClusterRole

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles@
-- 
-- list or watch objects of kind ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterRole 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListClusterRole MimeNoContent V1ClusterRoleList accept
listClusterRole  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterRole  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListClusterRole Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListClusterRole FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListClusterRole IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterRole LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListClusterRole Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterRole ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListClusterRole TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListClusterRole Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterRole MimeAny

-- | @application/json@
instance Produces ListClusterRole MimeJSON
-- | @application/yaml@
instance Produces ListClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListClusterRole MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListClusterRole MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListClusterRole MimeVndKubernetesProtobufstreamwatch


-- *** listClusterRoleBinding

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings@
-- 
-- list or watch objects of kind ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterRoleBinding 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListClusterRoleBinding MimeNoContent V1ClusterRoleBindingList accept
listClusterRoleBinding  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterRoleBinding  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListClusterRoleBinding Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListClusterRoleBinding FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListClusterRoleBinding IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterRoleBinding LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListClusterRoleBinding Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterRoleBinding ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListClusterRoleBinding TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListClusterRoleBinding Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterRoleBinding MimeAny

-- | @application/json@
instance Produces ListClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces ListClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListClusterRoleBinding MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListClusterRoleBinding MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListClusterRoleBinding MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedRole

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles@
-- 
-- list or watch objects of kind Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedRole 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedRole MimeNoContent V1RoleList accept
listNamespacedRole  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedRole  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedRole Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedRole FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedRole IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedRole LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedRole Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedRole ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedRole TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedRole Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedRole MimeAny

-- | @application/json@
instance Produces ListNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedRole MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedRole MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedRole MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedRoleBinding

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings@
-- 
-- list or watch objects of kind RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedRoleBinding 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedRoleBinding MimeNoContent V1RoleBindingList accept
listNamespacedRoleBinding  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedRoleBinding  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedRoleBinding Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedRoleBinding FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedRoleBinding IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedRoleBinding LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedRoleBinding Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedRoleBinding ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedRoleBinding TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedRoleBinding Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedRoleBinding MimeAny

-- | @application/json@
instance Produces ListNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedRoleBinding MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedRoleBinding MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedRoleBinding MimeVndKubernetesProtobufstreamwatch


-- *** listRoleBindingForAllNamespaces

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/rolebindings@
-- 
-- list or watch objects of kind RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listRoleBindingForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListRoleBindingForAllNamespaces MimeNoContent V1RoleBindingList accept
listRoleBindingForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListRoleBindingForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListRoleBindingForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListRoleBindingForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListRoleBindingForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListRoleBindingForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListRoleBindingForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListRoleBindingForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListRoleBindingForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListRoleBindingForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListRoleBindingForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListRoleBindingForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListRoleBindingForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListRoleBindingForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListRoleBindingForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListRoleBindingForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListRoleBindingForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** listRoleForAllNamespaces

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/roles@
-- 
-- list or watch objects of kind Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listRoleForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListRoleForAllNamespaces MimeNoContent V1RoleList accept
listRoleForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListRoleForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListRoleForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListRoleForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListRoleForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListRoleForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListRoleForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListRoleForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListRoleForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListRoleForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListRoleForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListRoleForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListRoleForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListRoleForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListRoleForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListRoleForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListRoleForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** patchClusterRole

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles\/{name}@
-- 
-- partially update the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchClusterRole 
  :: (Consumes PatchClusterRole contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchClusterRole contentType V1ClusterRole accept
patchClusterRole _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchClusterRole 
instance HasBodyParam PatchClusterRole A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchClusterRole MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchClusterRole MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchClusterRole MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchClusterRole MimeJSON
-- | @application/yaml@
instance Produces PatchClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchClusterRole MimeVndKubernetesProtobuf


-- *** patchClusterRoleBinding

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings\/{name}@
-- 
-- partially update the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchClusterRoleBinding 
  :: (Consumes PatchClusterRoleBinding contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchClusterRoleBinding contentType V1ClusterRoleBinding accept
patchClusterRoleBinding _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchClusterRoleBinding 
instance HasBodyParam PatchClusterRoleBinding A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchClusterRoleBinding MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchClusterRoleBinding MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchClusterRoleBinding MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces PatchClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchClusterRoleBinding MimeVndKubernetesProtobuf


-- *** patchNamespacedRole

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- partially update the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedRole 
  :: (Consumes PatchNamespacedRole contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedRole contentType V1Role accept
patchNamespacedRole _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedRole 
instance HasBodyParam PatchNamespacedRole A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedRole MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedRole MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedRole MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedRole MimeVndKubernetesProtobuf


-- *** patchNamespacedRoleBinding

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- partially update the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedRoleBinding 
  :: (Consumes PatchNamespacedRoleBinding contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedRoleBinding contentType V1RoleBinding accept
patchNamespacedRoleBinding _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedRoleBinding 
instance HasBodyParam PatchNamespacedRoleBinding A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedRoleBinding MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedRoleBinding MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedRoleBinding MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedRoleBinding MimeVndKubernetesProtobuf


-- *** readClusterRole

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles\/{name}@
-- 
-- read the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readClusterRole 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> KubernetesRequest ReadClusterRole MimeNoContent V1ClusterRole accept
readClusterRole  _ (Name name) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadClusterRole  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadClusterRole MimeAny

-- | @application/json@
instance Produces ReadClusterRole MimeJSON
-- | @application/yaml@
instance Produces ReadClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadClusterRole MimeVndKubernetesProtobuf


-- *** readClusterRoleBinding

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings\/{name}@
-- 
-- read the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readClusterRoleBinding 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> KubernetesRequest ReadClusterRoleBinding MimeNoContent V1ClusterRoleBinding accept
readClusterRoleBinding  _ (Name name) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadClusterRoleBinding  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadClusterRoleBinding MimeAny

-- | @application/json@
instance Produces ReadClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces ReadClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadClusterRoleBinding MimeVndKubernetesProtobuf


-- *** readNamespacedRole

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- read the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedRole 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedRole MimeNoContent V1Role accept
readNamespacedRole  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedRole  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedRole MimeAny

-- | @application/json@
instance Produces ReadNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedRole MimeVndKubernetesProtobuf


-- *** readNamespacedRoleBinding

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- read the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedRoleBinding 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedRoleBinding MimeNoContent V1RoleBinding accept
readNamespacedRoleBinding  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedRoleBinding  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedRoleBinding MimeAny

-- | @application/json@
instance Produces ReadNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedRoleBinding MimeVndKubernetesProtobuf


-- *** replaceClusterRole

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1\/clusterroles\/{name}@
-- 
-- replace the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterRole 
  :: (Consumes ReplaceClusterRole contentType, MimeRender contentType V1ClusterRole)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> V1ClusterRole -- ^ "body"
  -> KubernetesRequest ReplaceClusterRole contentType V1ClusterRole accept
replaceClusterRole _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterRole 
instance HasBodyParam ReplaceClusterRole V1ClusterRole 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceClusterRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceClusterRole MimeAny

-- | @application/json@
instance Produces ReplaceClusterRole MimeJSON
-- | @application/yaml@
instance Produces ReplaceClusterRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceClusterRole MimeVndKubernetesProtobuf


-- *** replaceClusterRoleBinding

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1\/clusterrolebindings\/{name}@
-- 
-- replace the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterRoleBinding 
  :: (Consumes ReplaceClusterRoleBinding contentType, MimeRender contentType V1ClusterRoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> V1ClusterRoleBinding -- ^ "body"
  -> KubernetesRequest ReplaceClusterRoleBinding contentType V1ClusterRoleBinding accept
replaceClusterRoleBinding _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterRoleBinding 
instance HasBodyParam ReplaceClusterRoleBinding V1ClusterRoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceClusterRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceClusterRoleBinding MimeAny

-- | @application/json@
instance Produces ReplaceClusterRoleBinding MimeJSON
-- | @application/yaml@
instance Produces ReplaceClusterRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceClusterRoleBinding MimeVndKubernetesProtobuf


-- *** replaceNamespacedRole

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- replace the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedRole 
  :: (Consumes ReplaceNamespacedRole contentType, MimeRender contentType V1Role)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1Role -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedRole contentType V1Role accept
replaceNamespacedRole _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedRole 
instance HasBodyParam ReplaceNamespacedRole V1Role 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedRole Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedRole MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedRole MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedRole MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedRole MimeVndKubernetesProtobuf


-- *** replaceNamespacedRoleBinding

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- replace the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedRoleBinding 
  :: (Consumes ReplaceNamespacedRoleBinding contentType, MimeRender contentType V1RoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1RoleBinding -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedRoleBinding contentType V1RoleBinding accept
replaceNamespacedRoleBinding _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedRoleBinding 
instance HasBodyParam ReplaceNamespacedRoleBinding V1RoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedRoleBinding Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedRoleBinding MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedRoleBinding MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedRoleBinding MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedRoleBinding MimeVndKubernetesProtobuf


-- ** RbacAuthorizationV1alpha1

-- *** createClusterRole2

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles@
-- 
-- create a ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterRole2 
  :: (Consumes CreateClusterRole2 contentType, MimeRender contentType V1alpha1ClusterRole)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha1ClusterRole -- ^ "body"
  -> KubernetesRequest CreateClusterRole2 contentType V1alpha1ClusterRole accept
createClusterRole2 _  _ body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterRole2 
instance HasBodyParam CreateClusterRole2 V1alpha1ClusterRole 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateClusterRole2 MimeAny

-- | @application/json@
instance Produces CreateClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces CreateClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateClusterRole2 MimeVndKubernetesProtobuf


-- *** createClusterRoleBinding2

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings@
-- 
-- create a ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterRoleBinding2 
  :: (Consumes CreateClusterRoleBinding2 contentType, MimeRender contentType V1alpha1ClusterRoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha1ClusterRoleBinding -- ^ "body"
  -> KubernetesRequest CreateClusterRoleBinding2 contentType V1alpha1ClusterRoleBinding accept
createClusterRoleBinding2 _  _ body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterRoleBinding2 
instance HasBodyParam CreateClusterRoleBinding2 V1alpha1ClusterRoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateClusterRoleBinding2 MimeAny

-- | @application/json@
instance Produces CreateClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces CreateClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateClusterRoleBinding2 MimeVndKubernetesProtobuf


-- *** createNamespacedRole2

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles@
-- 
-- create a Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedRole2 
  :: (Consumes CreateNamespacedRole2 contentType, MimeRender contentType V1alpha1Role)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1alpha1Role -- ^ "body"
  -> KubernetesRequest CreateNamespacedRole2 contentType V1alpha1Role accept
createNamespacedRole2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedRole2 
instance HasBodyParam CreateNamespacedRole2 V1alpha1Role 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedRole2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedRole2 MimeVndKubernetesProtobuf


-- *** createNamespacedRoleBinding2

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings@
-- 
-- create a RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedRoleBinding2 
  :: (Consumes CreateNamespacedRoleBinding2 contentType, MimeRender contentType V1alpha1RoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1alpha1RoleBinding -- ^ "body"
  -> KubernetesRequest CreateNamespacedRoleBinding2 contentType V1alpha1RoleBinding accept
createNamespacedRoleBinding2 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedRoleBinding2 
instance HasBodyParam CreateNamespacedRoleBinding2 V1alpha1RoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedRoleBinding2 MimeAny

-- | @application/json@
instance Produces CreateNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedRoleBinding2 MimeVndKubernetesProtobuf


-- *** deleteClusterRole2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles\/{name}@
-- 
-- delete a ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterRole2 
  :: (Consumes DeleteClusterRole2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterRole2 contentType V1Status accept
deleteClusterRole2 _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterRole2 
instance HasBodyParam DeleteClusterRole2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterRole2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterRole2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteClusterRole2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterRole2 MimeAny

-- | @application/json@
instance Produces DeleteClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces DeleteClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteClusterRole2 MimeVndKubernetesProtobuf


-- *** deleteClusterRoleBinding2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings\/{name}@
-- 
-- delete a ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterRoleBinding2 
  :: (Consumes DeleteClusterRoleBinding2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterRoleBinding2 contentType V1Status accept
deleteClusterRoleBinding2 _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterRoleBinding2 
instance HasBodyParam DeleteClusterRoleBinding2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterRoleBinding2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterRoleBinding2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteClusterRoleBinding2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterRoleBinding2 MimeAny

-- | @application/json@
instance Produces DeleteClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces DeleteClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteClusterRoleBinding2 MimeVndKubernetesProtobuf


-- *** deleteCollectionClusterRole2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles@
-- 
-- delete collection of ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionClusterRole2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionClusterRole2 MimeNoContent V1Status accept
deleteCollectionClusterRole2  _ =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionClusterRole2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionClusterRole2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRole2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionClusterRole2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRole2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionClusterRole2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionClusterRole2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionClusterRole2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionClusterRole2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionClusterRole2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionClusterRole2 MimeVndKubernetesProtobuf


-- *** deleteCollectionClusterRoleBinding2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings@
-- 
-- delete collection of ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionClusterRoleBinding2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionClusterRoleBinding2 MimeNoContent V1Status accept
deleteCollectionClusterRoleBinding2  _ =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionClusterRoleBinding2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionClusterRoleBinding2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionClusterRoleBinding2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionClusterRoleBinding2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedRole2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles@
-- 
-- delete collection of Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedRole2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedRole2 MimeNoContent V1Status accept
deleteCollectionNamespacedRole2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedRole2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedRole2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRole2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedRole2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRole2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedRole2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedRole2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedRole2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedRole2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedRole2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedRole2 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedRoleBinding2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings@
-- 
-- delete collection of RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedRoleBinding2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedRoleBinding2 MimeNoContent V1Status accept
deleteCollectionNamespacedRoleBinding2  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedRoleBinding2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedRoleBinding2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedRoleBinding2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedRole2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- delete a Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedRole2 
  :: (Consumes DeleteNamespacedRole2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedRole2 contentType V1Status accept
deleteNamespacedRole2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedRole2 
instance HasBodyParam DeleteNamespacedRole2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedRole2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedRole2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedRole2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedRole2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedRole2 MimeVndKubernetesProtobuf


-- *** deleteNamespacedRoleBinding2

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- delete a RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedRoleBinding2 
  :: (Consumes DeleteNamespacedRoleBinding2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedRoleBinding2 contentType V1Status accept
deleteNamespacedRoleBinding2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedRoleBinding2 
instance HasBodyParam DeleteNamespacedRoleBinding2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedRoleBinding2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedRoleBinding2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedRoleBinding2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedRoleBinding2 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedRoleBinding2 MimeVndKubernetesProtobuf


-- *** getAPIResources24

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources24 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources24 MimeNoContent V1APIResourceList accept
getAPIResources24  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources24  

-- | @application/json@
instance Consumes GetAPIResources24 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources24 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources24 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources24 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources24 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources24 MimeVndKubernetesProtobuf


-- *** listClusterRole2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles@
-- 
-- list or watch objects of kind ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterRole2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListClusterRole2 MimeNoContent V1alpha1ClusterRoleList accept
listClusterRole2  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterRole2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListClusterRole2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListClusterRole2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListClusterRole2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterRole2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListClusterRole2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterRole2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListClusterRole2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListClusterRole2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterRole2 MimeAny

-- | @application/json@
instance Produces ListClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces ListClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListClusterRole2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListClusterRole2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListClusterRole2 MimeVndKubernetesProtobufstreamwatch


-- *** listClusterRoleBinding2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings@
-- 
-- list or watch objects of kind ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterRoleBinding2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListClusterRoleBinding2 MimeNoContent V1alpha1ClusterRoleBindingList accept
listClusterRoleBinding2  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterRoleBinding2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListClusterRoleBinding2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListClusterRoleBinding2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListClusterRoleBinding2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterRoleBinding2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListClusterRoleBinding2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterRoleBinding2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListClusterRoleBinding2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListClusterRoleBinding2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterRoleBinding2 MimeAny

-- | @application/json@
instance Produces ListClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces ListClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListClusterRoleBinding2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListClusterRoleBinding2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListClusterRoleBinding2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedRole2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles@
-- 
-- list or watch objects of kind Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedRole2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedRole2 MimeNoContent V1alpha1RoleList accept
listNamespacedRole2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedRole2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedRole2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedRole2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedRole2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedRole2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedRole2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedRole2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedRole2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedRole2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedRole2 MimeAny

-- | @application/json@
instance Produces ListNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedRole2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedRole2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedRole2 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedRoleBinding2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings@
-- 
-- list or watch objects of kind RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedRoleBinding2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedRoleBinding2 MimeNoContent V1alpha1RoleBindingList accept
listNamespacedRoleBinding2  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedRoleBinding2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedRoleBinding2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedRoleBinding2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedRoleBinding2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedRoleBinding2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedRoleBinding2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedRoleBinding2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedRoleBinding2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedRoleBinding2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedRoleBinding2 MimeAny

-- | @application/json@
instance Produces ListNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedRoleBinding2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedRoleBinding2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedRoleBinding2 MimeVndKubernetesProtobufstreamwatch


-- *** listRoleBindingForAllNamespaces2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/rolebindings@
-- 
-- list or watch objects of kind RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listRoleBindingForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListRoleBindingForAllNamespaces2 MimeNoContent V1alpha1RoleBindingList accept
listRoleBindingForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListRoleBindingForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListRoleBindingForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListRoleBindingForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListRoleBindingForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListRoleBindingForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListRoleBindingForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListRoleBindingForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListRoleBindingForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** listRoleForAllNamespaces2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/roles@
-- 
-- list or watch objects of kind Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listRoleForAllNamespaces2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListRoleForAllNamespaces2 MimeNoContent V1alpha1RoleList accept
listRoleForAllNamespaces2  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListRoleForAllNamespaces2  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListRoleForAllNamespaces2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListRoleForAllNamespaces2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListRoleForAllNamespaces2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListRoleForAllNamespaces2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListRoleForAllNamespaces2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListRoleForAllNamespaces2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListRoleForAllNamespaces2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListRoleForAllNamespaces2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListRoleForAllNamespaces2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListRoleForAllNamespaces2 MimeAny

-- | @application/json@
instance Produces ListRoleForAllNamespaces2 MimeJSON
-- | @application/yaml@
instance Produces ListRoleForAllNamespaces2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListRoleForAllNamespaces2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListRoleForAllNamespaces2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListRoleForAllNamespaces2 MimeVndKubernetesProtobufstreamwatch


-- *** patchClusterRole2

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles\/{name}@
-- 
-- partially update the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchClusterRole2 
  :: (Consumes PatchClusterRole2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchClusterRole2 contentType V1alpha1ClusterRole accept
patchClusterRole2 _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchClusterRole2 
instance HasBodyParam PatchClusterRole2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchClusterRole2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchClusterRole2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchClusterRole2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces PatchClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchClusterRole2 MimeVndKubernetesProtobuf


-- *** patchClusterRoleBinding2

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings\/{name}@
-- 
-- partially update the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchClusterRoleBinding2 
  :: (Consumes PatchClusterRoleBinding2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchClusterRoleBinding2 contentType V1alpha1ClusterRoleBinding accept
patchClusterRoleBinding2 _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchClusterRoleBinding2 
instance HasBodyParam PatchClusterRoleBinding2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchClusterRoleBinding2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchClusterRoleBinding2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchClusterRoleBinding2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces PatchClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchClusterRoleBinding2 MimeVndKubernetesProtobuf


-- *** patchNamespacedRole2

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- partially update the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedRole2 
  :: (Consumes PatchNamespacedRole2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedRole2 contentType V1alpha1Role accept
patchNamespacedRole2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedRole2 
instance HasBodyParam PatchNamespacedRole2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedRole2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedRole2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedRole2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedRole2 MimeVndKubernetesProtobuf


-- *** patchNamespacedRoleBinding2

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- partially update the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedRoleBinding2 
  :: (Consumes PatchNamespacedRoleBinding2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedRoleBinding2 contentType V1alpha1RoleBinding accept
patchNamespacedRoleBinding2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedRoleBinding2 
instance HasBodyParam PatchNamespacedRoleBinding2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedRoleBinding2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedRoleBinding2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedRoleBinding2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedRoleBinding2 MimeVndKubernetesProtobuf


-- *** readClusterRole2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles\/{name}@
-- 
-- read the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readClusterRole2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> KubernetesRequest ReadClusterRole2 MimeNoContent V1alpha1ClusterRole accept
readClusterRole2  _ (Name name) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadClusterRole2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadClusterRole2 MimeAny

-- | @application/json@
instance Produces ReadClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces ReadClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadClusterRole2 MimeVndKubernetesProtobuf


-- *** readClusterRoleBinding2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings\/{name}@
-- 
-- read the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readClusterRoleBinding2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> KubernetesRequest ReadClusterRoleBinding2 MimeNoContent V1alpha1ClusterRoleBinding accept
readClusterRoleBinding2  _ (Name name) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadClusterRoleBinding2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadClusterRoleBinding2 MimeAny

-- | @application/json@
instance Produces ReadClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces ReadClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadClusterRoleBinding2 MimeVndKubernetesProtobuf


-- *** readNamespacedRole2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- read the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedRole2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedRole2 MimeNoContent V1alpha1Role accept
readNamespacedRole2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedRole2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedRole2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedRole2 MimeVndKubernetesProtobuf


-- *** readNamespacedRoleBinding2

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- read the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedRoleBinding2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedRoleBinding2 MimeNoContent V1alpha1RoleBinding accept
readNamespacedRoleBinding2  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedRoleBinding2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedRoleBinding2 MimeAny

-- | @application/json@
instance Produces ReadNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedRoleBinding2 MimeVndKubernetesProtobuf


-- *** replaceClusterRole2

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterroles\/{name}@
-- 
-- replace the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterRole2 
  :: (Consumes ReplaceClusterRole2 contentType, MimeRender contentType V1alpha1ClusterRole)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> V1alpha1ClusterRole -- ^ "body"
  -> KubernetesRequest ReplaceClusterRole2 contentType V1alpha1ClusterRole accept
replaceClusterRole2 _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterRole2 
instance HasBodyParam ReplaceClusterRole2 V1alpha1ClusterRole 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceClusterRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceClusterRole2 MimeAny

-- | @application/json@
instance Produces ReplaceClusterRole2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceClusterRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceClusterRole2 MimeVndKubernetesProtobuf


-- *** replaceClusterRoleBinding2

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1alpha1\/clusterrolebindings\/{name}@
-- 
-- replace the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterRoleBinding2 
  :: (Consumes ReplaceClusterRoleBinding2 contentType, MimeRender contentType V1alpha1ClusterRoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> V1alpha1ClusterRoleBinding -- ^ "body"
  -> KubernetesRequest ReplaceClusterRoleBinding2 contentType V1alpha1ClusterRoleBinding accept
replaceClusterRoleBinding2 _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterRoleBinding2 
instance HasBodyParam ReplaceClusterRoleBinding2 V1alpha1ClusterRoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceClusterRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceClusterRoleBinding2 MimeAny

-- | @application/json@
instance Produces ReplaceClusterRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceClusterRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceClusterRoleBinding2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedRole2

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- replace the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedRole2 
  :: (Consumes ReplaceNamespacedRole2 contentType, MimeRender contentType V1alpha1Role)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1alpha1Role -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedRole2 contentType V1alpha1Role accept
replaceNamespacedRole2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedRole2 
instance HasBodyParam ReplaceNamespacedRole2 V1alpha1Role 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedRole2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedRole2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedRole2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedRole2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedRole2 MimeVndKubernetesProtobuf


-- *** replaceNamespacedRoleBinding2

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1alpha1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- replace the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedRoleBinding2 
  :: (Consumes ReplaceNamespacedRoleBinding2 contentType, MimeRender contentType V1alpha1RoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1alpha1RoleBinding -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedRoleBinding2 contentType V1alpha1RoleBinding accept
replaceNamespacedRoleBinding2 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedRoleBinding2 
instance HasBodyParam ReplaceNamespacedRoleBinding2 V1alpha1RoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedRoleBinding2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedRoleBinding2 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedRoleBinding2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedRoleBinding2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedRoleBinding2 MimeVndKubernetesProtobuf


-- ** RbacAuthorizationV1beta1

-- *** createClusterRole3

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles@
-- 
-- create a ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterRole3 
  :: (Consumes CreateClusterRole3 contentType, MimeRender contentType V1beta1ClusterRole)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1ClusterRole -- ^ "body"
  -> KubernetesRequest CreateClusterRole3 contentType V1beta1ClusterRole accept
createClusterRole3 _  _ body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterRole3 
instance HasBodyParam CreateClusterRole3 V1beta1ClusterRole 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateClusterRole3 MimeAny

-- | @application/json@
instance Produces CreateClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces CreateClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateClusterRole3 MimeVndKubernetesProtobuf


-- *** createClusterRoleBinding3

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings@
-- 
-- create a ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createClusterRoleBinding3 
  :: (Consumes CreateClusterRoleBinding3 contentType, MimeRender contentType V1beta1ClusterRoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1ClusterRoleBinding -- ^ "body"
  -> KubernetesRequest CreateClusterRoleBinding3 contentType V1beta1ClusterRoleBinding accept
createClusterRoleBinding3 _  _ body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateClusterRoleBinding3 
instance HasBodyParam CreateClusterRoleBinding3 V1beta1ClusterRoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateClusterRoleBinding3 MimeAny

-- | @application/json@
instance Produces CreateClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces CreateClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateClusterRoleBinding3 MimeVndKubernetesProtobuf


-- *** createNamespacedRole3

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles@
-- 
-- create a Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedRole3 
  :: (Consumes CreateNamespacedRole3 contentType, MimeRender contentType V1beta1Role)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Role -- ^ "body"
  -> KubernetesRequest CreateNamespacedRole3 contentType V1beta1Role accept
createNamespacedRole3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedRole3 
instance HasBodyParam CreateNamespacedRole3 V1beta1Role 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedRole3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedRole3 MimeVndKubernetesProtobuf


-- *** createNamespacedRoleBinding3

-- | @POST \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings@
-- 
-- create a RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedRoleBinding3 
  :: (Consumes CreateNamespacedRoleBinding3 contentType, MimeRender contentType V1beta1RoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1RoleBinding -- ^ "body"
  -> KubernetesRequest CreateNamespacedRoleBinding3 contentType V1beta1RoleBinding accept
createNamespacedRoleBinding3 _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedRoleBinding3 
instance HasBodyParam CreateNamespacedRoleBinding3 V1beta1RoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedRoleBinding3 MimeAny

-- | @application/json@
instance Produces CreateNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedRoleBinding3 MimeVndKubernetesProtobuf


-- *** deleteClusterRole3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles\/{name}@
-- 
-- delete a ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterRole3 
  :: (Consumes DeleteClusterRole3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterRole3 contentType V1Status accept
deleteClusterRole3 _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterRole3 
instance HasBodyParam DeleteClusterRole3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterRole3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterRole3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteClusterRole3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterRole3 MimeAny

-- | @application/json@
instance Produces DeleteClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces DeleteClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteClusterRole3 MimeVndKubernetesProtobuf


-- *** deleteClusterRoleBinding3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings\/{name}@
-- 
-- delete a ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteClusterRoleBinding3 
  :: (Consumes DeleteClusterRoleBinding3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteClusterRoleBinding3 contentType V1Status accept
deleteClusterRoleBinding3 _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteClusterRoleBinding3 
instance HasBodyParam DeleteClusterRoleBinding3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteClusterRoleBinding3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteClusterRoleBinding3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteClusterRoleBinding3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteClusterRoleBinding3 MimeAny

-- | @application/json@
instance Produces DeleteClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces DeleteClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteClusterRoleBinding3 MimeVndKubernetesProtobuf


-- *** deleteCollectionClusterRole3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles@
-- 
-- delete collection of ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionClusterRole3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionClusterRole3 MimeNoContent V1Status accept
deleteCollectionClusterRole3  _ =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionClusterRole3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionClusterRole3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRole3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionClusterRole3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRole3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionClusterRole3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionClusterRole3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionClusterRole3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionClusterRole3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionClusterRole3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionClusterRole3 MimeVndKubernetesProtobuf


-- *** deleteCollectionClusterRoleBinding3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings@
-- 
-- delete collection of ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionClusterRoleBinding3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionClusterRoleBinding3 MimeNoContent V1Status accept
deleteCollectionClusterRoleBinding3  _ =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionClusterRoleBinding3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionClusterRoleBinding3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionClusterRoleBinding3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionClusterRoleBinding3 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedRole3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles@
-- 
-- delete collection of Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedRole3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedRole3 MimeNoContent V1Status accept
deleteCollectionNamespacedRole3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedRole3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedRole3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRole3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedRole3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRole3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedRole3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedRole3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedRole3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedRole3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedRole3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedRole3 MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedRoleBinding3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings@
-- 
-- delete collection of RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedRoleBinding3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedRoleBinding3 MimeNoContent V1Status accept
deleteCollectionNamespacedRoleBinding3  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedRoleBinding3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedRoleBinding3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedRoleBinding3 MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedRoleBinding3 MimeVndKubernetesProtobuf


-- *** deleteNamespacedRole3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- delete a Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedRole3 
  :: (Consumes DeleteNamespacedRole3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedRole3 contentType V1Status accept
deleteNamespacedRole3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedRole3 
instance HasBodyParam DeleteNamespacedRole3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedRole3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedRole3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedRole3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedRole3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedRole3 MimeVndKubernetesProtobuf


-- *** deleteNamespacedRoleBinding3

-- | @DELETE \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- delete a RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedRoleBinding3 
  :: (Consumes DeleteNamespacedRoleBinding3 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedRoleBinding3 contentType V1Status accept
deleteNamespacedRoleBinding3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedRoleBinding3 
instance HasBodyParam DeleteNamespacedRoleBinding3 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedRoleBinding3 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedRoleBinding3 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedRoleBinding3 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedRoleBinding3 MimeAny

-- | @application/json@
instance Produces DeleteNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedRoleBinding3 MimeVndKubernetesProtobuf


-- *** getAPIResources25

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources25 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources25 MimeNoContent V1APIResourceList accept
getAPIResources25  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources25  

-- | @application/json@
instance Consumes GetAPIResources25 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources25 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources25 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources25 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources25 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources25 MimeVndKubernetesProtobuf


-- *** listClusterRole3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles@
-- 
-- list or watch objects of kind ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterRole3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListClusterRole3 MimeNoContent V1beta1ClusterRoleList accept
listClusterRole3  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterRole3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListClusterRole3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListClusterRole3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListClusterRole3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterRole3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListClusterRole3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterRole3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListClusterRole3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListClusterRole3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterRole3 MimeAny

-- | @application/json@
instance Produces ListClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces ListClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListClusterRole3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListClusterRole3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListClusterRole3 MimeVndKubernetesProtobufstreamwatch


-- *** listClusterRoleBinding3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings@
-- 
-- list or watch objects of kind ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listClusterRoleBinding3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListClusterRoleBinding3 MimeNoContent V1beta1ClusterRoleBindingList accept
listClusterRoleBinding3  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListClusterRoleBinding3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListClusterRoleBinding3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListClusterRoleBinding3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListClusterRoleBinding3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListClusterRoleBinding3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListClusterRoleBinding3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListClusterRoleBinding3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListClusterRoleBinding3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListClusterRoleBinding3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListClusterRoleBinding3 MimeAny

-- | @application/json@
instance Produces ListClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces ListClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListClusterRoleBinding3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListClusterRoleBinding3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListClusterRoleBinding3 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedRole3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles@
-- 
-- list or watch objects of kind Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedRole3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedRole3 MimeNoContent V1beta1RoleList accept
listNamespacedRole3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedRole3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedRole3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedRole3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedRole3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedRole3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedRole3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedRole3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedRole3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedRole3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedRole3 MimeAny

-- | @application/json@
instance Produces ListNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedRole3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedRole3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedRole3 MimeVndKubernetesProtobufstreamwatch


-- *** listNamespacedRoleBinding3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings@
-- 
-- list or watch objects of kind RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedRoleBinding3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedRoleBinding3 MimeNoContent V1beta1RoleBindingList accept
listNamespacedRoleBinding3  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedRoleBinding3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedRoleBinding3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedRoleBinding3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedRoleBinding3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedRoleBinding3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedRoleBinding3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedRoleBinding3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedRoleBinding3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedRoleBinding3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedRoleBinding3 MimeAny

-- | @application/json@
instance Produces ListNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedRoleBinding3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedRoleBinding3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedRoleBinding3 MimeVndKubernetesProtobufstreamwatch


-- *** listRoleBindingForAllNamespaces3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/rolebindings@
-- 
-- list or watch objects of kind RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listRoleBindingForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListRoleBindingForAllNamespaces3 MimeNoContent V1beta1RoleBindingList accept
listRoleBindingForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/rolebindings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListRoleBindingForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListRoleBindingForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListRoleBindingForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListRoleBindingForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListRoleBindingForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListRoleBindingForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListRoleBindingForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListRoleBindingForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** listRoleForAllNamespaces3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/roles@
-- 
-- list or watch objects of kind Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listRoleForAllNamespaces3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListRoleForAllNamespaces3 MimeNoContent V1beta1RoleList accept
listRoleForAllNamespaces3  _ =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListRoleForAllNamespaces3  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListRoleForAllNamespaces3 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListRoleForAllNamespaces3 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListRoleForAllNamespaces3 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListRoleForAllNamespaces3 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListRoleForAllNamespaces3 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListRoleForAllNamespaces3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListRoleForAllNamespaces3 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListRoleForAllNamespaces3 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListRoleForAllNamespaces3 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListRoleForAllNamespaces3 MimeAny

-- | @application/json@
instance Produces ListRoleForAllNamespaces3 MimeJSON
-- | @application/yaml@
instance Produces ListRoleForAllNamespaces3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListRoleForAllNamespaces3 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListRoleForAllNamespaces3 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListRoleForAllNamespaces3 MimeVndKubernetesProtobufstreamwatch


-- *** patchClusterRole3

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles\/{name}@
-- 
-- partially update the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchClusterRole3 
  :: (Consumes PatchClusterRole3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchClusterRole3 contentType V1beta1ClusterRole accept
patchClusterRole3 _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchClusterRole3 
instance HasBodyParam PatchClusterRole3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchClusterRole3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchClusterRole3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchClusterRole3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces PatchClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchClusterRole3 MimeVndKubernetesProtobuf


-- *** patchClusterRoleBinding3

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings\/{name}@
-- 
-- partially update the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchClusterRoleBinding3 
  :: (Consumes PatchClusterRoleBinding3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchClusterRoleBinding3 contentType V1beta1ClusterRoleBinding accept
patchClusterRoleBinding3 _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchClusterRoleBinding3 
instance HasBodyParam PatchClusterRoleBinding3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchClusterRoleBinding3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchClusterRoleBinding3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchClusterRoleBinding3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces PatchClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchClusterRoleBinding3 MimeVndKubernetesProtobuf


-- *** patchNamespacedRole3

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- partially update the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedRole3 
  :: (Consumes PatchNamespacedRole3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedRole3 contentType V1beta1Role accept
patchNamespacedRole3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedRole3 
instance HasBodyParam PatchNamespacedRole3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedRole3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedRole3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedRole3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedRole3 MimeVndKubernetesProtobuf


-- *** patchNamespacedRoleBinding3

-- | @PATCH \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- partially update the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedRoleBinding3 
  :: (Consumes PatchNamespacedRoleBinding3 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedRoleBinding3 contentType V1beta1RoleBinding accept
patchNamespacedRoleBinding3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedRoleBinding3 
instance HasBodyParam PatchNamespacedRoleBinding3 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedRoleBinding3 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedRoleBinding3 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedRoleBinding3 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedRoleBinding3 MimeVndKubernetesProtobuf


-- *** readClusterRole3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles\/{name}@
-- 
-- read the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readClusterRole3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> KubernetesRequest ReadClusterRole3 MimeNoContent V1beta1ClusterRole accept
readClusterRole3  _ (Name name) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadClusterRole3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadClusterRole3 MimeAny

-- | @application/json@
instance Produces ReadClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces ReadClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadClusterRole3 MimeVndKubernetesProtobuf


-- *** readClusterRoleBinding3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings\/{name}@
-- 
-- read the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readClusterRoleBinding3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> KubernetesRequest ReadClusterRoleBinding3 MimeNoContent V1beta1ClusterRoleBinding accept
readClusterRoleBinding3  _ (Name name) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadClusterRoleBinding3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadClusterRoleBinding3 MimeAny

-- | @application/json@
instance Produces ReadClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces ReadClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadClusterRoleBinding3 MimeVndKubernetesProtobuf


-- *** readNamespacedRole3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- read the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedRole3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedRole3 MimeNoContent V1beta1Role accept
readNamespacedRole3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedRole3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedRole3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedRole3 MimeVndKubernetesProtobuf


-- *** readNamespacedRoleBinding3

-- | @GET \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- read the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedRoleBinding3 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedRoleBinding3 MimeNoContent V1beta1RoleBinding accept
readNamespacedRoleBinding3  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedRoleBinding3  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedRoleBinding3 MimeAny

-- | @application/json@
instance Produces ReadNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedRoleBinding3 MimeVndKubernetesProtobuf


-- *** replaceClusterRole3

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterroles\/{name}@
-- 
-- replace the specified ClusterRole
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterRole3 
  :: (Consumes ReplaceClusterRole3 contentType, MimeRender contentType V1beta1ClusterRole)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRole
  -> V1beta1ClusterRole -- ^ "body"
  -> KubernetesRequest ReplaceClusterRole3 contentType V1beta1ClusterRole accept
replaceClusterRole3 _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterRole3 
instance HasBodyParam ReplaceClusterRole3 V1beta1ClusterRole 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceClusterRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceClusterRole3 MimeAny

-- | @application/json@
instance Produces ReplaceClusterRole3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceClusterRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceClusterRole3 MimeVndKubernetesProtobuf


-- *** replaceClusterRoleBinding3

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1beta1\/clusterrolebindings\/{name}@
-- 
-- replace the specified ClusterRoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceClusterRoleBinding3 
  :: (Consumes ReplaceClusterRoleBinding3 contentType, MimeRender contentType V1beta1ClusterRoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ClusterRoleBinding
  -> V1beta1ClusterRoleBinding -- ^ "body"
  -> KubernetesRequest ReplaceClusterRoleBinding3 contentType V1beta1ClusterRoleBinding accept
replaceClusterRoleBinding3 _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceClusterRoleBinding3 
instance HasBodyParam ReplaceClusterRoleBinding3 V1beta1ClusterRoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceClusterRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceClusterRoleBinding3 MimeAny

-- | @application/json@
instance Produces ReplaceClusterRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceClusterRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceClusterRoleBinding3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedRole3

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/roles\/{name}@
-- 
-- replace the specified Role
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedRole3 
  :: (Consumes ReplaceNamespacedRole3 contentType, MimeRender contentType V1beta1Role)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the Role
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1Role -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedRole3 contentType V1beta1Role accept
replaceNamespacedRole3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/roles/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedRole3 
instance HasBodyParam ReplaceNamespacedRole3 V1beta1Role 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedRole3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedRole3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedRole3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedRole3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedRole3 MimeVndKubernetesProtobuf


-- *** replaceNamespacedRoleBinding3

-- | @PUT \/apis\/rbac.authorization.k8s.io\/v1beta1\/namespaces\/{namespace}\/rolebindings\/{name}@
-- 
-- replace the specified RoleBinding
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedRoleBinding3 
  :: (Consumes ReplaceNamespacedRoleBinding3 contentType, MimeRender contentType V1beta1RoleBinding)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the RoleBinding
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1beta1RoleBinding -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedRoleBinding3 contentType V1beta1RoleBinding accept
replaceNamespacedRoleBinding3 _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/rbac.authorization.k8s.io/v1beta1/namespaces/",toPath namespace,"/rolebindings/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedRoleBinding3 
instance HasBodyParam ReplaceNamespacedRoleBinding3 V1beta1RoleBinding 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedRoleBinding3 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedRoleBinding3 MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedRoleBinding3 MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedRoleBinding3 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedRoleBinding3 MimeVndKubernetesProtobuf


-- ** Scheduling

-- *** getAPIGroup15

-- | @GET \/apis\/scheduling.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup15 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup15 MimeNoContent V1APIGroup accept
getAPIGroup15  _ =
  _mkRequest "GET" ["/apis/scheduling.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup15  

-- | @application/json@
instance Consumes GetAPIGroup15 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup15 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup15 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup15 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup15 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup15 MimeVndKubernetesProtobuf


-- ** SchedulingV1alpha1

-- *** createPriorityClass

-- | @POST \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses@
-- 
-- create a PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createPriorityClass 
  :: (Consumes CreatePriorityClass contentType, MimeRender contentType V1alpha1PriorityClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha1PriorityClass -- ^ "body"
  -> KubernetesRequest CreatePriorityClass contentType V1alpha1PriorityClass accept
createPriorityClass _  _ body =
  _mkRequest "POST" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreatePriorityClass 
instance HasBodyParam CreatePriorityClass V1alpha1PriorityClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreatePriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreatePriorityClass MimeAny

-- | @application/json@
instance Produces CreatePriorityClass MimeJSON
-- | @application/yaml@
instance Produces CreatePriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreatePriorityClass MimeVndKubernetesProtobuf


-- *** deleteCollectionPriorityClass

-- | @DELETE \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses@
-- 
-- delete collection of PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionPriorityClass 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionPriorityClass MimeNoContent V1Status accept
deleteCollectionPriorityClass  _ =
  _mkRequest "DELETE" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionPriorityClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionPriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionPriorityClass Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionPriorityClass FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionPriorityClass IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionPriorityClass LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionPriorityClass Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionPriorityClass ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionPriorityClass TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionPriorityClass Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionPriorityClass MimeAny

-- | @application/json@
instance Produces DeleteCollectionPriorityClass MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionPriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionPriorityClass MimeVndKubernetesProtobuf


-- *** deletePriorityClass

-- | @DELETE \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses\/{name}@
-- 
-- delete a PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deletePriorityClass 
  :: (Consumes DeletePriorityClass contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PriorityClass
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeletePriorityClass contentType V1Status accept
deletePriorityClass _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeletePriorityClass 
instance HasBodyParam DeletePriorityClass V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeletePriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeletePriorityClass GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeletePriorityClass OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeletePriorityClass PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeletePriorityClass MimeAny

-- | @application/json@
instance Produces DeletePriorityClass MimeJSON
-- | @application/yaml@
instance Produces DeletePriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeletePriorityClass MimeVndKubernetesProtobuf


-- *** getAPIResources26

-- | @GET \/apis\/scheduling.k8s.io\/v1alpha1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources26 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources26 MimeNoContent V1APIResourceList accept
getAPIResources26  _ =
  _mkRequest "GET" ["/apis/scheduling.k8s.io/v1alpha1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources26  

-- | @application/json@
instance Consumes GetAPIResources26 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources26 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources26 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources26 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources26 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources26 MimeVndKubernetesProtobuf


-- *** listPriorityClass

-- | @GET \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses@
-- 
-- list or watch objects of kind PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPriorityClass 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPriorityClass MimeNoContent V1alpha1PriorityClassList accept
listPriorityClass  _ =
  _mkRequest "GET" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPriorityClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPriorityClass Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPriorityClass FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPriorityClass IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPriorityClass LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPriorityClass Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPriorityClass ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPriorityClass TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPriorityClass Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPriorityClass MimeAny

-- | @application/json@
instance Produces ListPriorityClass MimeJSON
-- | @application/yaml@
instance Produces ListPriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPriorityClass MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPriorityClass MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPriorityClass MimeVndKubernetesProtobufstreamwatch


-- *** patchPriorityClass

-- | @PATCH \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses\/{name}@
-- 
-- partially update the specified PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchPriorityClass 
  :: (Consumes PatchPriorityClass contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PriorityClass
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchPriorityClass contentType V1alpha1PriorityClass accept
patchPriorityClass _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchPriorityClass 
instance HasBodyParam PatchPriorityClass A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchPriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchPriorityClass MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchPriorityClass MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchPriorityClass MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchPriorityClass MimeJSON
-- | @application/yaml@
instance Produces PatchPriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchPriorityClass MimeVndKubernetesProtobuf


-- *** readPriorityClass

-- | @GET \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses\/{name}@
-- 
-- read the specified PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readPriorityClass 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PriorityClass
  -> KubernetesRequest ReadPriorityClass MimeNoContent V1alpha1PriorityClass accept
readPriorityClass  _ (Name name) =
  _mkRequest "GET" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadPriorityClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadPriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadPriorityClass Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadPriorityClass Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadPriorityClass MimeAny

-- | @application/json@
instance Produces ReadPriorityClass MimeJSON
-- | @application/yaml@
instance Produces ReadPriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadPriorityClass MimeVndKubernetesProtobuf


-- *** replacePriorityClass

-- | @PUT \/apis\/scheduling.k8s.io\/v1alpha1\/priorityclasses\/{name}@
-- 
-- replace the specified PriorityClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replacePriorityClass 
  :: (Consumes ReplacePriorityClass contentType, MimeRender contentType V1alpha1PriorityClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PriorityClass
  -> V1alpha1PriorityClass -- ^ "body"
  -> KubernetesRequest ReplacePriorityClass contentType V1alpha1PriorityClass accept
replacePriorityClass _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/scheduling.k8s.io/v1alpha1/priorityclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplacePriorityClass 
instance HasBodyParam ReplacePriorityClass V1alpha1PriorityClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplacePriorityClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplacePriorityClass MimeAny

-- | @application/json@
instance Produces ReplacePriorityClass MimeJSON
-- | @application/yaml@
instance Produces ReplacePriorityClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplacePriorityClass MimeVndKubernetesProtobuf


-- ** Settings

-- *** getAPIGroup16

-- | @GET \/apis\/settings.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup16 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup16 MimeNoContent V1APIGroup accept
getAPIGroup16  _ =
  _mkRequest "GET" ["/apis/settings.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup16  

-- | @application/json@
instance Consumes GetAPIGroup16 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup16 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup16 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup16 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup16 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup16 MimeVndKubernetesProtobuf


-- ** SettingsV1alpha1

-- *** createNamespacedPodPreset

-- | @POST \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets@
-- 
-- create a PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPodPreset 
  :: (Consumes CreateNamespacedPodPreset contentType, MimeRender contentType V1alpha1PodPreset)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1alpha1PodPreset -- ^ "body"
  -> KubernetesRequest CreateNamespacedPodPreset contentType V1alpha1PodPreset accept
createNamespacedPodPreset _  _ (Namespace namespace) body =
  _mkRequest "POST" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPodPreset 
instance HasBodyParam CreateNamespacedPodPreset V1alpha1PodPreset 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateNamespacedPodPreset MimeAny

-- | @application/json@
instance Produces CreateNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces CreateNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPodPreset MimeVndKubernetesProtobuf


-- *** deleteCollectionNamespacedPodPreset

-- | @DELETE \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets@
-- 
-- delete collection of PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedPodPreset 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedPodPreset MimeNoContent V1Status accept
deleteCollectionNamespacedPodPreset  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedPodPreset  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionNamespacedPodPreset Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionNamespacedPodPreset MimeAny

-- | @application/json@
instance Produces DeleteCollectionNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedPodPreset MimeVndKubernetesProtobuf


-- *** deleteNamespacedPodPreset

-- | @DELETE \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets\/{name}@
-- 
-- delete a PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedPodPreset 
  :: (Consumes DeleteNamespacedPodPreset contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodPreset
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteNamespacedPodPreset contentType V1Status accept
deleteNamespacedPodPreset _  _ (Name name) (Namespace namespace) body =
  _mkRequest "DELETE" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteNamespacedPodPreset 
instance HasBodyParam DeleteNamespacedPodPreset V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedPodPreset GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedPodPreset OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedPodPreset PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteNamespacedPodPreset MimeAny

-- | @application/json@
instance Produces DeleteNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces DeleteNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedPodPreset MimeVndKubernetesProtobuf


-- *** getAPIResources27

-- | @GET \/apis\/settings.k8s.io\/v1alpha1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources27 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources27 MimeNoContent V1APIResourceList accept
getAPIResources27  _ =
  _mkRequest "GET" ["/apis/settings.k8s.io/v1alpha1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources27  

-- | @application/json@
instance Consumes GetAPIResources27 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources27 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources27 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources27 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources27 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources27 MimeVndKubernetesProtobuf


-- *** listNamespacedPodPreset

-- | @GET \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets@
-- 
-- list or watch objects of kind PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedPodPreset 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedPodPreset MimeNoContent V1alpha1PodPresetList accept
listNamespacedPodPreset  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedPodPreset  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedPodPreset Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedPodPreset FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListNamespacedPodPreset IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedPodPreset LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedPodPreset Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListNamespacedPodPreset ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListNamespacedPodPreset TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedPodPreset Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListNamespacedPodPreset MimeAny

-- | @application/json@
instance Produces ListNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces ListNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedPodPreset MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListNamespacedPodPreset MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedPodPreset MimeVndKubernetesProtobufstreamwatch


-- *** listPodPresetForAllNamespaces

-- | @GET \/apis\/settings.k8s.io\/v1alpha1\/podpresets@
-- 
-- list or watch objects of kind PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodPresetForAllNamespaces 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodPresetForAllNamespaces MimeNoContent V1alpha1PodPresetList accept
listPodPresetForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/settings.k8s.io/v1alpha1/podpresets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodPresetForAllNamespaces  

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodPresetForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodPresetForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListPodPresetForAllNamespaces IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodPresetForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodPresetForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodPresetForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListPodPresetForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListPodPresetForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodPresetForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListPodPresetForAllNamespaces MimeAny

-- | @application/json@
instance Produces ListPodPresetForAllNamespaces MimeJSON
-- | @application/yaml@
instance Produces ListPodPresetForAllNamespaces MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodPresetForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListPodPresetForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodPresetForAllNamespaces MimeVndKubernetesProtobufstreamwatch


-- *** patchNamespacedPodPreset

-- | @PATCH \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets\/{name}@
-- 
-- partially update the specified PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodPreset 
  :: (Consumes PatchNamespacedPodPreset contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodPreset
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchNamespacedPodPreset contentType V1alpha1PodPreset accept
patchNamespacedPodPreset _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PATCH" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodPreset 
instance HasBodyParam PatchNamespacedPodPreset A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodPreset MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodPreset MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodPreset MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces PatchNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodPreset MimeVndKubernetesProtobuf


-- *** readNamespacedPodPreset

-- | @GET \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets\/{name}@
-- 
-- read the specified PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodPreset 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodPreset
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodPreset MimeNoContent V1alpha1PodPreset accept
readNamespacedPodPreset  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodPreset  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadNamespacedPodPreset Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadNamespacedPodPreset Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadNamespacedPodPreset MimeAny

-- | @application/json@
instance Produces ReadNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces ReadNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodPreset MimeVndKubernetesProtobuf


-- *** replaceNamespacedPodPreset

-- | @PUT \/apis\/settings.k8s.io\/v1alpha1\/namespaces\/{namespace}\/podpresets\/{name}@
-- 
-- replace the specified PodPreset
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodPreset 
  :: (Consumes ReplaceNamespacedPodPreset contentType, MimeRender contentType V1alpha1PodPreset)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodPreset
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> V1alpha1PodPreset -- ^ "body"
  -> KubernetesRequest ReplaceNamespacedPodPreset contentType V1alpha1PodPreset accept
replaceNamespacedPodPreset _  _ (Name name) (Namespace namespace) body =
  _mkRequest "PUT" ["/apis/settings.k8s.io/v1alpha1/namespaces/",toPath namespace,"/podpresets/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodPreset 
instance HasBodyParam ReplaceNamespacedPodPreset V1alpha1PodPreset 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodPreset Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceNamespacedPodPreset MimeAny

-- | @application/json@
instance Produces ReplaceNamespacedPodPreset MimeJSON
-- | @application/yaml@
instance Produces ReplaceNamespacedPodPreset MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodPreset MimeVndKubernetesProtobuf


-- ** Storage

-- *** getAPIGroup17

-- | @GET \/apis\/storage.k8s.io\/@
-- 
-- get information of a group
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIGroup17 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIGroup17 MimeNoContent V1APIGroup accept
getAPIGroup17  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIGroup17  

-- | @application/json@
instance Consumes GetAPIGroup17 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIGroup17 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIGroup17 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIGroup17 MimeJSON
-- | @application/yaml@
instance Produces GetAPIGroup17 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIGroup17 MimeVndKubernetesProtobuf


-- ** StorageV1

-- *** createStorageClass

-- | @POST \/apis\/storage.k8s.io\/v1\/storageclasses@
-- 
-- create a StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createStorageClass 
  :: (Consumes CreateStorageClass contentType, MimeRender contentType V1StorageClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1StorageClass -- ^ "body"
  -> KubernetesRequest CreateStorageClass contentType V1StorageClass accept
createStorageClass _  _ body =
  _mkRequest "POST" ["/apis/storage.k8s.io/v1/storageclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateStorageClass 
instance HasBodyParam CreateStorageClass V1StorageClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateStorageClass MimeAny

-- | @application/json@
instance Produces CreateStorageClass MimeJSON
-- | @application/yaml@
instance Produces CreateStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateStorageClass MimeVndKubernetesProtobuf


-- *** deleteCollectionStorageClass

-- | @DELETE \/apis\/storage.k8s.io\/v1\/storageclasses@
-- 
-- delete collection of StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionStorageClass 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionStorageClass MimeNoContent V1Status accept
deleteCollectionStorageClass  _ =
  _mkRequest "DELETE" ["/apis/storage.k8s.io/v1/storageclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionStorageClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionStorageClass Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionStorageClass FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionStorageClass IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionStorageClass LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionStorageClass Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionStorageClass ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionStorageClass TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionStorageClass Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionStorageClass MimeAny

-- | @application/json@
instance Produces DeleteCollectionStorageClass MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionStorageClass MimeVndKubernetesProtobuf


-- *** deleteStorageClass

-- | @DELETE \/apis\/storage.k8s.io\/v1\/storageclasses\/{name}@
-- 
-- delete a StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteStorageClass 
  :: (Consumes DeleteStorageClass contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteStorageClass contentType V1Status accept
deleteStorageClass _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/storage.k8s.io/v1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteStorageClass 
instance HasBodyParam DeleteStorageClass V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteStorageClass GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteStorageClass OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteStorageClass PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteStorageClass MimeAny

-- | @application/json@
instance Produces DeleteStorageClass MimeJSON
-- | @application/yaml@
instance Produces DeleteStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteStorageClass MimeVndKubernetesProtobuf


-- *** getAPIResources28

-- | @GET \/apis\/storage.k8s.io\/v1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources28 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources28 MimeNoContent V1APIResourceList accept
getAPIResources28  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources28  

-- | @application/json@
instance Consumes GetAPIResources28 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources28 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources28 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources28 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources28 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources28 MimeVndKubernetesProtobuf


-- *** listStorageClass

-- | @GET \/apis\/storage.k8s.io\/v1\/storageclasses@
-- 
-- list or watch objects of kind StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listStorageClass 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListStorageClass MimeNoContent V1StorageClassList accept
listStorageClass  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1/storageclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListStorageClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListStorageClass Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListStorageClass FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListStorageClass IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListStorageClass LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListStorageClass Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListStorageClass ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListStorageClass TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListStorageClass Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListStorageClass MimeAny

-- | @application/json@
instance Produces ListStorageClass MimeJSON
-- | @application/yaml@
instance Produces ListStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListStorageClass MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListStorageClass MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListStorageClass MimeVndKubernetesProtobufstreamwatch


-- *** patchStorageClass

-- | @PATCH \/apis\/storage.k8s.io\/v1\/storageclasses\/{name}@
-- 
-- partially update the specified StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchStorageClass 
  :: (Consumes PatchStorageClass contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchStorageClass contentType V1StorageClass accept
patchStorageClass _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/storage.k8s.io/v1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchStorageClass 
instance HasBodyParam PatchStorageClass A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchStorageClass MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchStorageClass MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchStorageClass MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchStorageClass MimeJSON
-- | @application/yaml@
instance Produces PatchStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchStorageClass MimeVndKubernetesProtobuf


-- *** readStorageClass

-- | @GET \/apis\/storage.k8s.io\/v1\/storageclasses\/{name}@
-- 
-- read the specified StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readStorageClass 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> KubernetesRequest ReadStorageClass MimeNoContent V1StorageClass accept
readStorageClass  _ (Name name) =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadStorageClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadStorageClass Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadStorageClass Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadStorageClass MimeAny

-- | @application/json@
instance Produces ReadStorageClass MimeJSON
-- | @application/yaml@
instance Produces ReadStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadStorageClass MimeVndKubernetesProtobuf


-- *** replaceStorageClass

-- | @PUT \/apis\/storage.k8s.io\/v1\/storageclasses\/{name}@
-- 
-- replace the specified StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceStorageClass 
  :: (Consumes ReplaceStorageClass contentType, MimeRender contentType V1StorageClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> V1StorageClass -- ^ "body"
  -> KubernetesRequest ReplaceStorageClass contentType V1StorageClass accept
replaceStorageClass _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/storage.k8s.io/v1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceStorageClass 
instance HasBodyParam ReplaceStorageClass V1StorageClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceStorageClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceStorageClass MimeAny

-- | @application/json@
instance Produces ReplaceStorageClass MimeJSON
-- | @application/yaml@
instance Produces ReplaceStorageClass MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceStorageClass MimeVndKubernetesProtobuf


-- ** StorageV1alpha1

-- *** createVolumeAttachment

-- | @POST \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments@
-- 
-- create a VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createVolumeAttachment 
  :: (Consumes CreateVolumeAttachment contentType, MimeRender contentType V1alpha1VolumeAttachment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha1VolumeAttachment -- ^ "body"
  -> KubernetesRequest CreateVolumeAttachment contentType V1alpha1VolumeAttachment accept
createVolumeAttachment _  _ body =
  _mkRequest "POST" ["/apis/storage.k8s.io/v1alpha1/volumeattachments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateVolumeAttachment 
instance HasBodyParam CreateVolumeAttachment V1alpha1VolumeAttachment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateVolumeAttachment MimeAny

-- | @application/json@
instance Produces CreateVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces CreateVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateVolumeAttachment MimeVndKubernetesProtobuf


-- *** deleteCollectionVolumeAttachment

-- | @DELETE \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments@
-- 
-- delete collection of VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionVolumeAttachment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionVolumeAttachment MimeNoContent V1Status accept
deleteCollectionVolumeAttachment  _ =
  _mkRequest "DELETE" ["/apis/storage.k8s.io/v1alpha1/volumeattachments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionVolumeAttachment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionVolumeAttachment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionVolumeAttachment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionVolumeAttachment IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionVolumeAttachment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionVolumeAttachment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionVolumeAttachment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionVolumeAttachment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionVolumeAttachment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionVolumeAttachment MimeAny

-- | @application/json@
instance Produces DeleteCollectionVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionVolumeAttachment MimeVndKubernetesProtobuf


-- *** deleteVolumeAttachment

-- | @DELETE \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments\/{name}@
-- 
-- delete a VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteVolumeAttachment 
  :: (Consumes DeleteVolumeAttachment contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the VolumeAttachment
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteVolumeAttachment contentType V1Status accept
deleteVolumeAttachment _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/storage.k8s.io/v1alpha1/volumeattachments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteVolumeAttachment 
instance HasBodyParam DeleteVolumeAttachment V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteVolumeAttachment GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteVolumeAttachment OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteVolumeAttachment PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteVolumeAttachment MimeAny

-- | @application/json@
instance Produces DeleteVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces DeleteVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteVolumeAttachment MimeVndKubernetesProtobuf


-- *** getAPIResources29

-- | @GET \/apis\/storage.k8s.io\/v1alpha1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources29 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources29 MimeNoContent V1APIResourceList accept
getAPIResources29  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1alpha1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources29  

-- | @application/json@
instance Consumes GetAPIResources29 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources29 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources29 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources29 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources29 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources29 MimeVndKubernetesProtobuf


-- *** listVolumeAttachment

-- | @GET \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments@
-- 
-- list or watch objects of kind VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listVolumeAttachment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListVolumeAttachment MimeNoContent V1alpha1VolumeAttachmentList accept
listVolumeAttachment  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1alpha1/volumeattachments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListVolumeAttachment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListVolumeAttachment Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListVolumeAttachment FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListVolumeAttachment IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListVolumeAttachment LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListVolumeAttachment Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListVolumeAttachment ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListVolumeAttachment TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListVolumeAttachment Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListVolumeAttachment MimeAny

-- | @application/json@
instance Produces ListVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces ListVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListVolumeAttachment MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListVolumeAttachment MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListVolumeAttachment MimeVndKubernetesProtobufstreamwatch


-- *** patchVolumeAttachment

-- | @PATCH \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments\/{name}@
-- 
-- partially update the specified VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchVolumeAttachment 
  :: (Consumes PatchVolumeAttachment contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the VolumeAttachment
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchVolumeAttachment contentType V1alpha1VolumeAttachment accept
patchVolumeAttachment _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/storage.k8s.io/v1alpha1/volumeattachments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchVolumeAttachment 
instance HasBodyParam PatchVolumeAttachment A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchVolumeAttachment MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchVolumeAttachment MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchVolumeAttachment MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces PatchVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchVolumeAttachment MimeVndKubernetesProtobuf


-- *** readVolumeAttachment

-- | @GET \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments\/{name}@
-- 
-- read the specified VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readVolumeAttachment 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the VolumeAttachment
  -> KubernetesRequest ReadVolumeAttachment MimeNoContent V1alpha1VolumeAttachment accept
readVolumeAttachment  _ (Name name) =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1alpha1/volumeattachments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadVolumeAttachment  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadVolumeAttachment Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadVolumeAttachment Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadVolumeAttachment MimeAny

-- | @application/json@
instance Produces ReadVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces ReadVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadVolumeAttachment MimeVndKubernetesProtobuf


-- *** replaceVolumeAttachment

-- | @PUT \/apis\/storage.k8s.io\/v1alpha1\/volumeattachments\/{name}@
-- 
-- replace the specified VolumeAttachment
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceVolumeAttachment 
  :: (Consumes ReplaceVolumeAttachment contentType, MimeRender contentType V1alpha1VolumeAttachment)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the VolumeAttachment
  -> V1alpha1VolumeAttachment -- ^ "body"
  -> KubernetesRequest ReplaceVolumeAttachment contentType V1alpha1VolumeAttachment accept
replaceVolumeAttachment _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/storage.k8s.io/v1alpha1/volumeattachments/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceVolumeAttachment 
instance HasBodyParam ReplaceVolumeAttachment V1alpha1VolumeAttachment 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceVolumeAttachment Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceVolumeAttachment MimeAny

-- | @application/json@
instance Produces ReplaceVolumeAttachment MimeJSON
-- | @application/yaml@
instance Produces ReplaceVolumeAttachment MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceVolumeAttachment MimeVndKubernetesProtobuf


-- ** StorageV1beta1

-- *** createStorageClass2

-- | @POST \/apis\/storage.k8s.io\/v1beta1\/storageclasses@
-- 
-- create a StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createStorageClass2 
  :: (Consumes CreateStorageClass2 contentType, MimeRender contentType V1beta1StorageClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1beta1StorageClass -- ^ "body"
  -> KubernetesRequest CreateStorageClass2 contentType V1beta1StorageClass accept
createStorageClass2 _  _ body =
  _mkRequest "POST" ["/apis/storage.k8s.io/v1beta1/storageclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateStorageClass2 
instance HasBodyParam CreateStorageClass2 V1beta1StorageClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes CreateStorageClass2 MimeAny

-- | @application/json@
instance Produces CreateStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces CreateStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateStorageClass2 MimeVndKubernetesProtobuf


-- *** deleteCollectionStorageClass2

-- | @DELETE \/apis\/storage.k8s.io\/v1beta1\/storageclasses@
-- 
-- delete collection of StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionStorageClass2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionStorageClass2 MimeNoContent V1Status accept
deleteCollectionStorageClass2  _ =
  _mkRequest "DELETE" ["/apis/storage.k8s.io/v1beta1/storageclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionStorageClass2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionStorageClass2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionStorageClass2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam DeleteCollectionStorageClass2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionStorageClass2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionStorageClass2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam DeleteCollectionStorageClass2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam DeleteCollectionStorageClass2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam DeleteCollectionStorageClass2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes DeleteCollectionStorageClass2 MimeAny

-- | @application/json@
instance Produces DeleteCollectionStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces DeleteCollectionStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionStorageClass2 MimeVndKubernetesProtobuf


-- *** deleteStorageClass2

-- | @DELETE \/apis\/storage.k8s.io\/v1beta1\/storageclasses\/{name}@
-- 
-- delete a StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteStorageClass2 
  :: (Consumes DeleteStorageClass2 contentType, MimeRender contentType V1DeleteOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> V1DeleteOptions -- ^ "body"
  -> KubernetesRequest DeleteStorageClass2 contentType V1Status accept
deleteStorageClass2 _  _ (Name name) body =
  _mkRequest "DELETE" ["/apis/storage.k8s.io/v1beta1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data DeleteStorageClass2 
instance HasBodyParam DeleteStorageClass2 V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteStorageClass2 GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `setQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteStorageClass2 OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `setQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteStorageClass2 PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `setQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance Consumes DeleteStorageClass2 MimeAny

-- | @application/json@
instance Produces DeleteStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces DeleteStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteStorageClass2 MimeVndKubernetesProtobuf


-- *** getAPIResources30

-- | @GET \/apis\/storage.k8s.io\/v1beta1\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources30 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources30 MimeNoContent V1APIResourceList accept
getAPIResources30  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1beta1/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources30  

-- | @application/json@
instance Consumes GetAPIResources30 MimeJSON
-- | @application/yaml@
instance Consumes GetAPIResources30 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Consumes GetAPIResources30 MimeVndKubernetesProtobuf

-- | @application/json@
instance Produces GetAPIResources30 MimeJSON
-- | @application/yaml@
instance Produces GetAPIResources30 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources30 MimeVndKubernetesProtobuf


-- *** listStorageClass2

-- | @GET \/apis\/storage.k8s.io\/v1beta1\/storageclasses@
-- 
-- list or watch objects of kind StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listStorageClass2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListStorageClass2 MimeNoContent V1beta1StorageClassList accept
listStorageClass2  _ =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1beta1/storageclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListStorageClass2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListStorageClass2 Continue where
  applyOptionalParam req (Continue xs) =
    req `setQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListStorageClass2 FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `setQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "includeUninitialized" - If true, partially initialized resources are included in the response.
instance HasOptionalParam ListStorageClass2 IncludeUninitialized where
  applyOptionalParam req (IncludeUninitialized xs) =
    req `setQuery` toQuery ("includeUninitialized", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListStorageClass2 LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `setQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListStorageClass2 Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
instance HasOptionalParam ListStorageClass2 ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `setQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call.
instance HasOptionalParam ListStorageClass2 TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `setQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListStorageClass2 Watch where
  applyOptionalParam req (Watch xs) =
    req `setQuery` toQuery ("watch", Just xs)

-- | @*/*@
instance Consumes ListStorageClass2 MimeAny

-- | @application/json@
instance Produces ListStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces ListStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListStorageClass2 MimeVndKubernetesProtobuf
-- | @application/json;stream=watch@
instance Produces ListStorageClass2 MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListStorageClass2 MimeVndKubernetesProtobufstreamwatch


-- *** patchStorageClass2

-- | @PATCH \/apis\/storage.k8s.io\/v1beta1\/storageclasses\/{name}@
-- 
-- partially update the specified StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchStorageClass2 
  :: (Consumes PatchStorageClass2 contentType, MimeRender contentType A.Value)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> A.Value -- ^ "body"
  -> KubernetesRequest PatchStorageClass2 contentType V1beta1StorageClass accept
patchStorageClass2 _  _ (Name name) body =
  _mkRequest "PATCH" ["/apis/storage.k8s.io/v1beta1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchStorageClass2 
instance HasBodyParam PatchStorageClass2 A.Value 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @application/json-patch+json@
instance Consumes PatchStorageClass2 MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchStorageClass2 MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchStorageClass2 MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces PatchStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchStorageClass2 MimeVndKubernetesProtobuf


-- *** readStorageClass2

-- | @GET \/apis\/storage.k8s.io\/v1beta1\/storageclasses\/{name}@
-- 
-- read the specified StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readStorageClass2 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> KubernetesRequest ReadStorageClass2 MimeNoContent V1beta1StorageClass accept
readStorageClass2  _ (Name name) =
  _mkRequest "GET" ["/apis/storage.k8s.io/v1beta1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadStorageClass2  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "exact" - Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
instance HasOptionalParam ReadStorageClass2 Exact where
  applyOptionalParam req (Exact xs) =
    req `setQuery` toQuery ("exact", Just xs)

-- | /Optional Param/ "export" - Should this value be exported.  Export strips fields that a user can not specify.
instance HasOptionalParam ReadStorageClass2 Export where
  applyOptionalParam req (Export xs) =
    req `setQuery` toQuery ("export", Just xs)

-- | @*/*@
instance Consumes ReadStorageClass2 MimeAny

-- | @application/json@
instance Produces ReadStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces ReadStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadStorageClass2 MimeVndKubernetesProtobuf


-- *** replaceStorageClass2

-- | @PUT \/apis\/storage.k8s.io\/v1beta1\/storageclasses\/{name}@
-- 
-- replace the specified StorageClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceStorageClass2 
  :: (Consumes ReplaceStorageClass2 contentType, MimeRender contentType V1beta1StorageClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the StorageClass
  -> V1beta1StorageClass -- ^ "body"
  -> KubernetesRequest ReplaceStorageClass2 contentType V1beta1StorageClass accept
replaceStorageClass2 _  _ (Name name) body =
  _mkRequest "PUT" ["/apis/storage.k8s.io/v1beta1/storageclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceStorageClass2 
instance HasBodyParam ReplaceStorageClass2 V1beta1StorageClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceStorageClass2 Pretty where
  applyOptionalParam req (Pretty xs) =
    req `setQuery` toQuery ("pretty", Just xs)

-- | @*/*@
instance Consumes ReplaceStorageClass2 MimeAny

-- | @application/json@
instance Produces ReplaceStorageClass2 MimeJSON
-- | @application/yaml@
instance Produces ReplaceStorageClass2 MimeYaml
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceStorageClass2 MimeVndKubernetesProtobuf


-- ** Version

-- *** getCode

-- | @GET \/version\/@
-- 
-- get the code version
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getCode 
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetCode MimeNoContent VersionInfo accept
getCode  _ =
  _mkRequest "GET" ["/version/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetCode  

-- | @application/json@
instance Consumes GetCode MimeJSON

-- | @application/json@
instance Produces GetCode MimeJSON



-- * Parameter newtypes

newtype Command = Command { unCommand :: Text } deriving (P.Eq, P.Show)
newtype Container = Container { unContainer :: Text } deriving (P.Eq, P.Show)
newtype Continue = Continue { unContinue :: Text } deriving (P.Eq, P.Show)
newtype Exact = Exact { unExact :: Bool } deriving (P.Eq, P.Show)
newtype Export = Export { unExport :: Bool } deriving (P.Eq, P.Show)
newtype FieldSelector = FieldSelector { unFieldSelector :: Text } deriving (P.Eq, P.Show)
newtype Follow = Follow { unFollow :: Bool } deriving (P.Eq, P.Show)
newtype GracePeriodSeconds = GracePeriodSeconds { unGracePeriodSeconds :: Int } deriving (P.Eq, P.Show)
newtype Group = Group { unGroup :: Text } deriving (P.Eq, P.Show)
newtype IncludeUninitialized = IncludeUninitialized { unIncludeUninitialized :: Bool } deriving (P.Eq, P.Show)
newtype LabelSelector = LabelSelector { unLabelSelector :: Text } deriving (P.Eq, P.Show)
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)
newtype LimitBytes = LimitBytes { unLimitBytes :: Int } deriving (P.Eq, P.Show)
newtype Logpath = Logpath { unLogpath :: Text } deriving (P.Eq, P.Show)
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)
newtype Namespace = Namespace { unNamespace :: Text } deriving (P.Eq, P.Show)
newtype OrphanDependents = OrphanDependents { unOrphanDependents :: Bool } deriving (P.Eq, P.Show)
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)
newtype Path2 = Path2 { unPath2 :: Text } deriving (P.Eq, P.Show)
newtype Plural = Plural { unPlural :: Text } deriving (P.Eq, P.Show)
newtype Ports = Ports { unPorts :: Int } deriving (P.Eq, P.Show)
newtype Pretty = Pretty { unPretty :: Text } deriving (P.Eq, P.Show)
newtype Previous = Previous { unPrevious :: Bool } deriving (P.Eq, P.Show)
newtype PropagationPolicy = PropagationPolicy { unPropagationPolicy :: Text } deriving (P.Eq, P.Show)
newtype ResourceVersion = ResourceVersion { unResourceVersion :: Text } deriving (P.Eq, P.Show)
newtype SinceSeconds = SinceSeconds { unSinceSeconds :: Int } deriving (P.Eq, P.Show)
newtype Stderr = Stderr { unStderr :: Bool } deriving (P.Eq, P.Show)
newtype Stdin = Stdin { unStdin :: Bool } deriving (P.Eq, P.Show)
newtype Stdout = Stdout { unStdout :: Bool } deriving (P.Eq, P.Show)
newtype TailLines = TailLines { unTailLines :: Int } deriving (P.Eq, P.Show)
newtype TimeoutSeconds = TimeoutSeconds { unTimeoutSeconds :: Int } deriving (P.Eq, P.Show)
newtype Timestamps = Timestamps { unTimestamps :: Bool } deriving (P.Eq, P.Show)
newtype Tty = Tty { unTty :: Bool } deriving (P.Eq, P.Show)
newtype Version = Version { unVersion :: Text } deriving (P.Eq, P.Show)
newtype Watch = Watch { unWatch :: Bool } deriving (P.Eq, P.Show)

-- * Auth Methods

-- ** AuthApiKeyBearerToken
data AuthApiKeyBearerToken =
  AuthApiKeyBearerToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyBearerToken where
  applyAuthMethod _ a@(AuthApiKeyBearerToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req



-- * Custom Mime Types

-- ** MimeJsonPatchjson

data MimeJsonPatchjson = MimeJsonPatchjson deriving (P.Typeable)

-- | @application/json-patch+json@
instance MimeType MimeJsonPatchjson where
  mimeType _ = Just $ P.fromString "application/json-patch+json"
instance A.ToJSON a => MimeRender MimeJsonPatchjson a where mimeRender _ = A.encode
instance A.FromJSON a => MimeUnrender MimeJsonPatchjson a where mimeUnrender _ = A.eitherDecode
-- instance MimeRender MimeJsonPatchjson T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeJsonPatchjson T.Text where mimeUnrender _ = undefined

-- ** MimeJsonstreamwatch

data MimeJsonstreamwatch = MimeJsonstreamwatch deriving (P.Typeable)

-- | @application/json;stream=watch@
instance MimeType MimeJsonstreamwatch where
  mimeType _ = Just $ P.fromString "application/json;stream=watch"
instance A.ToJSON a => MimeRender MimeJsonstreamwatch a where mimeRender _ = A.encode
instance A.FromJSON a => MimeUnrender MimeJsonstreamwatch a where mimeUnrender _ = A.eitherDecode
-- instance MimeRender MimeJsonstreamwatch T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeJsonstreamwatch T.Text where mimeUnrender _ = undefined

-- ** MimeMergePatchjson

data MimeMergePatchjson = MimeMergePatchjson deriving (P.Typeable)

-- | @application/merge-patch+json@
instance MimeType MimeMergePatchjson where
  mimeType _ = Just $ P.fromString "application/merge-patch+json"
instance A.ToJSON a => MimeRender MimeMergePatchjson a where mimeRender _ = A.encode
instance A.FromJSON a => MimeUnrender MimeMergePatchjson a where mimeUnrender _ = A.eitherDecode
-- instance MimeRender MimeMergePatchjson T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeMergePatchjson T.Text where mimeUnrender _ = undefined

-- ** MimeStrategicMergePatchjson

data MimeStrategicMergePatchjson = MimeStrategicMergePatchjson deriving (P.Typeable)

-- | @application/strategic-merge-patch+json@
instance MimeType MimeStrategicMergePatchjson where
  mimeType _ = Just $ P.fromString "application/strategic-merge-patch+json"
instance A.ToJSON a => MimeRender MimeStrategicMergePatchjson a where mimeRender _ = A.encode
instance A.FromJSON a => MimeUnrender MimeStrategicMergePatchjson a where mimeUnrender _ = A.eitherDecode
-- instance MimeRender MimeStrategicMergePatchjson T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeStrategicMergePatchjson T.Text where mimeUnrender _ = undefined

-- ** MimeVndKubernetesProtobuf

data MimeVndKubernetesProtobuf = MimeVndKubernetesProtobuf deriving (P.Typeable)

-- | @application/vnd.kubernetes.protobuf@
instance MimeType MimeVndKubernetesProtobuf where
  mimeType _ = Just $ P.fromString "application/vnd.kubernetes.protobuf"
-- instance MimeRender MimeVndKubernetesProtobuf T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeVndKubernetesProtobuf T.Text where mimeUnrender _ = undefined

-- ** MimeVndKubernetesProtobufstreamwatch

data MimeVndKubernetesProtobufstreamwatch = MimeVndKubernetesProtobufstreamwatch deriving (P.Typeable)

-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance MimeType MimeVndKubernetesProtobufstreamwatch where
  mimeType _ = Just $ P.fromString "application/vnd.kubernetes.protobuf;stream=watch"
-- instance MimeRender MimeVndKubernetesProtobufstreamwatch T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeVndKubernetesProtobufstreamwatch T.Text where mimeUnrender _ = undefined

-- ** MimeYaml

data MimeYaml = MimeYaml deriving (P.Typeable)

-- | @application/yaml@
instance MimeType MimeYaml where
  mimeType _ = Just $ P.fromString "application/yaml"
-- instance MimeRender MimeYaml T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeYaml T.Text where mimeUnrender _ = undefined


